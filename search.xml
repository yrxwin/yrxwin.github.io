<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[Leetcode 14] Longest Common Prefix]]></title>
    <url>%2FLeetcode-14-Longest-Common-Prefix%2F</url>
    <content type="text"><![CDATA[原题说明Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string &quot;&quot;. Example 1:Input: [“flower”,”flow”,”flight”]Output: “fl” Example 2:Input: [“dog”,”racecar”,”car”]Output: “” Note: All given inputs are in lowercase letters a-z. 解题思路本题解法大致分为两步. 第一步获取输入中字符串的最小长度, 用来防止之后访问时的内存越界. 第二步, 依次判断字符串第i位的字符是否一样.需要特别注意一些边界条件, 如输入空列表时直接返回空字符创. 示例代码 (python)1234567891011121314151617181920class Solution(object): def reverse(self, x): """ :type x: int :rtype: int """ if len(strs) == 0: return '' ret = '' min_len = len(strs[0]) for i in range(1, len(strs)): if len(strs[i]) &lt; min_len: min_len = len(strs[i]) for i in range(min_len): for j in range(1, len(strs)): if strs[j][i] != strs[0][i]: return ret ret += strs[0][i] return ret 复杂度分析时间复杂度: O(NK). N为列表长度, K为字符串长度空间复杂度: O(K). K为字符串长度 归纳总结本题比较简单, 但是仍需注意边界条件, 不要大意出错.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 9] Palindrome Number]]></title>
    <url>%2FLeetcode-9-Palindrome-Number%2F</url>
    <content type="text"><![CDATA[原题说明Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1:Input: 121Output: true Example 2:Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3:Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. 解题思路最简单的思路是先转换成字符串, 然后用两个指针来判断. 但是这样需要O(n)的空间复杂度. 为了用O(1)的空间复杂度, 我们可以直接把输入转换成反转后的数字. 如果一个数字反转后, 大小不变, 则是回文数. 解法也比较直观, 按位取余后逐渐生成反转后的数字. 要注意判断是否溢出. 示例代码 (python)1234567891011121314151617class Solution(object): def isPalindrome(self, x): """ :type x: int :rtype: bool """ if x &lt; 0: return False rev = 0 x_ = x while x_ &gt; 0: tmp = rev * 10 + x_ % 10 if (tmp - x_ % 10 ) / 10 != rev: return False rev = tmp x_ /= 10 return x == rev 复杂度分析时间复杂度: O(n)空间复杂度: O(1) 归纳总结在解题时需要判断是否会溢出.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 7] Reverse Integer]]></title>
    <url>%2FLeetcode-7-Reverse-Integer%2F</url>
    <content type="text"><![CDATA[原题说明Given a 32-bit signed integer, reverse digits of an integer. Example 1:Input: 123Output: 321 Example 2:Input: -123Output: -321 Example 3:Input: 120Output: 21 Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1].For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows. 解题思路解法比较简单, 按位取余即可. 难点在于如何处理溢出的问题. 在python中, 会自动处理溢出问题, 只需要直接判断是否在INT_32的范围内即可.但是python的取余在负数上的行为与预期不同, 因此需要记下符号, 并转换成非负数. 其他语言中, 需要在结果乘10之前与INT_MAX作比较，观察是否会溢出. 示例代码 (python)1234567891011121314151617class Solution(object): def reverse(self, x): """ :type x: int :rtype: int """ sign = 1 if x &gt; 0 else -1 x = x if x &gt; 0 else -x ret = 0 while x != 0: ret *= 10 ret += x % 10 x /= 10 ret *= sign if (ret &lt; -2**31) or (ret &gt; 2**31 - 1): return 0 return ret 复杂度分析时间复杂度: O(log n)空间复杂度: O(1) 归纳总结在解题时需要考虑清楚何时会溢出, 或者转换成长整型后再作判断.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 31] Next Permutation]]></title>
    <url>%2FLeetcode-31-Next-Permutation%2F</url>
    <content type="text"><![CDATA[原题说明Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order). The replacement must be in-place and use only constant extra memory. Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column. 1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 解题思路不熟悉排列数的，可以看一下permutation的基本定义。同时，我们要清楚字典顺序的定义Lexicographical order。 最直接的想法是把所有的全排列找出，但是这显然不是最优解，并且不符合题目要求的constant extra memory。 我们这里用一个例子来说明如何找出下一个字典顺序的排列数。假定我们有下面这组排列是 6 5 4 8 7 5 1 我们从后往前看，找到第一个非递减的数，这里是 4 . 我们可以发现，以 6 5 4开头的排列数，8 7 5 1 已经是最后一个排列数，因此需要把 4 做替换 在 8 7 5 1 中，比 4 大的最小的数是 5，因此把 5 和 4 做交换，我们得到 6 5 5 8 7 4 1 显然 6 5 5 8 7 4 1 并不是我们要求的，但只要把最后 4 位 8 7 4 1 做从小到大的排序，变成 1 4 7 8, 我们就得到了想要的字典顺序的排列数 6 5 5 1 4 7 8。 按照这个思路，我们给出相对应的代码。 示例代码 (cpp)123456789101112131415161718192021class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), left = -1; for (int i = n-1; i &gt; 0; i--) &#123; if (nums[i-1] &lt; nums[i]) &#123; left = i-1; break; &#125; &#125; if (left != -1) &#123; for (int i = n-1; i &gt; left; i--) &#123; if (nums[left] &lt; nums[i]) &#123; swap(nums[left], nums[i]); break; &#125; &#125; &#125; reverse(nums.begin() + left + 1, nums.end()); &#125;&#125;; 复杂度分析搜索第一个非递减的数，复杂度为 O(n)，reverse数组，复杂度为 O(n), 所以总的时间复杂度是 O(n) 。没用额外空间，复杂度是 O(1)。 时间复杂度: O(n) 空间复杂度: O(1) 归纳总结这题主要需要先明白 permutation 和 lexicographical order, 然后才能找出 next permutation的规律。借助一些具体的例子，能帮助提供一些思路。比单纯抽象的思考可能更好。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 6] ZigZag Conversion]]></title>
    <url>%2FLeetcode-6-ZigZag-Conversion%2F</url>
    <content type="text"><![CDATA[原题说明The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)123P A H NA P L S I I G Y I R And then read line by line: &quot;PAHNAPLSIIGYIR&quot; Write the code that will take a string and make this conversion given a number of rows:string convert(string s, int numRows); Example 1:12Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3Output: &quot;PAHNAPLSIIGYIR&quot; Example 2:1234567Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4Output: &quot;PINALSIGYAHRPI&quot;Explanation:P I NA L S I GY A H RP I 解题思路这道题需要把一个字符串变成ZigZag的排列后按行输出。所以我们只需要依次判断每个字符应该出现在ZigZag排列中的哪一行就可以了。对于一个N行的ZigZag排列，我们可以把它看作一个周期为2N - 2的循环。在这个周期内，如果一个字符位于周期的前N位，那么它的位数就是行号。如果在N位置后，那么它的行号就是超出部分的倒序，如N + 1那么，行号就是N - 1. (以上行号，从1开始计) 示例代码 (python)12345678910111213141516class Solution(object): def convert(self, s, numRows): """ :type s: str :type numRows: int :rtype: str """ if numRows == 1: return s rows = ['' for i in range(numRows)] for i in range(len(s)): r = i % (2 * numRows - 2) if r &gt;= numRows: r = 2 * numRows - r - 2 rows[r] += s[i] return ''.join(rows) 复杂度分析时间复杂度: O(n) 其中n为s的长度空间复杂度: O(n) 归纳总结这道题难度不高, 只需要考虑清楚字符串转换前后的对应关系即可。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 36] Valid Sudoku]]></title>
    <url>%2FLeetcode-36-Valid-Sudoku%2F</url>
    <content type="text"><![CDATA[原题说明Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. The Sudoku board could be partially filled, where empty cells are filled with the character &#39;.&#39;. Example 1:Input:[ [“5” , “3” , “ . “ , “ . “ , “7” , “ . “ , “ . “ , “ . “ , “ . “], [“6” , “ . “ , “ . “ , “1” , “9” , “5” , “ . “ , “ . “ , “ . “], [“ . “ , “9” , “8” , “ . “ , “ . “ , “ . “ , “ . “ , “6” , “ . “], [“8” , “ . “ , “ . “ , “ . “ , “6” , “ . “ , “ . “ , “ . “ , “3”], [“4” , “ . “ , “ . “ , “8” , “ . “ , “3” , “ . “ , “ . “ , “1”], [“7” , “ . “ , “ . “ , “ . “ , “2” , “ . “ , “ . “ , “ . “ , “6”], [“ . “ , “6” , “ . “ , “ . “ , “ . “ , “ . “ , “2” , “8” , “ . “], [“ . “ , “ . “ , “ . “ , “4” , “1” , “9” , “ . “ , “ . “ , “5”], [“ . “ , “ . “ , “ . “ , “ . “ , “8” , “ . “ , “ . “ , “7” , “9”]]Output: true Example 2:Input:[ [“8” , “3” , “ . “ , “ . “ , “7” , “ . “ , “ . “ , “ . “ , “ . “], [“6” , “ . “ , “ . “ , “1” , “9” , “5” , “ . “ , “ . “ , “ . “], [“ . “ , “9” , “8” , “ . “ , “ . “ , “ . “ , “ . “ , “6” , “ . “], [“8” , “ . “ , “ . “ , “ . “ , “6” , “ . “ , “ . “ , “ . “ , “3”], [“4” , “ . “ , “ . “ , “8” , “ . “ , “3” , “ . “ , “ . “ , “1”], [“7” , “6” , “ . “ , “ . “ , “ . “ , “ . “ , “2” , “8” , “ . “], [“ . “ , “ . “ , “ . “ , “4” , “1” , “9” , “ . “ , “ . “ , “5”], [“ . “ , “ . “ , “ . “ , “ . “ , “8” , “ . “ , “ . “ , “7” , “9”]]Output: falseExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8’s in the top left 3x3 sub-box, it is invalid. Note: A Sudoku board (partially filled) could be valid but is not necessarily solvable. Only the filled cells need to be validated according to the mentioned rules. The given board contain only digits 1-9 and the character ‘.’. The given board size is always 9x9. 解题思路本题要求确定一个 9 x 9 的数独是否valid。题目说明并不要求数独是可解的，因此难度不是很高。 根据数独的规则，需要对每一行，每一列，以及规定的 9 个 3 x 3 的矩阵做检查。因为每次检查需要对9个数进行查重，我们另外写一个函数 isValidSec ，用一个map记录下遍历过的值，遇到有相同的数字是返回false, 否则最终返回true。然后分别按行、列、矩阵块遍历即可。 具体代码如下： 示例代码 (cpp)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; vector&lt;char&gt; nineNum; // 检查行 for (int i = 0; i &lt; board.size(); i++) &#123; if (!isValidSec(board[i])) &#123; return false; &#125; &#125; // 检查列 for (int i = 0; i &lt; board[0].size(); i++) &#123; nineNum.clear(); for (int j = 0; j &lt; board.size(); j++) &#123; nineNum.push_back(board[j][i]); &#125; if (!isValidSec(nineNum)) &#123; return false; &#125; &#125; // 检查矩阵块 for (int i = 0; i &lt; board.size(); i = i + 3) &#123; for (int j = 0; j &lt; board[0].size(); j = j + 3) &#123; nineNum.clear(); for (int l = i; l &lt; i+3; l++)&#123; for (int m = j; m &lt; j+3; m++)&#123; nineNum.push_back(board[l][m]); &#125; &#125; if (!isValidSec(nineNum)) &#123; return false; &#125; &#125; &#125; return true; &#125; bool isValidSec(vector&lt;char&gt;&amp; nineNum) &#123; unordered_map&lt;char, int&gt; table; for(int i = 0 ; i &lt; nineNum.size(); i++) &#123; if (nineNum[i] != '.' &amp;&amp; table.count(nineNum[i]) &gt; 0) &#123; return false; &#125; else &#123; table[nineNum[i]] = 1; &#125; &#125; return true; &#125;&#125;; 复杂度分析我们遍历了3遍整个数独，因此时间复杂度为O(n), 同时空间复杂度为O(n^0.5). 时间复杂度: O(n) 空间复杂度: O(n^0.5) 归纳总结这题的难度不高，按照数独的规则一次做检查即可。代码虽然显得较长，但可读性会显得比较好。之后我们会再介绍这题的进阶版，[LeetCode 37] Sudoku Solver。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Uber</tag>
        <tag>Apple</tag>
        <tag>Hash Table</tag>
        <tag>Snapchat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 10] Regular Expression Matching]]></title>
    <url>%2FLeetcode-10-Regular-Expression-Matching%2F</url>
    <content type="text"><![CDATA[原题说明Given an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;. ‘.’ Matches any single character.‘*’ Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1:Input:s = “aa”p = “a”Output: falseExplanation: “a” does not match the entire string “aa”. Example 2:Input:s = “aa”p = “a*“Output: trueExplanation: ‘*‘ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”. Example 3:Input:s = “ab”p = “.*“Output: trueExplanation: “.*“ means “zero or more (*) of any character (.)”. Example 4:Input:s = “aab”p = “c*a*b”Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”. Example 5:Input:s = “mississippi”p = “mis*is*p*.”Output: false 解题思路以下解题思路以python版本为准, cpp版本则是简化的(无递归)动态规划解答, 读者任选其一即可 如果熟悉Edit distance的话, 可以比较容易得想到用动态规划的办法求解.类似Edit distance的解法, 我们可以构建一个SxP的矩阵来记录状态.该矩阵中位于坐标i, j的值代表字符串s[i:]和Patternp[j:]是否匹配(若为None, 则代表未知).求解该矩阵的过程可以看作遵循一定走法的同时，试图寻找一条从(0, 0)走到(S + 1, P + 1)的路径. (S + 1和P + 1可以看作是s和p的终结状态) 如果s[i]和p[j]是匹配的(s[i] == p[j] 或者 p[j] == &#39;.&#39;): 如果j + 1是*的话，我们可以从(i, j)走到(i, j + 2)代表我们跳过这个pattern, 或者从(i, j)走到(i + 1, j)代表我们选择匹配这个字符 如果不是*的话，那么我们直接从(i, j)走到(i + 1, j + 1). 这意味着我们匹配了(i, j) 如果不匹配: 如果j + 1是*的话, 我们可以从(i, j)走到(i, j + 2)代表我们跳过这个pattern 如果不是, 那么说明必然不匹配, (i, j)的状态是False终结状态就是s和p都用完, 也就是走到(S + 1, P + 1)的时候.如果p用完了, 但是s还有剩余, 那么显然不匹配.如果s用完了, p还有剩余, 那么只有当接下来都是有*的pattern的时候才匹配. 示例代码 (python)1234567891011121314151617181920212223242526272829class Solution(object): def dfs(self, i, j, s, p, dp): if j == len(p): return i == len(s) if i == len(s): if j &lt; len(p) - 1 and p[j + 1] == '*': return self.dfs(i, j + 2, s, p, dp) else: return False if dp[i][j] is not None: return dp[i][j] curr_match = p[j] == '.' or s[i] == p[j] if j + 1 &lt; len(p) and p[j + 1] == '*': dp[i][j] = self.dfs(i, j + 2, s, p, dp) \ or curr_match and self.dfs(i + 1, j, s, p, dp) else: dp[i][j] = curr_match and self.dfs(i + 1, j + 1, s, p, dp) return dp[i][j] def isMatch(self, s, p): """ :type s: str :type p: str :rtype: bool """ dp = [[None for i in range(len(p))] for j in range(len(s))] return self.dfs(0, 0, s, p, dp) 示例代码 (cpp)123456789101112131415161718192021222324252627282930class Solution &#123;public: bool isMatch(string s, string p) &#123; int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false)); dp[0][0] = true; for (int i = 0; i &lt;= m; ++i) &#123; for (int j = 1; j &lt;= n; ++j) &#123; if (p[j - 1] != '*' &amp;&amp; p[j - 1] != '.') &#123; if (i &gt; 0 &amp;&amp; s[i - 1] == p[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; &#125; else if (p[j - 1] == '.') &#123; if (i &gt; 0) &#123; dp[i][j] = dp[i - 1][j - 1]; &#125; &#125; else &#123; if (j == 1) &#123; continue; &#125; dp[i][j] = dp[i][j - 2]; if (i &gt; 0 &amp;&amp; (p[j - 2] == '.' || p[j - 2] == s[i - 1])) &#123; dp[i][j] = dp[i][j] || dp[i - 1][j]; &#125; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 复杂度分析时间复杂度: O(SP), 其中S为s的长度, P为p的长度.空间复杂度: O(SP), 其中S为s的长度, P为p的长度 归纳总结这道题的思路还是比较容易想到用动态规划/递归来做的. 虽然这里python版本使用了DFS，但是因为记录了中间状态，本质上就是动态规划(如果读者细心比较，会发现时间空间复杂度也是一样的). 面试时, 还需要额外注意终结状态的判断和边界条件, 避免出现edge case或者访问了超出边界的矩阵坐标.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Uber</tag>
        <tag>Airbnb</tag>
        <tag>Google</tag>
        <tag>Twitter</tag>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 5] Longest Palindromic Substring]]></title>
    <url>%2FLeetcode-5-Longest-Palindromic-Substring%2F</url>
    <content type="text"><![CDATA[原题说明Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1:Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer. Example 2: Input: &quot;cbbd&quot;Output: &quot;bb&quot; 解题思路很多palindrome相关的问题都可以用动态规划去解决. 做动态规划的问题, 要想清楚以下几件事情: 动归数组代表了什么 递推公式是什么, 从而可以决定从什么方向开始递推. 例如dp[i] = func(dp[i-1])那就从左向右递推, 反之如果dp[i] = func(dp[i+1])那么就要从右向左递推 处理边界条件 回到这道题, 我们用一个二维布尔数组dp[j][i]代表从j开始到i结束的子字符串是否为回文字符串. 初始条件为对于任意下标i, dp[i][i]为true, 这一初始条件可以在递推过程中更新. 递推公式和递推方向请见具体代码. 示例代码 (cpp)1234567891011121314151617181920212223242526class Solution &#123;public: string longestPalindrome(string s) &#123; if (!s.size()) &#123; return ""; &#125; string ret; int left = 0, maxLen = 1; int n = s.size(); vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, false)); for (int i = 0; i &lt; n; ++i) &#123; // i自左向右更新 dp[i][i] = true; for (int j = i - 1; j &gt;= 0; --j) &#123; // j自右向左更新 dp[j][i] = (s[i] == s[j] &amp;&amp; (i - j &lt; 2 || dp[j + 1][i - 1])); // 上面这行就是递推公式 if (dp[j][i]) &#123; if (maxLen &lt; i - j + 1) &#123; maxLen = i - j + 1; left = j; &#125; &#125; &#125; &#125; return s.substr(left, maxLen); &#125;&#125;; 示例代码 (python)12345678910111213141516class Solution(object): def longestPalindrome(self, s): """ :type s: str :rtype: str """ maxlen = 0 ret = None dp = [[None for i in range(len(s))] for j in range(len(s))] for right in range(len(s)): for left in range(right, -1, -1): dp[left][right] = s[left] == s[right] and (right - left &lt; 3 or dp[left + 1][right - 1]) if dp[left][right] and (right - left + 1 &gt; maxlen): maxlen = right - left + 1 ret = s[left:right + 1] return ret 复杂度分析时间复杂度: O(n^2), 其中n为s的长度空间复杂度: O(n^2) 归纳总结动态规划的题一般思路比较难想清楚, 但是有了思路之后代码实现比较容易. 因此面试中不要慌张, 记住本文归纳的三个要点, 先讨论清楚了再开始写代码.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Amazon</tag>
        <tag>Bloomberg</tag>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 4] Median of Two Sorted Arrays]]></title>
    <url>%2FLeetcode-4-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[原题说明There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1:nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 解题思路这道题的最优解比较难想到. 想到之后, 也要注意处理边界条件. 这里我们使用Divide and Conquer的方法: 首先抽象出一个函数, 用于寻找两个数组(由小到大)合并之后的第k个元素. 由于两个数组都是排好序的, 只需要比较他们的第k / 2个元素, 较小的那个元素至多排在合并后的第k - 1个位置, 因此该元素以及其左边的元素不可能为合并后的第k个元素, 均可以排除. 由此我们可以反复调用函数得到最终结果. 边界条件的处理请见代码. 这道题还可以使用二分搜索的办法, 但实际上掌握一种就足以应付面试了, 这里介绍的方法思路相对比较清晰. 读者如果对另一种方法感兴趣, 可以参考这里. 示例代码 (cpp)123456789101112131415161718192021222324class Solution &#123; int findKth(vector&lt;int&gt; nums1, vector&lt;int&gt; nums2, int k) &#123; int m = nums1.size(), n = nums2.size(); if (m &gt; n) &#123; return findKth(nums2, nums1, k); &#125; if (!m) &#123; // 较短的数组为空, 则直接返回另一个数组的第k个元素 return nums2[k - 1]; &#125; if (k == 1) &#123; return min(nums1[0], nums2[0]); &#125; int i = min(m, k / 2), j = min(n, k / 2); if (nums1[i - 1] &lt; nums2[i - 1]) &#123; return findKth(vector&lt;int&gt;(nums1.begin() + i, nums1.end()), nums2, k - i); &#125; return findKth(nums1, vector&lt;int&gt;(nums2.begin() + j, nums2.end()), k - j); &#125;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(); return (findKth(nums1, nums2, (m + n + 1) / 2) + findKth(nums1, nums2, (m + n + 2) / 2)) / 2.0; &#125;&#125;; 示例代码 (python)12345678910111213141516171819202122232425class Solution(object): def findKth(self, nums1, nums2, k): if len(nums1) &gt; len(nums2): nums1, nums2 = nums2, nums1 if len(nums1) == 0: return nums2[k - 1] if k == 1: return min(nums1[0], nums2[0]) k1 = min(len(nums1), k / 2) k2 = min(len(nums2), k / 2) if nums1[k1 - 1] &lt; nums2[k1 - 1]: return self.findKth(nums1[k1:], nums2, k - k1) else: return self.findKth(nums1, nums2[k2:], k - k2) def findMedianSortedArrays(self, nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ return (self.findKth(nums1, nums2, (len(nums1) + len(nums2) + 1) / 2) \ + self.findKth(nums1, nums2, (len(nums1) + len(nums2) + 2) / 2)) / 2. 复杂度分析时间复杂度: O(log(m+n))空间复杂度: O(1) 归纳总结这道题没有见过的话不太容易一下子想到. 面试中遇到不要太高兴直接写答案, 要分析思路. 如果类似难度的题目没有遇到过也不要紧张, 面试官很可能会给出提示, 比如面试官如果提示目标复杂度是log量级的, 那么就应该想到可能是二分搜索或者Divide and Conquer的解法.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Apple</tag>
        <tag>Yahoo</tag>
        <tag>Adobe</tag>
        <tag>Dropbox</tag>
        <tag>Array</tag>
        <tag>Google</tag>
        <tag>Binary Search</tag>
        <tag>Zenefits</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 3] Longest Substring Without Repeating Characters]]></title>
    <url>%2FLeetcode-3-Longest-Substring-Without-Repeating-Characters%2F</url>
    <content type="text"><![CDATA[原题说明Given a string, find the length of the longest substring without repeating characters. Examples:Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. NoteThe answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 解题思路这道题需要用一个Hash Table来记录当前字符上一次出现的index, 用一个变量left记录以当前字符结尾的符合题目条件的substring的左侧index. 注意left初始值为-1, 表示以当前字符结尾的符合题目条件的substring的起始位置等于s的起始位置 (index为0). 示例代码 (cpp)123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; unordered_map&lt;char, int&gt; mapping; int ret = 0, left = -1; for (int i = 0; i &lt; s.size(); ++i) &#123; if (mapping.count(s[i])) &#123; left = max(left, mapping[s[i]]); &#125; mapping[s[i]] = i; ret = max(ret, i - left); &#125; return ret; &#125;&#125;; 示例代码 (python)12345678910111213141516class Solution(object): def lengthOfLongestSubstring(self, s): """ :type s: str :rtype: int """ iLeft = -1 ret = 0 charDict = dict() for iRight in range(len(s)): if s[iRight] in charDict and charDict[s[iRight]] &gt;= iLeft: iLeft = charDict[s[iRight]] charDict[s[iRight]] = iRight if iRight - iLeft &gt; ret: ret = iRight - iLeft return ret 复杂度分析时间复杂度: O(n) 其中n为s的长度空间复杂度: O(1) 因为不同字符的数量有限(一般来说为256), 所以mapping的大小是恒定的 归纳总结这道题中的mapping可以用vector&lt;int&gt;代替unordered_map, 但是作者倾向于使用后者, 因为更有普遍性, 不容易与面试官产生分歧(比如面试官默认s只有26个字母, 那么hard code字符数为256就容易产生分歧), 即使一定要hard code字符数, 也需要和面试官说明. 这道题的思路产生过程并不直接, 面试中如果一下子想不清楚, 建议可以带一个例子, 一步步手动推导结果, 从中或许能够找到一些灵感, 至少也可以让面试官看到思考过程.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Bloomberg</tag>
        <tag>Yelp</tag>
        <tag>Adobe</tag>
        <tag>Hash Table</tag>
        <tag>String</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 2] Add Two Numbers]]></title>
    <url>%2FLeetcode-2-Add-Two-Numbers%2F</url>
    <content type="text"><![CDATA[原题说明You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example:Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 解题思路这道题考察对链表的熟练使用, 以及对边界条件的处理能力. 实际上Leetcode上有很多类似的题目, 同学们可以总结一套自己的模板, 这样面试中比较容易和面试官说清楚思路, 也可以避免出错. 本文的模板(c++)主要有以下几个需要注意的地方: 用一个dummy node来指向返回节点 用一个变量carry来记住进位 while循环有三个, 第一个是两个链表都没有走完的情况, 另两个是其中一个没有走完的情况 最后要记得判断一下carry不为零的情况, 这样还要再加一个节点 该模板思路清晰, 但代码量稍多. 在python版中, 提供了另一种解法. 这种解法以l1 || l2 || carry 为终止条件, 写法上更为简洁. 示例代码 (cpp)123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; int carry = 0; ListNode* dummy = new ListNode(-1); ListNode* node = dummy; while (l1 &amp;&amp; l2) &#123; int tmp = l1-&gt;val + l2-&gt;val + carry; int val = tmp % 10; carry = tmp / 10; node-&gt;next = new ListNode(val); node = node-&gt;next; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; while (l1) &#123; int tmp = l1-&gt;val + carry; int val = tmp % 10; carry = tmp / 10; node-&gt;next = new ListNode(val); node = node-&gt;next; l1 = l1-&gt;next; &#125; while (l2) &#123; int tmp = l2-&gt;val + carry; int val = tmp % 10; carry = tmp / 10; node-&gt;next = new ListNode(val); node = node-&gt;next; l2 = l2-&gt;next; &#125; if (carry) &#123; node-&gt;next = new ListNode(carry); &#125; return dummy-&gt;next; &#125;&#125;; 示例代码 (python)123456789101112131415161718192021222324252627# Definition for singly-linked list.# class ListNode(object):# def __init__(self, x):# self.val = x# self.next = Noneclass Solution(object): def addTwoNumbers(self, l1, l2): """ :type l1: ListNode :type l2: ListNode :rtype: ListNode """ dummy = ListNode(0) curr = dummy carry = 0 while(l1 is not None or l2 is not None or carry): curr_val = 0 curr_val += l1.val if l1 is not None else 0 curr_val += l2.val if l2 is not None else 0 l1 = l1.next if l1 is not None else None l2 = l2.next if l2 is not None else None curr_val += carry carry = curr_val &gt; 9 curr.next = ListNode(curr_val - carry * 10) curr = curr.next return dummy.next 复杂度分析时间复杂度: O(max(m, n)), m和n分别是链表l1和l2的长度空间复杂度: O(max(m, n)) 归纳总结面试中遇到这道题, 写完一定要用特殊例子检查一下. 因为本题思路很直接, 但是边界条件较多, 如果有边界条件没有考虑到会减分. 本文提供了两个模板, 同学们选择比较顺手的作为模板即可, 没有必要来回切换.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Amazon</tag>
        <tag>Bloomberg</tag>
        <tag>Airbnb</tag>
        <tag>Adobe</tag>
        <tag>Linked List</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 1] Two Sum]]></title>
    <url>%2FLeetcode-1-Two-Sum%2F</url>
    <content type="text"><![CDATA[原题说明Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 解题思路这是一道非常经典的面试题. 由于被面的太多, 现在一般会考察这道题的变种, 但是原题也还是经常出现在电话面试中, 或者被当做热身题. 这道题的O(n)解法是利用hash table来存储遍历过的元素, 对于当前的元素nums[i], 我们只需要判断target - nums[i]是否在哈希表中即可. 这道题可能会有follow up问能否不用额外空间, 那么就需要牺牲时间复杂度: 可以先排序, 然后用双指针两头扫遍历一遍即可, 这个方法此处不做赘述, 在Three Sum中会详细介绍. 示例代码 (cpp)12345678910111213class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; mapping; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (mapping.count(target - nums[i])) &#123; return &#123;mapping[target - nums[i]], i&#125;; &#125; mapping[nums[i]] = i; &#125; return &#123;-1, -1&#125;; &#125;&#125;; 示例代码 (python)123456789101112class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] """ numsIdxDict = dict() for i in range(len(nums)): if (target - nums[i]) in numsIdxDict: return [i, numsIdxDict[(target - nums[i])]] numsIdxDict[nums[i]] = i 复杂度分析时间复杂度: O(n) n为nums数组长度空间复杂度: O(n) 归纳总结面试中如果遇到这道题, 也不要太高兴直接开始写答案, 还是要好好分析思路, 问清楚要求, 比如是不是一定有解, 可能有多少解, 能不能用额外空间等等.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Microsoft</tag>
        <tag>Amazon</tag>
        <tag>Bloomberg</tag>
        <tag>Uber</tag>
        <tag>Linkedin</tag>
        <tag>Apple</tag>
        <tag>Airbnb</tag>
        <tag>Yelp</tag>
        <tag>Yahoo</tag>
        <tag>Adobe</tag>
        <tag>Dropbox</tag>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 239] Sliding Window Maximum]]></title>
    <url>%2FLeetcode-239-Sliding-Window-Maximum%2F</url>
    <content type="text"><![CDATA[原题说明Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. Example:Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7]Explanation:12345678Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note:You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array. Follow up:Could you solve it in linear time? 解题思路这是一道比较好的面试题, 因为用priority queue的方法是容易想到的, 但是在实现的过程中也需要考虑一些边界条件, 比如刚开始扫的时候队列中少于k个数怎么处理, 什么时候结束等等. 这样方便面试官考察基本的coding能力. 对于followup, 相对来说要难一些, 用了双向队列(deque)结构来存储当前sliding window, 类似的问题有[LeetCode 316] Remove Duplicate Letters 移除重复字母, [Leetcode 739] Daily Temperatures. 如果面试中能够想到的话, 就很接近Strong Hire了. 为了方便更新sliding window以及取出当前最大元素, 我们用的数据结构是deque. deque存储的是nums中对应元素的index. 主要思路是使得deque中的元素由老到新, 由大到小排列, 并且只存储之后可能会成为最大值的元素. 具体的方法是: 首先将超出窗口范围的老元素从队列头移出, 每次新扫到的元素与队列尾元素比较, 如果新的元素大, 则pop当前队尾元素(因为被pop的元素在窗口内必然小于新元素, 所以之后任意一步都不会成为最大值), 不然则直接插入新元素. 这样每走一步, 当前的deque头元素即为窗口中的最大值. 示例代码 (cpp)12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; deque&lt;int&gt; dq; vector&lt;int&gt; rets; for (int i = 0; i &lt; nums.size(); ++i) &#123; if (i &gt;= k) &#123; if (dq.front() == i - k) &#123; dq.pop_front(); &#125; &#125; while (!dq.empty() &amp;&amp; nums[i] &gt; nums[dq.back()]) &#123; dq.pop_back(); &#125; dq.push_back(i); if (i &gt;= k - 1) &#123; rets.push_back(nums[dq.front()]); &#125; &#125; return rets; &#125;&#125;; 示例代码 (python)123456789101112131415161718class Solution(object): def maxSlidingWindow(self, nums, k): """ :type nums: List[int] :type k: int :rtype: List[int] """ ret = [] queue = collections.deque() for i in range(len(nums)): while(len(queue) and (queue[0] &lt;= i - k)): queue.popleft() while(len(queue) and (nums[queue[-1]] &lt; nums[i])): queue.pop() queue.append(i) if i &gt;= k - 1: ret.append(nums[queue[0]]) return ret 复杂度分析时间复杂度: O(n) 其中n为nums长度空间复杂度: O(k) 归纳总结同学们可以将解题思路中总结的类似题目一起做一遍, 这样对于处理这类问题会有更好的理解.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Google</tag>
        <tag>Zenefits</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 803] Bricks Falling When Hit]]></title>
    <url>%2FLeetcode-803-Bricks-Falling-When-Hit%2F</url>
    <content type="text"><![CDATA[原题说明We have a grid of 1s and 0s; the 1s in a cell represent bricks. A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop. We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure. Return an array representing the number of bricks that will drop after each erasure in sequence. Example 1:Input:grid = [[1,0,0,0],[1,1,1,0]]hits = [[1,0]]Output: [2]Explanation:If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2. Example 2:Input:grid = [[1,0,0,0],[1,1,0,0]]hits = [[1,1],[1,0]]Output: [0,0]Explanation:When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping. Note that the erased brick (1, 0) will not be counted as a dropped brick. Note: The number of rows and columns in the grid will be in the range [1, 200]. The number of erasures will not exceed the area of the grid. It is guaranteed that each erasure will be different from any other erasure, and located inside the grid. An erasure may refer to a location with no brick - if it does, no bricks drop. 解题思路这道题tag里有union find的方法, 解题思路可以参考官方解答. 实际上, 用DFS一样可以给出清晰的解答. 在面试过程中, 除非利用union find可以明显简化问题, 否则不是很推荐使用. 曾经有人使用union find解答number of islands I, 就被面试官追问, union find如何删除一个节点, 如果不熟悉的话就会很被动. 这里我们提供两种DFS的思路。 方法1(c++): 每次落下一个砖块, 要从砖块的上下左右四个方向分别做DFS, 第一遍判断DFS经过的砖块是否与顶部砖块连通, 如果不连通, 则该砖块会落下, 并且所有与之相连的砖块都不与顶部砖块连通, 因此做第二遍DFS, 标记访问过的砖块为落下. 注意每一次DFS都是一次新的遍历, 因此我们使用_id的来标记第_id次DFS, 并且在新的一次遍历前更新id. 方法2(python): 将所有击落的砖块，先行去除(在Grid矩阵中-1)，接着用DFS找出所有与顶部砖块连通的砖块，并用一个矩阵connected记录(既表示已经访问过，又表示与顶部连通)。然后，从最后一块被击落的砖块向前逐一恢复。每次恢复被击落砖块时，在Grid中+1，并且判断该位置是否原来有砖块存在，是否处于顶部或者四周有没有与顶部连通的砖块存在。若满足这些条件，说明该被击落的砖块可以恢复，并且以它为起点做DFS，所有与他连通的砖块都可以被恢复，恢复的数量即为该次击落后，落下砖块的数量。 示例代码 (cpp)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123; vector&lt;vector&lt;int&gt;&gt; _g; // 用一个私有变量 _g 可以减少 fall 函数的参数数量 int _m, _n; int _id = 1; vector&lt;int&gt; dx = &#123;-1, 0, 0, 1&#125;; vector&lt;int&gt; dy = &#123;0, -1, 1, 0&#125;; bool fall(int x, int y, bool isClear, int&amp; cnt) &#123; if (x &lt; 0 || x &gt;= _m || y &lt; 0 || y &gt;= _n) &#123; return true; &#125; if (_g[x][y] == _id || _g[x][y] == 0) &#123; return true; &#125; if (x == 0) &#123; return false; &#125; _g[x][y] = isClear ? 0 : _id; ++cnt; for (int i = 0; i &lt; 4; ++i) &#123; int xx = x + dx[i], yy = y + dy[i]; if (!fall(xx, yy, isClear, cnt)) &#123; return false; &#125; &#125; return true; &#125;public: vector&lt;int&gt; hitBricks(vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;int&gt;&gt;&amp; hits) &#123; _m = grid.size(); _n = grid[0].size(); _g.swap(grid); vector&lt;int&gt; rets; for (auto&amp; hit : hits) &#123; int ret = 0; int x = hit[0], y = hit[1]; _g[x][y] = 0; for (int i = 0; i &lt; 4; ++i) &#123; ++_id; int xx = x + dx[i]; int yy = y + dy[i]; int cnt = 0; if (!fall(xx, yy, false, cnt)) &#123; continue; &#125; ++_id; ret += cnt; fall(xx, yy, true, cnt); &#125; rets.push_back(ret); &#125; return rets; &#125; &#125;; 示例代码 (python)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution(object): def check_valid(self, r, c, grid): if r &lt; 0 or r &gt;= len(grid) or c &lt; 0 or c &gt;= len(grid[0]) or grid[r][c] &lt; 1: return False else: return True def dfs_connect(self, grid, connected, r, c): num_connected = 1 for rr, cc in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]: if self.check_valid(rr, cc, grid) and not connected[rr][cc]: connected[rr][cc] = 1 num_connected += self.dfs_connect(grid, connected, rr, cc) return num_connected def build_connection(self, grid): connected = [[0 for c in range(len(grid[0]))] for r in range(len(grid))] for c in range(len(grid[0])): if self.check_valid(0, c, grid): connected[0][c] = 1 self.dfs_connect(grid, connected, 0, c) return connected def check_new_block_connection(self, r, c, grid, connected): if grid[r][c] &lt; 1: return False if r == 0: return True for rr, cc in [(r - 1, c), (r + 1, c), (r, c - 1), (r, c + 1)]: if self.check_valid(rr, cc, grid) and connected[rr][cc] == 1: return True return False def hitBricks(self, grid, hits): """ :type grid: List[List[int]] :type hits: List[List[int]] :rtype: List[int] """ ret = [0 for i in range(len(hits))] for hit in hits: grid[hit[0]][hit[1]] -= 1 connected = self.build_connection(grid) for idx in range(len(hits)): r, c = hits[-1 - idx] grid[r][c] += 1 if self.check_new_block_connection(r, c, grid, connected): connected[r][c] = 1 add_num = self.dfs_connect(grid, connected, r, c) - 1 ret[-1 - idx] = add_num return ret 复杂度分析方法1：时间复杂度: O(N * Q) 其中N是砖块数量, Q是hits的长度空间复杂度: O(1) 方法2：时间复杂度: O(N + Q) 其中N是砖块数量, Q是hits的长度空间复杂度: O(N) 归纳总结这是一道比较复杂的深度遍历问题, 如果同学一下子不会做也没有关系, 面试的时候不要紧张, 要和面试官讨论并且慢慢理清思路.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 819] Most Common Word]]></title>
    <url>%2FLeetcode-819-Most-Common-Word%2F</url>
    <content type="text"><![CDATA[原题说明Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn’t banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase. Example:Input:paragraph = “Bob hit a ball, the hit BALL flew far after it was hit.”banned = [“hit”]Output: “ball”Explanation:“hit” occurs 3 times, but it is a banned word.“ball” occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.Note that words in the paragraph are not case sensitive,that punctuation is ignored (even if adjacent to words, such as “ball,”),and that “hit” isn’t the answer even though it occurs more because it is banned. Note: 1 &lt;= paragraph.length &lt;= 1000. 1 &lt;= banned.length &lt;= 100. 1 &lt;= banned[i].length &lt;= 10. The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.) paragraph only consists of letters, spaces, or the punctuation symbols !?’,;. Different words in paragraph are always separated by a space. There are no hyphens or hyphenated words. Words only consist of letters, never apostrophes or other punctuation symbols. 解题思路这道题可以通过hash table来建立每个单词与其出现频率的对应关系, 在遍历paragraph的时候统计单词出现的频率, 并更新当前的最高频单词.由于题目相对简单, 面试的时候需要在较短的时间内想到建立怎样的对应关系, 存储结构应该如何设计 (比如用map还是unordered_map, key和value分别是什么, 两者能不能倒过来等等)另外对于使用cpp的同学来说, 熟练掌握istringstream和getline这些基础的I/O interface还是比较加分的. 示例代码 (cpp)12345678910111213141516171819202122232425class Solution &#123;public: string mostCommonWord(string paragraph, vector&lt;string&gt;&amp; banned) &#123; istringstream iss(paragraph); unordered_set&lt;string&gt; banSet(banned.begin(), banned.end()); unordered_map&lt;string, int&gt; mapping; string cur, ret; int curMax = 0; while (getline(iss, cur, ' ')) &#123; string formatStr; for (int i = 0; i &lt; cur.size(); ++i) &#123; char ch = tolower(cur[i]); if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') &#123; formatStr += ch; &#125; &#125; mapping[formatStr]++; if (mapping[formatStr] &gt; curMax &amp;&amp; !banSet.count(formatStr)) &#123; curMax = mapping[formatStr]; ret = formatStr; &#125; &#125; return ret; &#125;&#125;; 示例代码 (python)12345678910111213141516171819class Solution(object): def mostCommonWord(self, paragraph, banned): """ :type paragraph: str :type banned: List[str] :rtype: str """ words_dict = collections.Counter() top_word = None top_freq = 0 words = re.split("[ !?',;.]+", paragraph) for word in words: if word.lower() not in banned: words_dict[word.lower()] += 1 if words_dict[word.lower()] &gt; top_freq: top_word = word.lower() top_freq = words_dict[word.lower()] return top_word 复杂度分析时间复杂度: O(n) (n为paragraph包含的单词数)空间复杂度: O(m + n) (m为banned长度) 归纳总结像这样一道比较基础的算法设计题, 如果真正面试的时候遇到, 尽量不要一上来就写答案, 可以在白板上列举一下可能的数据结构及做法, 说明为什么最后选择这样做(比如只有这样才行得通或者效率更高). 通过这样的分析可以让面试官看到真实清晰的思路.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 812] Largest Triangle Area]]></title>
    <url>%2FLeetcode-812-Largest-Triangle-Area%2F</url>
    <content type="text"><![CDATA[原题说明You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points. Example:Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]]Output: 2Explanation:The five points are show in the figure below. The red triangle is the largest. Notes: 3 &lt;= points.length &lt;= 50. No points will be duplicated. -50 &lt;= points[i][j] &lt;= 50. Answers within 10^-6 of the true value will be accepted as correct. 解题思路这道题主要考察解析几何中三角形面积的计算(如叉乘计算面积, 行列式计算面积 ), 也比较适合Google电话面试或者Intern面试的难度, 可能会用来考察简历有相关背景的面试者.做法上比较暴力, 直接三重循环找到所有可能组成三角形的点计算最大面积即可, 还是要求快速形成思路, 代码清晰, 建议把叉乘部分单独写成一个Function, 这样做即使面试时叉乘公式不记得了, 但是整体思路清晰, 也可能会过面试. 示例代码 (cpp)123456789101112131415161718class Solution &#123; double multiply(vector&lt;int&gt; v1, vector&lt;int&gt; v2) &#123; return 0.5 * abs(v1[0] * v2[1] - v2[0] * v1[1]); &#125;public: double largestTriangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int n = points.size(); double ret = 0; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i + 1; j &lt; n; ++j) &#123; for (int k = j + 1; k &lt; n; ++k) &#123; ret = max(ret, multiply(&#123;points[k][0] - points[i][0], points[k][1] - points[i][1]&#125;, &#123;points[k][0] - points[j][0], points[k][1] - points[j][1]&#125;)); &#125; &#125; &#125; return ret; &#125;&#125;; 示例代码 (python)123456789101112131415161718class Solution(object): def calArea(self, p1, p2, p3): #Use Determinant to get triangle area return .5 * abs(p1[0] * p2[1] + p2[0] * p3[1] + p3[0] * p1[1] - p1[0] * p3[1] - p2[0] * p1[1] - p3[0] * p2[1]) def largestTriangleArea(self, points): """ :type points: List[List[int]] :rtype: float """ maxS = 0 for i in range(len(points) - 2): for j in range(i + 1, len(points) - 1): for k in range(j + 1, len(points)): S = self.calArea(points[i], points[j], points[k]) if S &gt; maxS: maxS = S return maxS 复杂度分析时间复杂度: O(N^3)空间复杂度: O(1) 归纳总结谷歌有时候会考察矩阵叉乘, 点乘相关的知识点, 面试的时候即使不记得也可以问面试官要提示, 当然如果自己能够记得肯定是加分的. 之后会整理相关的考题.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 832] Flipping an Image]]></title>
    <url>%2FLeetcode-832-Flipping-an-Image%2F</url>
    <content type="text"><![CDATA[原题说明Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1:Input: [[1,1,0],[1,0,1],[0,0,0]]Output: [[1,0,0],[0,1,0],[1,1,1]]Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2:Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Notes: 1 &lt;= A.length = A[0].length &lt;= 20 0 &lt;= A[i][j] &lt;= 1 解题思路这道题并不难, 属于谷歌面试中的热身题或者是Intern电话面试的难度. 关键是要在短时间内形成清晰的思路, 并且形成代码, 为之后的题或者followup争取到足够的时间.这里介绍的思路是逐行进行swap, 然后每个元素异或, 虽然这样每个元素会扫面两遍, 但是思路足够清晰. 示例代码 (cpp)1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; for (auto &amp;row : A) &#123; for (int i = 0; i &lt; row.size() / 2; ++i) &#123; swap(row[i], row[row.size() - 1 - i]); &#125; for (auto &amp;ele : row) &#123; ele ^= 1; &#125; &#125; return A; &#125;&#125;; 示例代码 (python)12345678910class Solution(object): def flipAndInvertImage(self, A): """ :type A: List[List[int]] :rtype: List[List[int]] """ for i in range(len(A)): A[i] = A[i][::-1] A[i] = [ele^1 for ele in A[i]] return A 复杂度分析时间复杂度: O(n^2) (n为A的边长)空间复杂度: O(1) 归纳总结需要训练在白板上10分钟之内搞定.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 410] Split Array Largest Sum]]></title>
    <url>%2FLeetcode-410-Split-Array-Largest-Sum%2F</url>
    <content type="text"><![CDATA[原题说明Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays. Note: If n is the length of array, assume the following constraints are satisfied: 1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) Examples: Input: nums = [7,2,5,10,8] m = 2 Output: 18 Explanation: There are four ways to split nums into two subarrays. The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18. 解题思路本题给出一个数组nums和一个整数m,要求把数组nums分成连续的m份，找到所有分类中，子数组最大和的最小值。 显然，最简单的方法是可以使用DFS做暴力搜索，但是这样时间复杂度相当于从n-1个元素中抽取m-1个元素，为O(n^m)，会 TLE。 因为子数组本身是连续的，我们可以想到用动态规划 Dyanmic Programming 来设计解法。定义f[i][j]为把数组 nums[0,1,..,i]分成j份后最大子数组和的最小值。显然，我们会有以下公式:f[i][j] = max(f[k][j-1],nums[k+1]+...+nums[i) for all valid k用动态规划，从f[0][0]出发，最后返回f[n][m] 即可。时间复杂度为O(n^2*m)，并且空间复杂度为O(n*m)。 这里，介绍一种更好的算法，运用 Binary Search 。考虑到数组元素都是非负整数，所以答案也一定是整数。同时，答案一定存在于 0 到 数组元素和sum of array之间。因此，我们只需能够判断，对于任意一个整数mid，是否存在一个分类使得nums能分成m份，并且最大子数组的和不超过mid。如果能，我们下调Binary Search，如果不能，我们上调Binary Search。 判断的算法也很简单，我们用贪心算法Greedy。用tmpsum记录当前子数组的和，用count记录当前的分类数。如果当前元素num加上tmpsum不超过mid，更新tmpsum = tmpsum + num；如果超过mid，更新tmpsum = 0并更新count = count + 1。遍历完数组nums， 当count &lt;= m，返回 True，反之返回False。 示例代码 (python)12345678910111213141516171819202122232425262728class Solution: def splitArray(self, nums, m): """ :type nums: List[int] :type m: int :rtype: int """ low, high = 0, sum(nums) while low + 1 &lt; high: mid = int(low + (high - low) /2) if self.determinTrue(mid, nums, m): high = mid else: low = mid return i if self.determinTrue(low, nums, m) else high def determinTrue(self, target, nums, m): n = len(nums) tmpsum, count = 0, 1 for num in nums: if num &gt; target: return False if tmpsum + num &lt;= target: tmpsum += num else: tmpsum = num count += 1 return count &lt;= m 复杂度分析每次贪心算法时间复杂度为O(n)，同时Binary Search需要的时间复杂度是O(log(sum of array))。因此总的时间复杂度为O(n*(log(sum of array)))。而空间复杂度为O(n)。 时间复杂度: O(n*(log(sum of array))) 空间复杂度: O(n) 归纳总结当数组的和不过分大时，一般情况下，Binary Search 的时间复杂度都会优于Dyanmic Programming。当然，这里能使用 Binary Search的前提是数组元素都是非负整数而Dynamic Programming则没有这个限制 。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Dynamic Programming</tag>
        <tag>Binary Search</tag>
        <tag>Baidu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 719] Find K-th Smallest Pair Distance]]></title>
    <url>%2FLeetcode-719-Find-K-th-Smallest-Pair-Distance%2F</url>
    <content type="text"><![CDATA[原题说明Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. **Example 1**: Input: nums = [1,3,1] k = 1 Output: 0 Explanation: Here are all the pairs: (1,3) -&gt; 2 (1,1) -&gt; 0 (3,1) -&gt; 2 Then the 1st smallest distance pair is (1,1), and its distance is 0. Note: 2 &lt;= len(nums) &lt;= 10000. 0 &lt;= nums[i] &lt; 1000000. 1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2. 解题思路题目要求求出第 k 个最小 pair 的距离。对于长度为n的数组，一共有 n*(n-1)个pair。如果我们求出所有 pair 的距离，然后排序找出第k个最小的pair的距离，时间复杂度会是 O(n^2log(n))，同时空间复杂度会是 O(n^2)， 这显然不是最优解。 可以对以上解法稍作优化，使用优先队列进行排序，这样时间复杂度会是O(n^2log(k))，空间复杂度会降低到 O(k)。 这题更好的一个解法是使用 Binary Search。对数组先进行排序，我们可以得到 pair 的最大距离end。因为题目讨论的都是整数，所以答案一定是在0到end的范围内的整数。我们在这个范围内使用 Binary Search，对于每一个搜索的值 mid，我们用一个函数count判断比mid小的 pair 的距离的个数。如果小于k，则让 start == mid ；反之，则让 end == mid。 因为我们对数组事先进行了排序，所以每一次调用count函数，用window sliding的方法，只需要遍历一边数组就可以。 示例代码 (python)12345678910111213141516171819202122232425class Solution: def smallestDistancePair(self, nums, k): """ :type nums: List[int] :type k: int :rtype: int """ nums.sort() start, end = 0, nums[-1] - nums[0] while start + 1 &lt; end: mid = int(start + (end - start)/2) if self.count(nums, mid) &lt; k: start = mid else: end = mid return start if self.count(nums,start) &gt;= k else end def count(self, nums, mid): #比mid小的pair数 left, right, ans = 0, 0, 0 while right != len(nums): while nums[right] - nums[left] &gt; mid: left += 1 ans += right - left right += 1 return ans 示例代码 (cpp)12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int countPairs(vector&lt;int&gt;&amp; nums, int mid) &#123; int low = 0, high = 0, res = 0; while(high &lt; nums.size()) &#123; while(nums[high] - nums[low] &gt; mid) &#123; low++; &#125; res += high - low; high++; &#125; return res; &#125; int smallestDistancePair(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int low = nums[1] - nums[0], high = nums[nums.size()-1] - nums[0], mid; for(int i = 0; i &lt; nums.size() - 1; i++) &#123; if (nums[i + 1] - nums[i] &lt; low) &#123; low = nums[i + 1] - nums[i]; &#125; &#125; while(low &lt; high) &#123; mid = (low + high) / 2; if (countPairs(nums, mid) &lt; k) &#123; low = mid + 1; &#125; else &#123; high = mid; &#125; &#125; return low; &#125;&#125;; 复杂度分析排序数组的时间复杂度为O(n log(n))， Binary Search的遍历次数为O(log(n))，每次遍历调用 count 函数，需要遍历一边数组，时间复杂度为O(n)， 所以总的时间复杂度是O(n log(n))。用 in-place 的方法排序，不需要额外的空间，总的空间复杂度为 O(1) 时间复杂度: O(n log(n)) 空间复杂度: O(1) 归纳总结在有有效精度或者整数等条件给出的前提下，用 Binary Search 往往能有效的优化一些算法。之后我们会再多讨论这类题型。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Google</tag>
        <tag>Binary Search</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 777] Swap Adjacent in LR String]]></title>
    <url>%2FLeetcode-777-Swap-Adjacent-in-LR-String%2F</url>
    <content type="text"><![CDATA[原题说明In a string composed of &#39;L&#39;, &#39;R&#39;, and &#39;X&#39; characters, like “RXXLRXRXL”, a move consists of either replacing one occurrence of &quot;XL&quot; with &quot;LX&quot;, or replacing one occurrence of &quot;RX&quot; with &quot;XR&quot;. Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other. Example: Input: start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot; Output: True Explanation: We can transform start to end following these steps: RXXLRXRXL -&gt; XRXLRXRXL -&gt; XRLXRXRXL -&gt; XRLXXRRXL -&gt; XRLXXRRLX Note: 1 &lt;= len(start) = len(end) &lt;= 10000. Both start and end will only consist of characters in {&#39;L&#39;, &#39;R&#39;, &#39;X&#39;}. 解题思路题目要求根据给定的规则，判断能否从 start string 变换到 end string 。 给出了两种变换的规则，从“XL”到“LX”和从“RX”到“XR”。所以我们可以给出两条规律： 如果start能变换到end，那么除去两个字符串中的&quot;X&quot;，剩余的字符串一定相同。因为任意&quot;R&quot;和&quot;L&quot;的相对顺序都不会发生变化，我们定义出去&quot;X&quot;的字符串为有效字符串 根据变换的规则，&quot;L&quot;不能向右移，“R”不能向左移，所以 start 中“L”对应的 index &quot;i&quot; 一定不小于 end 中 “L”对应的index &quot;j&quot;；start 中“R”对应的 index &quot;i&quot; 一定不大于 end 中 “R”对应的index &quot;j&quot;； i &gt;= j, 如果 start[i]==end[j]==”L” i &lt;= j, 如果 start[i]==end[j]==”R” 示例代码 (python)1234567891011121314151617181920212223242526class Solution: def canTransform(self, start, end): """ :type start: str :type end: str :rtype: bool """ # 第一条规律 startRemove = "".join(start.split("X")) endRemove = "".join(end.split("X")) if startRemove != endRemove: return False # 第二条规律 i, j, n = 0, 0, len(start) while(j &lt; n and i &lt; n): while(j &lt; n and end[j] == 'X'): j += 1 while(i &lt; n and start[i] == 'X'): i += 1 if(i == n and j == n): break if(start[i] == 'R' and i &gt; j) or (start[i] == 'L' and i &lt; j): return False i += 1 j += 1 return True 复杂度分析每个字符串遍历一边，时间复杂度为O(n)。没有用额外空间，时间复杂度为O(1)时间复杂度: O(n)空间复杂度: O(1) 归纳总结本题需要对变换的规律做出总结，找出不变量，从而做出进一步判断。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Brainteaser</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 805] Split Array With Same Average]]></title>
    <url>%2FLeetcode-805-Split-Array-With-Same-Average%2F</url>
    <content type="text"><![CDATA[原题说明In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.) Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty. Example : Input: [1,2,3,4,5,6,7,8] Output: true Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5. Note: The length of A will be in the range [1, 30]. A[i] will be in the range of [0, 10000]. 解题思路给定一个数组，题目要求判断能否把数组分成两个数组，是它们的平均值相同。 我们说明以下三点事实： 如果存在这样的分组，它们各自的平均值一定等于原数组的平均值，反之则不存在 我们只要找到任意一个分组，使得它的平均值等于原数组的平均值，就可以判定剩余数组成的数组的平均值也与其相等，从在给出存在的判断 如果存在这样的分组，平均值（原数组以及分类后的两个数组的平均值都相等）乘以任意数组的长度，都一定是一个整数。这点会简化我们的计算。 因此，我们可以用上述三点事实，来给出我们的算法。因为是分成两个数组，所以必定有一个数组的长度不超过原数组长度的一般。枚举从1到原数组长度的一半k，对其中乘以平均值为整数的那些值sum，我们用递归的方法找出是否能从原数组中挑选出给k个元素，使得它们的和等于sum。如果能找出其中任意一个，存在这种分类，反之则不存在。 为了防止TLE,我们用一个字典visit来记录遍历的情况。visit的key是一个元组（target，k），表示需要寻找的目标和元素个数，visit的value是i,表示从第i个元组之后找。这样如果新的i比visit中对应key的value来的大，说明这种情况已经遍历过，则无需重复遍历。否则需要更新visit，并继续搜索。 示例代码 (python)123456789101112131415161718192021class Solution: def splitArraySameAverage(self, A): """ :type A: List[int] :rtype: bool """ visit = &#123;&#125; # 记录搜索过得信息 n, s = len(A), sum(A) return any(self.find(A, s * k / n, k, 0, visit) for k in range(1, int(n / 2) + 1) if s * k % n == 0) def find(self, A, target, k, i, visit): if (target, k) in visit and visit[(target, k)] &lt;= i: return False if k == 0: return target == 0 if k + i &gt; len(A): return False ans = self.find(A, target - A[i], k - 1, i + 1, visit) or self.find(A, target, k, i + 1, visit) if not ans: visit[(target, k)] = min(visit.get((target,k), len(A)), i) return ans 复杂度分析我们用了一个visit来记录一些中间过程，它的空间复杂度是O(ele_max*n^3),其中ele_max是A[i]的最大值，这里是10000。对于时间复杂度，也是同样的情况，时间复杂度: O(ele_max*n^3)空间复杂度: O(ele_max*n^3) 归纳总结这题如果使用暴力搜索，一定会超时。利用两个数组平均值相等的性质，可以做的剪枝dfs。同时我们用一个map来记录已经搜索的信息，进一步避免了不必要的计算。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 297] Serialize and Deserialize Binary Tree]]></title>
    <url>%2FLeetcode-297-Serialize-and-Deserialize-Binary-Tree%2F</url>
    <content type="text"><![CDATA[原题说明Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. For example, you may serialize the following tree 1 / \ 2 3 / \ 4 5 as &quot;[1,2,3,null,null,4,5]&quot;, just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself. Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless. 解题思路本题要求设计两个函数，系列化和反序列化（重构）二叉树。 序列化函数：我们可以用层序遍历的方法将二叉树储存，可以参考[LeetCode 102] Binary Tree Level Order Traversal 二叉树层序遍历， 需要注意的一点，遍历过程中，若是当前节点的子节点是空的，我们依然需要储存，这样才能在反序列函数中重构二叉树。 反序列化函数：用队列的数据结构，按层序读取序列，每次读取两个元素，对应当前节点的左右子节点。当序列元素非空时，将其设为当前节点对应的左节点或右节点，并加入队列内。直到读取完所有序列内元素，完成二叉树的重构。 另一种思路是用前序遍历。因为递归的实现比较trivial，这里用递推实现。同样，为了正确重构，我们仍然需要储存空节点。这里我们加入writeAndReturnNode这个辅助函数，让我们可以最大程度的复用原始的递推代码。需要额外注意不要使同一个节点被写一次以上。在解码时，由于在原代码push时不知道右子节点的情况，因此改为push本节点，并在pop时获取正确右子节点状态后，将curr改为右子节点。 示例代码 思路一 (python)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Codec: def serialize(self, root): """Encodes a tree to a single string. :type root: TreeNode :rtype: str """ if not root: return "None" queue, ans = collections.deque(), collections.deque() queue.append(root) while queue: tmpNode = queue.popleft() if tmpNode == None: ans.append(tmpNode) else: ans.append(tmpNode.val) queue.extend([tmpNode.left,tmpNode.right]) return str(list(ans)) #序列返回的结构和题目例子中给出的是一致的 def deserialize(self, data): """Decodes your encoded data to tree. :type data: str :rtype: TreeNode """ data = data[1:-1].split(",") if not self.represents_int(data[0]) or not data: return None else: root = TreeNode(int(data[0])) idx = 1 queue = collections.deque() queue.append(root) while idx != len(data): tmpNode = queue.popleft() if self.represents_int(data[idx]): tmpNode.left = TreeNode(int(data[idx])) queue.append(tmpNode.left) if self.represents_int(data[idx+1]): tmpNode.right = TreeNode(int(data[idx+1])) queue.append(tmpNode.right) idx += 2 return root def represents_int(self, num): try: int(num) return True except ValueError: return False # Your Codec object will be instantiated and called as such:# codec = Codec()# codec.deserialize(codec.serialize(root)) 示例代码 思路二 (cpp)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Codec &#123;public: TreeNode* writeAndReturnNode(TreeNode* node, ostringstream&amp; ret) &#123; if (node) &#123; ret &lt;&lt; node-&gt;val &lt;&lt; " "; &#125; else &#123; ret &lt;&lt; "X "; &#125; return node; &#125; // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; ostringstream ret; stack&lt;TreeNode*&gt; nodeStack; while (writeAndReturnNode(root, ret) || !nodeStack.empty()) &#123; while(root) &#123; nodeStack.push(root-&gt;right); root = writeAndReturnNode(root-&gt;left, ret); &#125; if (!nodeStack.empty()) &#123; root = nodeStack.top(); nodeStack.pop(); &#125; &#125; return ret.str(); &#125; TreeNode* readAndReturnNode(istringstream&amp; inStream) &#123; string nextVal; inStream &gt;&gt; nextVal; if (nextVal == "X") &#123; return NULL; &#125; else &#123; return new TreeNode(stoi(nextVal)); &#125; &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; TreeNode *root, *curr, *next; stack&lt;TreeNode*&gt; nodeStack; istringstream inStream(data); root = readAndReturnNode(inStream); curr = root; while (curr || !nodeStack.empty()) &#123; while(curr) &#123; curr-&gt;left = readAndReturnNode(inStream); nodeStack.push(curr); curr = curr-&gt;left; &#125; if (!nodeStack.empty()) &#123; curr = nodeStack.top(); nodeStack.pop(); curr-&gt;right = readAndReturnNode(inStream); curr = curr-&gt;right; &#125; &#125; return root; &#125;&#125;; 复杂度分析每个节点被访问一次，同时我们用额外空间（队列/栈）来储存中间过程或答案，所以复杂度分析为时间复杂度: O(n)空间复杂度: O(n) 归纳总结这是一道设计题，对二叉树的序列化和反序列还可以有其它灵活的处理方法。有兴趣的朋友可以再多做一些尝试。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Microsoft</tag>
        <tag>Amazon</tag>
        <tag>Bloomberg</tag>
        <tag>Uber</tag>
        <tag>Yahoo</tag>
        <tag>Google</tag>
        <tag>Tree</tag>
        <tag>LinkedIn</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 808] Soup Servings]]></title>
    <url>%2FLeetcode-808-Soup-Servings%2F</url>
    <content type="text"><![CDATA[原题说明There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations: Serve 100 ml of soup A and 0 ml of soup B Serve 75 ml of soup A and 25 ml of soup B Serve 50 ml of soup A and 50 ml of soup B Serve 25 ml of soup A and 75 ml of soup B When we serve some soup, we give it to someone and we no longer have it. Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can. We stop once we no longer have some quantity of both types of soup. Note that we do not have the operation where all 100 ml’s of soup B are used first. Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time. Example:Input: N = 50Output: 0.625Explanation:If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625. Notes: 0 &lt;= N &lt;= 10^9. Answers within 10^-6 of the true value will be accepted as correct. 解题思路虽然题目乍一看比较复杂，好像让你去算概率，难道是概率题，不是编程题？但稍加分析，可以总结如下信息：初始状态下，A和B同时拥有N的汤。终结状态下， 若A先被倒完，则A剩余的汤为0或负数。（因为在剩余汤不足时，可以倒比所需少的量）此时B剩余的汤应当大于0。 若A和B同时倒完，则A和B的汤均为0或负数。 若B先被倒完，则B剩余的汤为0或负数。此时A剩余的汤应当大于0。 有了初始状态和终结状态，可以想到用递归的方法来求解。在结算时，因为同时倒完的概率只需计算一半。因此，判断其为A先倒完时，返回1，而同时倒完时返回0.5。又考虑到所有操作中汤的份量都是25的倍数，实际中间状态的可能最多为Ceil(N/25)^2。因此可以用动态规划来避免冗余计算。 以上基本实现了本题的主体解法。然而这是一个两次方复杂度的解法，随着N的上升，需要指数的时间去计算。此时我们可以利用题目中提到的精度要求来做文章。让我们从概率的角度重新审题。四个操作对汤消耗的期望值为A = 62.5, B = 37.5。A的消耗速度远高于B。因此，当N变大时，A先倒完的概率趋向于1。我们尝试不断递增的N来运行程序后，可以发现当N&gt;4800时，所得概率已经落在1 - 10^-6内。也就是说所有大于4800的输入，都可以直接输出1作为结果。 示例代码 (cpp)123456789101112131415161718192021222324252627class Solution &#123; double recurse(int a, int b, unordered_map&lt;int, unordered_map&lt;int, double&gt;&gt;&amp; memo) &#123; if (a &lt;= 0 &amp;&amp; b &gt; 0) &#123; return 1; &#125; if (a &lt;= 0 &amp;&amp; b &lt;= 0) &#123; return 0.5; &#125; if (b &lt;= 0) &#123; return 0; &#125; if (memo.count(a) &amp;&amp; memo[a].count(b)) &#123; return memo[a][b]; &#125; double prob = (recurse(a - 100, b, memo) + recurse(a - 75, b - 25, memo) + recurse(a - 50, b - 50, memo) + recurse(a - 25, b - 75, memo)) / 4.0; memo[a][b] = prob; return prob; &#125;public: double soupServings(int N) &#123; if (N &gt;= 5000) &#123; return 1; &#125; unordered_map&lt;int, unordered_map&lt;int, double&gt;&gt; memo; return recurse(N, N, memo); &#125;&#125;; 示例代码 (python)1234567891011121314151617181920212223242526272829class Solution(object): def soupHelper(self, A, B, state): if (A, B) in state: return state[A, B] if A &lt;=0 or B &lt;= 0: if A &lt;= 0 and B &lt;= 0: return 0.5 if B &gt; 0: return 1 return 0 prob = 0 prob += self.soupHelper(A - 100, B, state) prob += self.soupHelper(A - 75, B - 25, state) prob += self.soupHelper(A - 50, B - 50, state) prob += self.soupHelper(A - 25, B - 75, state) state[A, B] = 0.25 * prob return state[A, B] def soupServings(self, N): """ :type N: int :rtype: float """ if N &gt; 4800: return 1. state = dict() prob = self.soupHelper(N, N, state) return prob 复杂度分析当N&lt;=4800时： 时间复杂度: O(n^2) 空间复杂度: O(n^2) 当N&gt;4800时： 时间复杂度: O(1) 空间复杂度: O(1) 归纳总结本题主要有两个难点: 想到用递归结合动态规划的办法来求解概率。 利用精度和定性的概率判断，避免计算时间会指数量级的膨胀]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 236] Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2FLeetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[原题说明Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” _______3______ / \ ___5__ ___1__ / \ / \ 6 _2 0 8 / \ 7 4 For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. 解题思路本题要求找出两个节点的最近的共同祖先。 一个简单的思路是我们可以遍历整棵树，然后用一个map记录每个节点的父节点。这样可以找出节点p和q到根节点的path,然后就能方便的找出最近的共同祖先。但是这样要求我们用额外的map来记录每个节点的信息，空间复杂度为O(n)。 换一个思路，我们发现：假设对于一个节点，如果它的右子树里只找到了其中一个目标节点，而在它的左子树中没有找到另一个目标节点；或者它的左子树里只有一个目标节点，而它的右子树里没有另外一个目标界节点，那么当前节点就不是两个目标节点的最近公共祖先了。除此之外的情况，当前节点就是两个目标节点的公共祖先了。 我们可以从叶子节点向上，标记子树中出现目标节点的情况。若一个节点的左右子树都有标记，则当前节点就是共同祖先。 我们用递归的方法实现代码，会非常简洁。 示例代码 (python)12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def lowestCommonAncestor(self, root, p, q): """ :type root: TreeNode :type p: TreeNode :type q: TreeNode :rtype: TreeNode """ if not root or root == p or root == q: return root left = self.lowestCommonAncestor(root.left, p, q) right = self.lowestCommonAncestor(root.right, p, q) if left and right: return root return left if left else right 示例代码 (cpp)123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; TreeNode *left, *right; if (!root || root == p || root == q) &#123; return root; &#125; left = lowestCommonAncestor(root-&gt;left, p, q); right = lowestCommonAncestor(root-&gt;right, p, q); if (left &amp;&amp; right) &#123; return root; &#125; return left ? left : right; &#125;&#125;; 复杂度分析最坏情况每个节点visit一次，因此时间复杂度为O(n）。时间复杂度: O(n)空间复杂度: O(1) 归纳总结思考清楚共同祖先的定义，我们用递归的方法实现代码。同时我们可以看出，这题本质上还是对 Tree 遍历的变种。 好了，这几天就和大家讨论到这里，种香蕉树去了。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 802] Find Eventual Safe States]]></title>
    <url>%2FLeetcode-802-Find-Eventual-Safe-States%2F</url>
    <content type="text"><![CDATA[原题说明In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop. Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps. Which nodes are eventually safe? Return them as an array in sorted order. The directed graph has N nodes with labels 0, 1, ..., N-1, where N is the length of graph. The graph is given in the following form: graph[i] is a list of labels j such that (i, j) is a directed edge of the graph. Example:Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]Output: [2,4,5,6] Note: graph will have length at most 10000. The number of edges in the graph will not exceed 32000. Each graph[i] will be a sorted list of different integers, chosen within the range [0, graph.length - 1]. 解题思路首先需要理解题意, 所谓safe node是指所有经过该node的路径都最后结束于terminal node, 也就是说不会形成环.所以我们可以给每个node三个状态,分别为:0: unvisited1: unsafe2: safe 利用dfs遍历每一个node (返回值为当前路径是否safe): 如果node的状态为unvisited, 那么我们初始化该node转态为unsafe, 并用dfs遍历其所有路径,如果其中有任意一条范围为unsafe, 那么直接break. 如果所有路径返回均为safe,那么设该node状态为safe并返回. 如果node状态为unsafe, 那么有两种情况, 要么是之前dfs遍历时访问过, 确定为unsafe状态; 要么是当前访问路径下之前经过了该点, 说明当前路径形成了环. 不管是哪一种情况, 当前node的unsafe状态都不会改变, 直接返回false. 如果node状态为safe, 那么肯定是之前dfs遍历过, 确定为safe状态, 直接返回即可. 示例代码 (cpp)1234567891011121314151617181920212223242526272829303132class Solution &#123; bool dfs(vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; states, int cur) &#123; if (states[cur] == 1) &#123; return false; &#125; if (states[cur] == 2) &#123; return true; &#125; states[cur] = 1; for (auto&amp; nei : graph[cur]) &#123; if (!dfs(graph, states, nei)) &#123; return false; &#125; &#125; states[cur] = 2; return true; &#125;public: vector&lt;int&gt; eventualSafeNodes(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; vector&lt;int&gt; states(graph.size(), 0); for (int i = 0; i &lt; graph.size(); ++i) &#123; dfs(graph, states, i); &#125; vector&lt;int&gt; rets; for (int i = 0; i &lt; states.size(); ++i) &#123; if (states[i] == 2) &#123; rets.push_back(i); &#125; &#125; return rets; &#125;&#125;; 示例代码 (python)1234567891011121314151617181920212223class Solution(object): def dfs(self, graph, state, curr_idx): if state[curr_idx]: return state[curr_idx] state[curr_idx] = 1 for next_node_idx in graph[curr_idx]: next_state = self.dfs(graph, state, next_node_idx) if next_state == 1: return state[curr_idx] state[curr_idx] = 2 return state[curr_idx] def eventualSafeNodes(self, graph): """ :type graph: List[List[int]] :rtype: List[int] """ ret = [] state = [0 for i in range(len(graph))] for idx in range(len(graph)): if self.dfs(graph, state, idx) == 2: ret.append(idx) return ret 复杂度分析时间复杂度: O(n) 因为每个node经过一次空间复杂度: O(n) 记录states 归纳总结这是一道经典的DFS题目, 需要注意的是, 每个node有三个状态, 并且我们经过node时将其设为unsafe状态, 这样遍历过程中再次遇到该点, 我们就可以直接确定为unsafe了.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Depth-first Search</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 117] Populating Next Right Pointers in Each Node II]]></title>
    <url>%2FLeetcode-117-Populating-Next-Right-Pointers-in-Each-Node-II%2F</url>
    <content type="text"><![CDATA[原题说明Follow up for problem “Populating Next Right Pointers in Each Node”. What if the given tree could be any binary tree? Would your previous solution still work? Note: You may only use constant extra space. For example, Given the following binary tree, 1 / \ 2 3 / \ \ 4 5 7 After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \ 4-&gt; 5 -&gt; 7 -&gt; NULL 解题思路这题是[LeetCode 116] Populating Next Right Pointers in Each Node的进阶题。从完美二叉树变成任意的二叉树。仍然要求空间复杂度为O(n)。 总体的思路不变，需要记录每层的信息，保存前一个节点，遍历到下一个节点之后，让前一个结点的next链接到当前节点。由于不能保证上一层的父节点都有子节点，因此我们需要对上一层父节点是否存在子节点做出额外的判断，然后遍历当前层的非空节点。这点与之前完美二叉树是不同的。 在示例代码中，prev可以看做一个存放当前遍历节点的前一个节点。而leftMost则指向当前层的第一个节点，遍历完整层后，利用leftMost更新下一层。如果对代码的逻辑理解不够清晰，建议用题目给出的二叉树做简单的验算，能有直观认识。 示例代码 (python)123456789101112131415161718192021222324252627282930# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): node = root while node: prev, leftMost = None, None while node: if node.left: if prev: prev.next = node.left prev = node.left if not leftMost: leftMost = node.left if node.right: if prev: prev.next = node.right prev = node.right if not leftMost: leftMost = node.right node = node.next node = leftMost 示例代码 (cpp)123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; TreeLinkNode *node = root; while (node) &#123; TreeLinkNode *prev = NULL, *leftMost = NULL; while (node) &#123; if (node-&gt;left) &#123; if (prev) &#123; prev-&gt;next = node-&gt;left; &#125; prev = node-&gt;left; if (!leftMost) &#123; leftMost = node-&gt;left; &#125; &#125; if (node-&gt;right) &#123; if (prev) &#123; prev-&gt;next = node-&gt;right; &#125; prev = node-&gt;right; if (!leftMost) &#123; leftMost = node-&gt;right; &#125; &#125; node = node-&gt;next; &#125; node = leftMost; &#125; &#125;&#125;; 复杂度分析广度搜索BFS遍历二叉树，每个节点被遍历一次，时间复杂度为O(n）。同时我们使用了cur，pre两个变量，空间复杂度为O(1)。因此复杂度分析为： 时间复杂度： O(n) 空间复杂度： O(1） 总结归纳：这题是对[LeetCode 116] Populating Next Right Pointers in Each Node的进阶，要求更高。但总体解题的逻辑不变。因此此题的解法也完全适用于Leetcode 166。 种香蕉树去了^_^]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 116] Populating Next Right Pointers in Each Node]]></title>
    <url>%2FLeetcode-116-Populating-Next-Right-Pointers-in-Each-Node%2F</url>
    <content type="text"><![CDATA[原题说明Given a binary tree struct TreeLinkNode { TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space. You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). For example, Given the following perfect binary tree, 1 / \ 2 3 / \ / \ 4 5 6 7 After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \ 4-&gt;5-&gt;6-&gt;7 -&gt; NULL 解题思路本题要去给一个完美二叉树加上next节点，如果没有类似节点则标记为NULL。结合给出的例子，还是题意还是比较清晰的。 最简单的思路，可以结合我们之前层序遍历二叉树的一题 [LeetCode 102] Binary Tree Level Order Traversal 二叉树层序遍历，把每一层的节点按顺序加上next节点即可。然而，这样的空间复杂度会是O(n),并不符合要求。 为了优化空间复杂度，我们需要记录每层的信息，保存前一个节点，遍历到下一个节点之后，让前一个结点的next到当前节点（如果前面没有节点或者当前节点是最后一个，就另行处理） 具体而言，我们用cur记录当前层第一个节点。在每个层间，用pre记录当前节点的前一个节点。如果pre非空，那么把pre.next连接到当前节点root.left,再更新pre。当一层遍历完，就更新到下一层。 具体参看代码实例。结合题中给的树的例子和给出的示例代码，能更清晰的理解其中逻辑。 示例代码 (python)1234567891011121314151617181920212223# Definition for binary tree with next pointer.# class TreeLinkNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None# self.next = Noneclass Solution: # @param root, a tree link node # @return nothing def connect(self, root): if not root: return while root.left: cur = root.left prev = None while root: if prev: prev.next = root.left root.left.next = root.right prev = root.right root = root.next root = cur 示例代码 (cpp)1234567891011121314151617181920212223242526272829/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; TreeLinkNode *leftMost = NULL, *prev = NULL; while(root) &#123; leftMost = root; while(root) &#123; if (root-&gt;left) &#123; if (prev) &#123; prev-&gt;next = root-&gt;left; &#125; root-&gt;left-&gt;next = root-&gt;right; prev = root-&gt;right; &#125; root = root-&gt;next; &#125; prev = NULL; root = leftMost-&gt;left; &#125; &#125;&#125;; 复杂度分析广度搜索BFS遍历二叉树，每个节点被遍历一次，时间复杂度为O(n）。同时我们使用了cur，pre两个变量，空间复杂度为O(1)。因此复杂度分析为： 时间复杂度： O(n) 空间复杂度：O(1） 总结归纳：这题题意清晰。为了优化空间复杂度，需要我们对层序遍历做更细致的操作。 以后我们会再介绍本题的进阶版，对非完美二叉树改如何实现同样的操作。基本思路与这题相同，只是需要做更进一步的判断实现next的链接。有兴趣的朋友可以参看 [LeetCode 117] Populating Next Right Pointers in Each Node II 种香蕉树去了^_^]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 105] Construct Binary Tree from Preorder and Inorder Traversal]]></title>
    <url>%2FLeetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal%2F</url>
    <content type="text"><![CDATA[原题说明Given preorder and inorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree: 3 / \ 9 20 / \ 15 7 解题思路题目给出二叉树的前序遍历与中序遍历，要求重新构建原二叉树，返回根节点。 首先我们需要明确： 前序遍历的顺序：中、左、右 中序遍历的顺序：左、中、右 因此，我们知道前序遍历序列的第一个元素是原二叉树的根节点，而此根节点将中序遍历分为了左子树的中序遍历与右子树的中序遍历。 根据以上思路，我们可以继续对左右子树的分别进行递归，直到序列为空，重构整个二叉树。 示例代码 (python)1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: # @param inorder, a list of integers # @param postorder, a list of integers # @return a tree node # 12:00 def buildTree(self, preorder, inorder): """ :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode """ dicinorder = &#123;&#125; #用dictionary记录inoder中value和对应index的关系 for i, val in enumerate(inorder): dicinorder[val] = i start, end = 0, len(inorder) return self.helper(start, end, preorder, dicinorder) def helper(self, start, end, preorder, dicinorder): if start == end: return None root = TreeNode(preorder.pop(0)) inorderIndex = dicinorder[root.val] root.left = self.helper(start, inorderIndex, preorder, dicinorder) root.right = self.helper(inorderIndex+1, end, preorder, dicinorder) return root 复杂度分析我们使用一个字典记录inorder数组中value与对应index的关系，这样能快速查找每个value的index，每次查找时间复杂度为O(1)。每个节点重构会被访问一次，一共n个节点。同时字典需要空间O(n)。所以复杂度分析为 时间复杂度: O(n) 空间复杂度: O(n) 归纳总结此题要求重构二叉树，因此需要理解清楚中序遍历与后序遍历的定义。合理使用递归方法即可完成解题。 大家可以结合利用中序遍历与后序遍历构建二叉树这题，更好的理解问题： [LeetCode 106] Construct Binary Tree from Inorder and Postorder Traversal 大家可以在 Tree Tag 中找到更多和树有关的内容。种香蕉树去了^_^]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 106] Construct Binary Tree from Inorder and Postorder Traversal]]></title>
    <url>%2FLeetcode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[原题说明Given inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree: 3 / \ 9 20 / \ 15 7 解题思路题目给出二叉树的中序遍历与后序遍历，要求重新构建原二叉树，返回根节点。 首先我们需要明确： 中序遍历的顺序：左、中、右 后序遍历的顺序：左、右、中 因此，我们知道后序遍历的最后一个元素是原二叉树的根节点，而此根节点将中序遍历分为了左子树的中序遍历与右子树的中序遍历。 根据以上思路，我们可以继续对左右子树的分别进行递归，直到序列为空，重构整个二叉树。 示例代码 (python)123456789101112131415161718192021222324252627# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def buildTree(self, inorder, postorder): """ :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode """ dicinorder = &#123;&#125; for i, val in enumerate(inorder): dicinorder[val] = i start, end = 0, len(inorder) return self.helper(start, end, postorder, dicinorder) def helper(self, start, end, postorder, dicinorder): if start == end: return None root = TreeNode(postorder.pop()) inorderIndex = dicinorder[root.val] root.right = self.helper(inorderIndex+1, end, postorder, dicinorder) root.left = self.helper(start, inorderIndex, postorder, dicinorder) return root 复杂度分析我们使用一个字典记录inorder数组中value与对应index的关系，这样能快速查找每个value的index，每次查找时间复杂度为O(1)。每个节点重构会被访问一次，一共n个节点。同时字典需要空间O(n)。所以复杂度分析为 时间复杂度: O(n) 空间复杂度: O(n) 归纳总结此题要求重构二叉树，因此需要理解清楚中序遍历与后序遍历的定义。合理使用递归方法即可完成解题。 大家可以结合利用中序遍历与前序遍历构建二叉树这题，更好的理解问题： [LeetCode 105] Construct Binary Tree from Preorder and Inorder Traversal 大家可以在 Tree Tag 中找到更多和树有关的内容。种香蕉树去了^_^]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 250] Count Univalue Subtrees]]></title>
    <url>%2FLeetcode-250-Count-Univalue-Subtrees%2F</url>
    <content type="text"><![CDATA[原题说明Given a binary tree, count the number of uni-value subtrees. A Uni-value subtree means all nodes of the subtree have the same value. For example:Given binary tree, 5 / \ 1 5 / \ \ 5 5 5 return 4. 解题思路这题要求求出所有二叉树子树中，元素都相同的子树的个数。给出的例子中，以5为值得子树个数是4个，以1为值得子树个数是0，所以答案是4。 如果一个子树是满足条件的元素相同的子树，那以它的子节点为根的子树也一定是满足条件的元素相同的子树。因此，我们可以从叶子节点从下往上（bottom-up）判断。 如果两个以叶子节点为根的子树都是元素相同的子树，并且它们的值与父节点的值相同，则以父节点为根的子树也是满足条件的子树。但是节点没有父节点，无法往上判断，所以可以采用递归的方法从上往下调用判断。 在代码的实现过程中，这里我们用计数器self.count记录满足条件的子树个数，用一个辅助函数checkUni帮助我们从下往上查找UnivalSubTree 示例代码 （python）123456789101112131415161718192021222324# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def countUnivalSubtrees(self, root): self.count = 0 self.checkUni(root) return self.count# If both children are "True" and root.val is equal to both children's values that exist, # then root node is uniValue subtree node. def checkUni(self, root): if not root: return True l, r = self.checkUni(root.left), self.checkUni(root.right) if l and r and (not root.left or root.left.val == root.val) and \ (not root.right or root.right.val == root.val): self.count += 1 return True return False 复杂度分析使用深度搜索DFS,每个节点被访问一次。并且递归过程中，递归栈的最大深度为O(n)。所以复杂度分析为: 时间复杂度 O(n) 空间复杂度：O(1), &#160; 递归栈深度O(n) 归纳总结：递归方法解决树的问题。关键在于想明白父节点与子节点之间的关系。这里一个小点值得提醒，我们把空的节点判断为True, 这样方便于之后的计算。 大家可以在 Tree Tag 中找到更多和树有关的内容，在 Depth-first Search Tag 中找到更多和深度搜索相关的问题。 要种香蕉树去了：）]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 112] Path Sum]]></title>
    <url>%2FLeetcode-112-Path-Sum%2F</url>
    <content type="text"><![CDATA[原题说明Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum. For example:Given the below binary tree and sum = 22, 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22. 解题思路本题给出一个数sum，要求判断二叉树中是否存在一条从根到叶root-to-leaf的路径，使得路径上数值的和等于sum。 事实上，如果存在这样一条路径，那么对于根节点的两个可能的子节点left和right, 两个中至少存在一条路径，使得从子节点left或者right到叶的路径的数值的和等于sum - root.val。以此类推，子节点的子节点亦是如此。 因此，我们自然想到利用递归，深度搜索的方法来解决此题。当搜索到叶节点时，如果叶节点的值val等于当时的sum,则找到了这样一条路径。 示例代码 （python）12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def hasPathSum(self, root, sum): """ :type root: TreeNode :type sum: int :rtype: bool """ if not root: return False if not root.left and not root.right: #当搜索到叶节点时 return root.val == sum return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val) 复杂度分析使用深度搜索DFS,每个节点被访问一次。并且递归过程中，栈的最大深度为O(n)。考虑到本题并非平衡二叉树，最差将退化成链表，而大O代表复杂度的上阈值，因此为O(n)。 所以复杂度分析为： 时间复杂度： O(n) 空间复杂度：O(1), &#160; 递归栈深度O(n) 总结归纳：这是一道典型的用递归方法解决的树的问题，采用深度搜索DFS的方法也是比较基础。 大家可以在 Tree Tag 中找到更多和树有关的内容，也可以在 Depth-first Search tag 中查找与深度搜索有关的题目。 不说了，忙着种香蕉树去了：）]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 809] Expressive Words]]></title>
    <url>%2FLeetcode-809-Expressive-Words%2F</url>
    <content type="text"><![CDATA[原题说明Sometimes people repeat letters to represent extra feeling, such as &quot;hello&quot; -&gt; &quot;heeellooo&quot;, &quot;hi&quot; -&gt; &quot;hiiii&quot;. Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different. A group is extended if that group is length 3 or more, so “e” and “o” would be extended in the first example, and “i” would be extended in the second example. As another example, the groups of “abbcccaaaa” would be “a”, “bb”, “ccc”, and “aaaa”; and “ccc” and “aaaa” are the extended groups of that string. For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups. Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, and add some number of the same character c to it so that the length of the group is 3 or more. Note that we cannot extend a group of size one like “h” to a group of size two like “hh” - all extensions must leave the group extended - ie., at least 3 characters long. Given a list of query words, return the number of words that are stretchy. Example:Input:S = “heeellooo”words = [“hello”, “hi”, “helo”]Output: 1Explanation:We can extend “e” and “o” in the word “hello” to get “heeellooo”.We can’t extend “helo” to get “heeellooo” because the group “ll” is not extended. Notes: 0 &lt;= len(S) &lt;= 100. 0 &lt;= len(words) &lt;= 100. 0 &lt;= len(words[i]) &lt;= 100. S and all words in words consist only of lowercase letters 解题思路这道题主要需要建立isMatch()方法判断original word (o)是否能够表述成stretchy word (s)指针i和j分别指向s和o,需要判断如下条件: 如果当前的s[i] != o[j], 直接返回false 统计当前连续相同的字符分别用cntO和cntS表示 如果cntO == cntS,说明是严格匹配,当然可以继续 如果cntO &lt; cntS &amp;&amp; cntS &gt;= 3, 说明Sextend了当前的字符,也可以继续匹配 需要注意的是,&quot;baac&quot;(original word)和&quot;baaac&quot;(strechy word)是可以匹配的, 但是&quot;baaaac&quot;(original word)和&quot;baaac&quot;(stretchy word)就不可以了, 也就是说原字符串中相同连续字符(例子中的字符&#39;a&#39;)长度一定要小于Stretchy word中对应的相同连续字符(&#39;a&#39;)长度才可能匹配, 这一点原题没有说的特别清楚, 面试的时候需要和面试官clarify清楚. 示例代码 (cpp)12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; // s means strechy word, o means original word bool isMatch(const string&amp; s, const string&amp; o) &#123; int i = 0, j = 0; while (i &lt; s.size() &amp;&amp; j &lt; o.size()) &#123; if (s[i++] != o[j++]) &#123; return false; &#125; // cntO means number of consecutive chars in O starting from i - 1 // cntS means number of consecutive chars in S stargin from j - 1 int cntO = 1, cntS = 1; while (i &lt; s.size() &amp;&amp; s[i] == s[i - 1]) &#123; ++i; ++cntS; &#125; while (j &lt; o.size() &amp;&amp; o[j] == o[j - 1]) &#123; ++j; ++cntO; &#125; if (cntS == cntO || (cntS &gt;= 3 &amp;&amp; cntS &gt; cntO)) &#123; continue; &#125; return false; &#125; return (i == s.size() &amp;&amp; j == o.size()); &#125;public: int expressiveWords(string S, vector&lt;string&gt;&amp; words) &#123; int ret = 0; for (auto&amp; word : words) &#123; if (isMatch(S, word)) &#123; ++ret; &#125; &#125; return ret; &#125;&#125;; 示例代码 (python)123456789101112131415161718192021222324252627282930313233343536373839class Solution(object): def get_char_len_next_nondup_idx(self, word, curr_idx): """ Get current character, continous length of this charactor and next character index """ length = 1 for idx in range(curr_idx + 1, len(word)): if word[idx] != word[curr_idx]: return word[curr_idx], length, idx length += 1 return word[curr_idx], length, len(word) def check(self, S, word): sid = 0 wid = 0 while(sid &lt; len(S) and wid &lt; len(word)): curr_s_char, curr_s_len, sid = self.get_char_len_next_nondup_idx(S, sid) curr_w_char, curr_w_len, wid = self.get_char_len_next_nondup_idx(word, wid) if curr_s_char != curr_w_char: return 0 if curr_s_len &lt; curr_w_len: return 0 if curr_s_len == 2 and curr_w_len == 1: return 0 if sid == len(S) and wid == len(word): return 1 return 0 def expressiveWords(self, S, words): """ :type S: str :type words: List[str] :rtype: int """ ret = 0 for word in words: ret += self.check(S, word) return ret 复杂度分析时间复杂度: O(len * (m + n)) 其中len为words.size(), m为S.size(), n为word中字符串的平均长度空间复杂度: O(1) 归纳总结这是一道经典的字符串题目,题目本身并不算很难,重要的是要理解清楚题意.]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 101] Symmetric Tree]]></title>
    <url>%2FLeetcode-101-Symmetric-Tree%2F</url>
    <content type="text"><![CDATA[原题说明Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center). For example, this binary tree [1,2,2,3,4,4,3] is symmetric: 1 / \ 2 2 / \ / \ 3 4 4 3 But the following 1 / \ 2 2 \ \ 3 3 Note:Bonus points if you could solve it both recursively and iteratively. 解题思路本题要求判断二叉树是否对称。简单来说，对一颗二叉树做镜像翻转，如果翻转后的二叉树与原树相同，即可判断为对称，反之则不对称。 我们可以用递归与非递归两种解法来完成这题，但总体思路上就是之前所说的。 在递归方法总是相对简单，我们使用深度搜索DFS来实现。用一个辅助函数helpcheck来完成对两棵树的同时遍历。这里我们只要对原本该遍历left的地方换成right,right的地方换成left,就完成了对镜像树的遍历。 在非递归方法中，我们使用广度搜索BFS来实现。使用双端队列来实现。每次从队列头部pop出两棵树的对应节点做判断，节点值不同，则返回False；如果满足条件，在把它们对应的左右子节点存入队尾。直到队列为空时，返回True 示例代码 （递归 python）12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ return self.helpcheck(root, root) def helpcheck(self, left, right): if not left and not right: return True if not left or not right: return False if left.val != right.val: return False return self.helpcheck(left.left, right.right) and self.helpcheck(left.right, right.left) 示例代码 （递归 cpp）123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool checkHelper(TreeNode* left, TreeNode* right) &#123; if (!left &amp;&amp; !right) &#123; return true; &#125; if (!left || !right) &#123; return false; &#125; if (left-&gt;val != right-&gt;val) &#123; return false; &#125; return checkHelper(left-&gt;left, right-&gt;right) &amp;&amp; checkHelper(left-&gt;right, right-&gt;left); &#125; bool isSymmetric(TreeNode* root) &#123; return checkHelper(root, root); &#125;&#125;; 示例代码 （非递归 python）1234567891011121314151617181920212223242526272829303132# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneimport collectionsclass Solution: def isSymmetric(self, root): """ :type root: TreeNode :rtype: bool """ if not root: return True q = collections.deque() q.extend([root,root]) while q: tmpNode1 = q.popleft() tmpNode2 = q.popleft() if tmpNode1.val != tmpNode2.val: return False if tmpNode1.left and tmpNode2.right: q.extend([tmpNode1.left, tmpNode2.right]) elif (tmpNode1.left and not tmpNode2.right) or (not tmpNode1.left and tmpNode2.right): return False if tmpNode1.right and tmpNode2.left: q.extend([tmpNode1.right, tmpNode2.left]) elif (tmpNode1.right and not tmpNode2.left) or (not tmpNode1.right and tmpNode2.left): return False return True 示例代码 （非递归 cpp）123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; TreeNode* left = root; TreeNode* right = root; stack&lt;TreeNode*&gt; nodeStackL; stack&lt;TreeNode*&gt; nodeStackR; while(left || !nodeStackL.empty()) &#123; while(left) &#123; if (!right) return false; if (left-&gt;val != right-&gt;val) return false; nodeStackL.push(left); nodeStackR.push(right); left = left-&gt;left; right = right-&gt;right; &#125; if (right) return false; if(!nodeStackL.empty()) &#123; left = nodeStackL.top(); right = nodeStackR.top(); nodeStackL.pop(); nodeStackR.pop(); left = left-&gt;right; right = right-&gt;left; &#125; &#125; if (right) return false; return true; &#125;&#125;; 复杂度分析对递归深度搜索，每个节点被访问一次，因此时间复杂度为O(n)。考虑到本题并非平衡二叉树，最差将退化成链表，递归栈最大深度为O(n)。因此其复杂度为： 时间复杂度： O(n) 空间复杂度：O(1), &#160; 递归栈深度O(n) 对非递归广度搜索，每个节点被访问一次，时间复杂度为O(n)。队的最大长度为其中最宽的层的节点数，因此空间复杂度仍然为O(n). 时间复杂度： O(n) 空间复杂度： O(n) 总结归纳：本题想清楚树的对称的定义，便能利用深度搜索DFS和广度搜索BFS两种树的遍历的方法解题。类似的题目在实现的过程中一般都是利用这两种遍历方法，所以需要大家对树的遍历能够比较熟悉，以便加以利用。 之后我们还会添加一些相关的练习。同时大家可以在Tree Tag 中找到更多和树有关的内容。种香蕉树去了：） [LeetCode 144] Binary Tree Preorder Traversal 二叉树前序遍历 [LeetCode 94] Binary Tree Inorder Traversal 二叉树中序遍历 [LeetCode 145] Binary Tree Postorder Traversal 二叉树后序遍历]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Bloomberg</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 104] Maximum Depth of Binary Tree]]></title>
    <url>%2FLeetcode-104-Maximum-Depth-of-Binary-Tree%2F</url>
    <content type="text"><![CDATA[原题说明Given a binary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its depth = 3 解题思路这题要求我们给出二叉树的最大深度。最大深度是指的从根节点一直到最远的叶节点中所有的节点数目。 因为二叉树有左右两棵，所以二叉树的最大深度为其根节点左右两棵子树中，最深的那棵子树的深度加一. depth(root) = max(depth(root.left), depth(root.right)) + 1 显然我们可以用深度搜索（DFS）来实现这一算法，非常简单。 示例代码 （python）1234567891011121314151617# Definition for a binary tree node.# class TreeNode(object):# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution(object): def maxDepth(self, root): """ :type root: TreeNode :rtype: int """ if not root: return 0 ans = max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1 return ans 示例代码 （c++）123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int depthHelper(TreeNode* curr, int depth) &#123; int left,right; if(!curr) &#123; return depth; &#125; left = depthHelper(curr-&gt;left, depth + 1); right = depthHelper(curr-&gt;right, depth + 1); return left &gt; right ? left : right; &#125; int maxDepth(TreeNode* root) &#123; return depthHelper(root, 0); &#125;&#125;; 复杂度分析使用深度搜索DFS,每个节点被访问一次。并且递归过程中，栈的最大深度为O(n)。考虑到本题并非平衡二叉树，最差将退化成链表，而大O代表复杂度的上阈值，因此为O(n)。所以复杂度分析为： 时间复杂度：O(n) 空间复杂度：O(1), &#160; 递归栈深度O(n) 总结归纳：这题比较简单，想清楚树的深度的定义，找出递归的关系，就可以利用递归的方法解题。当然也可以使用非递归的方便遍历树来解决这一问题，有兴趣的朋友可以自己试试。 更多Tree相关的内容将更新在 Tree Tag，尽请期待，种香蕉树去了：）]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Uber</tag>
        <tag>Apple</tag>
        <tag>Yahoo</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 102] Binary Tree Level Order Traversal]]></title>
    <url>%2FLeetcode-102-Binary-Tree-Level-Order-Traversal%2F</url>
    <content type="text"><![CDATA[原题说明Given a binary tree, return the level order of its nodes’ values. (ie, from left to right, level by level). For example: Given binary tree [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 return its level order traversal as: [ [3], [9,20], [15,7] ] 解题思路本题要求层序遍历一个二叉树，与普通的广度遍历（Breadth First Search）稍有不同的是，需要按层分开。所以我们需要判断当前层的遍历是否结束。我们使用队queue来实现遍历，具体思路为： 建立一个队q,并将当前节点cur存入队中： 当前层的长度由变量count记录 如果队q非空： 2.1 建立一个空列tmplevel存放下一层的节点 2.2 如果count非零： 当前节点cur更新为退队节点 将当前节点cur的值存入列tmplevel中 count减1 如果当前节点cur的左子节点非空，存入队q 如果当前节点cur的右子节点非空，存入队q 回到步骤2.2 2.3 将列tmplevel存入答案列ans 2.4 更新count为当前队列q长度 返回ans 算法过程中，我们用变量count追踪当前层剩余的未访问节点的个数，从而判断何时按层分开。思路还是比较简单的。 示例代码 （python版）12345678910111213141516171819202122232425262728293031class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def levelOrder(self, root): """ :type root: TreeNode :rtype: List[List[int]] """ if not root: return [] ans = [] cur = root q = collections.deque([cur]) count = len(q) while q: tmplevel = [] while count: cur = q.popleft() tmplevel.append(cur.val) count -= 1 if cur.left: q.append(cur.left) if cur.right: q.append(cur.right) ans.append(tmplevel) count = len(q) return ans 复杂度分析每个节点被访问一次，因此时间复杂度为O(n)。另一方面，队的最大长度为其中最宽的层的节点数，因此空间复杂度仍然为O(n). 时间复杂度： O(n) 空间复杂度： O(n) 总结归纳：层序遍历level order也是树遍历的一种方法，结合我们之前讨论过的前序preorder、中序inorder、后序postorder遍历，希望大家能体会它们实现过程中的区别。 层序遍历使用队列queue这一数据结构实现，这点和前序preorder、中序inorder、后序postorder遍历是不同的。同时，层序遍历的空间复杂度大于另外三种深度遍历的复杂度，这点也值得我们注意。 相关的练习还有： [LeetCode 144] Binary Tree Preorder Traversal 二叉树前序遍历 [LeetCode 94] Binary Tree Inorder Traversal 二叉树中序遍历 [LeetCode 145] Binary Tree Postorder Traversal 二叉树后序遍历 好了，今天就和大家讨论到这里，种香蕉树去了]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 145] Binary Tree Postorder Traversal]]></title>
    <url>%2Fleetcode-145-Binary-Tree-Postorder-Traversal%2F</url>
    <content type="text"><![CDATA[原题说明Given a binary tree, return the postorder traversal of its nodes’ values. For example: Given binary tree [1,null,2,3], 1 \ 2 / 3 return [3,2,1]. Note: Recursive solution is trivial, could you do it iteratively? 解题思路深度遍历二叉树（DFS），可以分为 前序遍历（preorder） 中序遍历（inorder） 后序遍历（postorder） 这题要求使用后序遍历。后序遍历按照左子节点（left），右子节点（right），根节点（root）的顺序深度遍历二叉树。 同样，我们可以使用递归与非递归两种方法来实现前序遍历。递归的方法还是比较简单，参看相关代码就能明白。后序遍历的非递归的方法相比前序遍历与中序遍历而言，相对比较复杂，每个根节点我们都要visit两次，逻辑上需要大家仔细思考。 我们依然可以通过栈（stack）实现，总体思想为方位左子节点，直到其为空，同时将访问过得节点和其右子节点存入栈中。当退回是需要判断节点的右子节点是否为空， 从而可以确定是否访问该节点还是访问该节点的右子节点： 使用栈（stack），每次visit当前节点node，同时如果当前节点的右子节点非空，将此右子节点存入栈中。然后将当前节点node压入栈中，并将当前节点更新为其左子节点，知道当前节点node为空。 之后当栈非空，如果栈顶元素的右子节点不等于该元素退栈后的栈顶元素，则将栈顶元素存入答案数组，退栈，并将当前节点node设为空。反之，交换栈顶的两个节点，并将当前节点设为栈顶元素，并退栈。 重复上述两个步骤，直到遍历完整棵二叉树。具体流程为： 建立一个空栈stack 如果当前节点node非空或者栈stack非空： 2.1 如果当前节点node非空： 如果当前节点的右子节点非空：将右子节点存入栈中 将当前节点node压入栈 更新当前节点node为它的左子节点，回到步骤2.1 2.2 如果栈非空: 将当前节点node设为栈顶元素并退栈 如果栈非空并且栈顶元素等于当前节点的右子节点：交换当前节点和栈顶元素。 反之访问并将当前节点node存入答案数组ans, 并将当前节点设为空 回到步骤2 示例代码 （递归 python版）12345678910111213141516171819202122class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ def postorderhelper(root, ans): if root: postorderhelper(root.left, ans) else: return postorderhelper(root.right, ans) ans.append(root.val) ans = [] postorderhelper(root, ans) return ans 示例代码 （递归 c++版）123456789101112131415161718192021222324struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: void postorderHelper(TreeNode* curr, vector&lt;int&gt;&amp; ret) &#123; if (!curr) &#123; return; &#125; postorderHelper(curr-&gt;left, ret); postorderHelper(curr-&gt;right, ret); ret.push_back(curr-&gt;val); return; &#125; vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; postorderHelper(root, ret); return ret; &#125;&#125;; 示例代码 （非递归 python版）12345678910111213141516171819202122232425262728293031class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def postorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ cur = root stack = collections.deque() ans = [] while(cur or stack): while cur: if cur.right: stack.append(cur.right) stack.append(cur) cur = cur.left if stack: cur = stack.pop() if stack and cur.right == stack[-1]: tmp = stack.pop() stack.append(cur) cur = tmp else: ans.append(cur.val) cur = None return ans 示例代码 （非递归 c++版）1234567891011121314151617181920212223242526272829303132333435363738394041424344struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; nodeStack; stack&lt;bool&gt; stackLR; // False for Only Visited Left, True for Visited Left and Right bool lr = false; TreeNode* curr = root; while(curr || !stackLR.empty())&#123; if(curr) &#123; while(curr-&gt;left) &#123; nodeStack.push(curr); stackLR.push(false); curr = curr-&gt;left; &#125; nodeStack.push(curr); stackLR.push(true); curr = curr-&gt;right; continue; &#125; curr = nodeStack.top(); nodeStack.pop(); lr = stackLR.top(); stackLR.pop(); if (lr) &#123; ret.push_back(curr-&gt;val); curr = NULL; &#125; else &#123; nodeStack.push(curr); stackLR.push(true); curr = curr-&gt;right; &#125; &#125; return ret; &#125;&#125;; 复杂度分析对递归方法，每个节点都被访问一次，考虑到本题并非平衡二叉树，最差将退化成链表，递归栈最大深度为O(n)。所以复杂度分析为： 时间复杂度： O(n) 空间复杂度：O(1), &#160; 递归栈深度O(n) 对非递归方法，同样每个节点都被访问一次，考虑到本题并非平衡二叉树，最差将退化成链表，栈最大深度为O(n)。所以复杂度分析为： 时间复杂度： O(n) 空间复杂度：O(n) 总结归纳：今天我们讲了二叉树的后序遍历，结合之前我们介绍的前序遍历、中序遍历，希望能对感兴趣的朋友有所帮助。 后序遍历的非递归实现相对前序遍历、中序遍历而言复杂一点，但只要逻辑上清晰，严格按照后序遍历的定义去做，也不难实现。 相关的练习还有： [LeetCode 144] Binary Tree Preorder Traversal 二叉树前序遍历 [LeetCode 94] Binary Tree Inorder Traversal 二叉树中序遍历 [LeetCode 102] Binary Tree Level Order Traversal 二叉树层序遍历 之后我们会继续讨论更多Tree相关的内容,并更新在 Tree Tag，尽请期待，种香蕉树去了：）]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 94] Binary Tree Inorder Traversal]]></title>
    <url>%2FLeetcode-94-Binary-Tree-Inorder-Traversal%2F</url>
    <content type="text"><![CDATA[原题说明Given a binary tree, return the inorder traversal of its nodes’ values. For example: Given binary tree [1,null,2,3], 1 \ 2 / 3 return [1,3,2]. Note: Recursive solution is trivial, could you do it iteratively? 解题思路深度遍历二叉树（DFS），可以分为 前序遍历（preorder） 中序遍历（inorder） 后序遍历（postorder） 这题要求使用中序遍历。中序遍历按照左子节点（left），根节点（root），右子节点（right）的顺序深度遍历二叉树。 同样，我们可以使用递归与非递归两种方法来实现前序遍历。递归的方法比较简单，参看相关代码就能明白。非递归的方法可以通过栈（stack）实现： 使用栈（stack），每次visit当前节点node，同时如果当前节点的右子节点非空，将此右子节点存入栈中，再将当前节点node更新为当前节点的左子节点。直到遍历完整棵二叉树。具体步骤为： 建立一个空栈stack 如果当前节点node非空或者栈stack非空： 2.1 如果当前节点node非空： 将当前节点node压入栈 更新当前节点node为它的左子节点，回到步骤2.1 2.2 如果栈非空，: 将当前节点更新为栈顶元素，并且退栈 访问当前节点 更新当前节点node为它的右子节点，回到步骤2 示例代码 （递归 python版）123456789101112131415161718192021class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def inorderhelper(self, root, ans): if root is None: return self.inorderhelper(root.left, ans) ans.append(root.val) self.inorderhelper(root.right, ans) def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ res = [] self.inorderhelper(root, res) return res 示例代码 （递归 cpp版）123456789101112131415161718192021222324 struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; &#125;; class Solution &#123;public: void inorderHelper(TreeNode* curr, vector&lt;int&gt; &amp;ret) &#123; if (!curr) &#123; return; &#125; inorderHelper(curr-&gt;left, ret); ret.push_back(curr-&gt;val); inorderHelper(curr-&gt;right, ret); return; &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; inorderHelper(root, ret); return ret; &#125;&#125;; 示例代码 （非递归 python版）1234567891011121314151617181920212223class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def inorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ stack = collections.deque() cur, ans = root, [] while(cur or stack): while cur: stack.append(cur) cur = cur.left if stack: cur = stack.pop() ans.append(cur.val) cur = cur.right return ans 示例代码 （非递归 cpp版）1234567891011121314151617181920212223242526 struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; &#125;; class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; TreeNode* curr = root; stack&lt;TreeNode*&gt; nodeStack; while(curr || !nodeStack.empty())&#123; while(curr) &#123; nodeStack.push(curr); curr = curr-&gt;left; &#125; curr = nodeStack.top(); nodeStack.pop(); ret.push_back(curr-&gt;val); curr = curr-&gt;right; &#125; return ret; &#125;&#125;; 复杂度分析对递归方法，每个节点都被访问一次，考虑到本题并非平衡二叉树，最差将退化成链表，递归栈最大深度为O(n)。所以复杂度分析为： 时间复杂度： O(n) 空间复杂度：O(1), &#160; 递归栈深度O(n) 对非递归方法，同样每个节点都被访问一次，考虑到本题并非平衡二叉树，最差将退化成链表，栈最大深度为O(n)。所以复杂度分析为： 时间复杂度： O(n) 空间复杂度：O(n) 总结归纳：今天我们讲了二叉树的中序遍历，结合之前我们介绍的前序遍历，希望能对感兴趣的朋友有所帮助。 这里再介绍一个小知识点，当二叉树(Binary Tree)为二叉搜索树（Binary Search Tree）时，中序遍历会按照节点值从小到大排列。因此这也提供给我们一个判断二叉树(Binary Tree)是否是二叉搜索树（Binary Search Tree）的方法。 相关的练习还有： [LeetCode 144] Binary Tree Preorder Traversal 二叉树前序遍历 [LeetCode 145] Binary Tree Postorder Traversal 二叉树后序遍历 [LeetCode 102] Binary Tree Level Order Traversal 二叉树层序遍历 之后我们会继续讨论更多Tree相关的内容,并更新在 Tree Tag，尽请期待，种香蕉树去了：）]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Hash Table</tag>
        <tag>Tree</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 144] Binary Tree Preorder Traversal]]></title>
    <url>%2FLeetcode-144-Binary-Tree-Preorder-Traversal%2F</url>
    <content type="text"><![CDATA[原题说明Given a binary tree, return the preorder traversal of its nodes’ values. For example: Given binary tree [1,null,2,3], 1 \ 2 / 3 return [1,2,3]. 解题思路深度遍历二叉树（DFS），可以分为 前序遍历（preorder） 中序遍历（inorder） 后序遍历（postorder） 这题要求使用前序遍历。前序遍历简单是说总是按照根节点（root），左子节点（left），右子节点（right）的顺序深度遍历二叉树。 我们可以使用递归与非递归两种方法来实现前序遍历。递归的方便比较简单，参看相关代码就能明白。这里主要讲一下非递归的方法： 使用栈（stack），每次visit当前节点node，同时如果当前节点的右子节点非空，将此右子节点存入栈中，再将当前节点node更新为当前节点的左子节点。直到遍历完整棵二叉树。具体步骤为： 建立一个空栈stack 如果当前节点node非空或者栈stack非空： 2.1 如果当前节点node非空： 访问当前节点node 如果当前节点的右子节点非空，压入栈 更新当前节点node为它的左子节点，回到步骤2.1 2.2 如果栈非空，将当前节点更新为栈顶元素，并且退栈，回到步骤2 示例代码 （递归 python版）123456789101112131415161718192021class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ ans = [] self.preorderHelper(root, ans) return ans def preorderHelper(self, root, ans): if root: ans.append(root.val) self.preorderHelper(root.left, ans) self.preorderHelper(root.right, ans) 示例代码 （非递归 python版）12345678910111213141516171819202122232425class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = Noneclass Solution: def preorderTraversal(self, root): """ :type root: TreeNode :rtype: List[int] """ if not root: return [] ans = [] stack = collections.deque() while stack or root: while root : ans.append(root.val) if root.right: stack.append(root.right) root = root.left if stack: root = stack.pop() return ans 复杂度分析对递归方法，每个节点都被访问一次，考虑到本题并非平衡二叉树，最差将退化成链表，递归栈最大深度为O(n)。所以复杂度分析为： 时间复杂度： O(n) 空间复杂度：O(1), &#160; 递归栈深度O(n) 对非递归方法，同样每个节点都被访问一次，考虑到本题并非平衡二叉树，最差将退化成链表，栈最大深度为O(n)。所以复杂度分析为： 时间复杂度： O(n) 空间复杂度：O(n) 总结归纳：树的遍历是对树的基本操作之一。今天我们讲了前序遍历。相关的练习还有： [LeetCode 94] Binary Tree Inorder Traversal 二叉树中序遍历 [LeetCode 145] Binary Tree Postorder Traversal 二叉树后序遍历 [LeetCode 102] Binary Tree Level Order Traversal 二叉树层序遍历 之后我们会继续讨论更多Tree相关的内容,并更新在 Tree Tag，尽请期待，种香蕉树去了：）]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 162] Find Peak Element]]></title>
    <url>%2FLeetcode-162-Find-Peak-Element%2F</url>
    <content type="text"><![CDATA[原题说明A peak element is an element that is greater than its neighbors. Given an input array where num[i] ≠ num[i+1], find a peak element and return its index. The array may contain multiple peaks, in that case return the index to any one of the peaks is fine. You may imagine that num[-1] = num[n] = -∞. For example, in array [1, 2, 3, 1], 3is a peak element and your function should return the index number 2. Note: Your solution should be in logarithmic complexity. 解题思路题目要求给出一个数列中峰值的位置。注意的是数列中可能存在若干个峰值，我们只要给出其中任意一个的位置即可。举个例子：数列 [0,0,0,4,0,0,5,0,0]， 它的峰值分别是4,5，因此答案应该是3或者6。 最直接的想法用暴力搜索，直接遍历一遍数组，给出最大值得位置即可。这样时间复杂度是 O(n)。 如果我们想要降低时间复杂度到O(log n)，直觉上可以用二分搜索（Binary Search）。若是只有一个峰值，设最左边位置为low，最右边位置为high，这样中间位置为 mid = (high + low) / 2。判断准则为，若是 num[mid] &lt; num[mid+1], 我们就让low = mid，反之high = mid， 直到 low + 1等于high,终止二分。 有趣的是，如果存在若干个峰值，我们也不需要对以上算法进行改动。因为进过若干次的二分，在位置low和high之间终归会存在一个且仅有一个峰值。 示例代码 (python)1234567891011121314class Solution: def findPeakElement(self, nums): """ :type nums: List[int] :rtype: int """ low, high = 0, len(nums) - 1 while low &lt; high: mid = int(low + (high - low) / 2) if nums[mid] &gt; nums[mid + 1]: high = mid else: low = mid + 1 return low 示例代码 (c++)123456789101112131415class Solution &#123;public: int findPeakElement(const vector&lt;int&gt;&amp; nums) &#123; int low = 0; int high = nums.size() - 1; while (low + 1 &lt; high) &#123; int mid = low + (high - low) / 2; if (nums[mid] &lt; nums[mid + 1]) low = mid; else high = mid; &#125; return nums[low] &gt; nums[high] ? low : high; &#125;&#125;; 复杂度分析典型的二分法算法，并且只需要 low, high, mid 3个变量，所以时间和空间复杂度分别为： 时间复杂度：O(log n) 空间复杂度：O(1) 总结归纳：这是一道经典的二分算法题（Binary Search），一般如果要求在对数时间复杂度下完成，我们可以考虑使用二分搜索。今天的解题就到这里了，种香蕉树去了：）]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Array</tag>
        <tag>Google</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 739] Daily Temperatures]]></title>
    <url>%2FLeetcode-739-Daily-Temperatures%2F</url>
    <content type="text"><![CDATA[原题说明Given a list of daily temperatures, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead. For example, given the list temperatures = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0]. Note: The length of temperatures will be in the range [1, 30000]. Each temperature will be an integer in the range [30, 100]. 解题步骤这又是一道可以用Stack来解决的问题。 建立降序栈stk,存temperatures数组对应的 index 建立返回数组rets并且初始化为0 遍历temperatures数组： 每一个元素temp和stk的栈顶元素对应值比较，如果temp较大，说明遇到了 warmer temperature，所以在rets中更新栈顶元素对应的值，并且 pop 栈顶元素 重复上述过程，直到stk为空或者temp比栈顶值小，将当前index 进栈 示例代码(CPP)123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; int n = temperatures.size(); // 注意需要初始化为0 vector&lt;int&gt; rets(n, 0); stack&lt;int&gt; stk; for (int i = 0; i &lt; n; ++i) &#123; while (!stk.empty() &amp;&amp; temperatures[i] &gt; temperatures[stk.top()]) &#123; rets[stk.top()] = i - stk.top(); stk.pop(); &#125; // 注意push的是index，不是值 stk.push(i); &#125; return rets; &#125;&#125;; 示例代码(PYTHON)12345678910111213141516class Solution(object): def dailyTemperatures(self, temperatures): """ :type temperatures: List[int] :rtype: List[int] """ # 使用List代替stack stack = list() res = [0 for i in range(len(temperatures))] for i in range(len(temperatures)): while(len(stack) &gt; 0 and temperatures[i] &gt; temperatures[stack[-1]]): res[stack[-1]] = i - stack[-1]; stack.pop() # append等效为stack中的push stack.append(i) return res 复杂度分析因为每个字符push和pop都是最多一次，所以： 时间复杂度：O(n) 空间复杂度：O(n) 总结归纳：运用Stack的题目很多，这类问题的做法是遍历输入数组，当前元素与栈顶元素比较，如果当前元素更优（不同题目条件不同，比如本题对应当前元素较大）则pop栈顶元素，直到栈顶元素更优为止，而后插入当前元素。 类似的题目还有：[LeetCode 316] Remove Duplicate Letters 移除重复字母 最近会总结更多这类题目更新在Stack Tag中，尽请期待，吃香蕉去了：）]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Leetcode 316] Remove Duplicate Letters]]></title>
    <url>%2FLeetcode-316-Remove-Duplicate-Letters%2F</url>
    <content type="text"><![CDATA[原题说明Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example:Given &quot;bcabc&quot;Return &quot;abc&quot; Given &quot;cbacdcbc&quot;Return &quot;acdb&quot; 解题步骤 建立哈希表（或者数组)mapping来统计字符串中每一个字母出现的频率 建立哈希表（或者数组)visited来记录已经插入ret (return string) 的字母 将 ret 当作 stack，用 Greedy (贪心法）遍历字符串 s ： 若当前字符已经在 visited 中了，直接 continue 当前字符 ch 与 ret 字符串的末尾元素（栈顶）比较，若 ch 靠前，并且 mapping 中栈顶元素大于0 (即之后遍历中还会出现栈顶元素)，则 pop ret末尾元素，如此反复，直到 ret 末尾元素靠前，或者 ret 为空 在 ret 中插入当前字符 ch 插入与 pop 过程都不要忘记更新 visited 示例代码(CPP)123456789101112131415161718192021222324class Solution &#123;public: string removeDuplicateLetters(string s) &#123; unordered_map&lt;char, int&gt; mapping; unordered_set&lt;char&gt; visited; for (auto&amp; ch : s) &#123; mapping[ch]++; &#125; string ret; for (auto&amp; ch : s) &#123; mapping[ch]--; if (visited.count(ch)) &#123; continue; &#125; while (ret.size() &amp;&amp; ret.back() &gt; ch &amp;&amp; mapping[ret.back()] &gt; 0) &#123; visited.erase(ret.back()); ret.pop_back(); &#125; ret += ch; visited.insert(ch); &#125; return ret; &#125;&#125;; 示例代码(PYTHON)12345678910111213141516171819202122from collections import Counterclass Solution(object): def removeDuplicateLetters(self, s): """ :type s: str :rtype: str """ map = Counter() stack = list() visited = set() for c in s: map[c] += 1 for c in s: map[c] -= 1; if c in visited: continue else: visited.add(c) while(len(stack) &gt; 0 and c &lt; stack[-1] and map[stack[-1]] &gt; 0): visited.remove(stack[-1]) stack.pop() stack.append(c) visited.add(c) return ''.join(stack) 复杂度分析因为每个字符插入和pop出ret都是最多一次，所以： 时间复杂度：O(n) 空间复杂度：O(n) 总结归纳：运用Stack加贪心法的题目有很多，这类问题的做法是遍历输入数组，当前元素与栈顶元素比较，如果当前元素更优（不同题目条件不同，比如本题对应当前元素较小）则pop栈顶元素，直到栈顶元素更优为止，而后插入当前元素。 最近会着重介绍这类题目，之后会将链接贴在这里，尽请期待，吃香蕉去了：）]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Stack</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
</search>
