<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Amazon 行为面试解析</title>
    <url>/Amazon-Behavior-Questions/</url>
    <content><![CDATA[<p>Amazon是一家非常注重行为面试（Behavior Question）的公司，一般每一轮面试都会问2 - 3个行为面试问题，而且不同面试官的问题往往涉及不同方面。Amazon会因为行为面试不过关，将五年工作经验的同学lowball成L4（SDE I - Entry Level），也会以为行为面试表现优异，而破格录取在技术方面有缺陷的面试者。</p>
<p>Amazon的行为面试又非常有迹可循，其官方给出了<strong>十四条Leadership Principles</strong>（领导力准则）作为行为标准。行为面试的回答，应当能够通过事先准备好的<strong>亲身事例</strong>，尽可能深入而全面地覆盖这些准则。一般可以准备三到五个事例，每一个分别覆盖几个准则，这样面对不同的问题和不同的面试官，就可以运用<strong>不同</strong>的事例。面试官在面试完会集中交流，这时候就会看到多个事例覆盖了多个准则，而不是只有单一的事例或者仅仅提及了单一的准则。稍后在官方面试指南中也会提及相应的准备方法。</p>
<p>本文分三个部分：</p>
<p>1）列出Leadership Principles的官方解释，并逐条分析其重要性。</p>
<p>2）给出Amazon的官方面试指南，包括了可能涉及的问题，以及应该如何准备。</p>
<p>3）通过列举面试真题，给出参考答案，让大家对如何回答行为面试有一个直观了解。</p>
<h4 id="Leadership-Principles"><a href="#Leadership-Principles" class="headerlink" title="Leadership Principles"></a>Leadership Principles</h4><p>领导力准则</p>
<p>We use our Leadership Principles every day, whether we’re discussing ideas for new projects or deciding on the best approach to solving a problem. It is just one of the things that makes Amazon peculiar.</p>
<p><font color="blue"><strong>1. Customer Obsession** </strong></font><br>Leaders start with the customer and work backwards. They work vigorously to earn and keep customer trust. Although leaders pay attention to competitors, they obsess over customers.</p>
<p>顾客至尚<br>领导者从客户入手，再反向推动工作。他们努力工作，赢得并维系客户对他们的信任。虽然领导者会关注竞争对手，但是他们更关注客户。</p>
<p><font color="blue"><strong>2. Ownership** </strong></font><br>Leaders are owners. They think long term and don’t sacrifice long-term value for short-term results. They act on behalf of the entire company, beyond just their own team. They never say “that’s not my job”. </p>
<p>主人翁精神<br>领导者是主人翁。他们会从长远考虑，不会为了短期业绩而牺牲长期价值。他们不仅仅代表自己的团队，而且代表整个公司行事。他们绝不会说“那不是我的工作”。</p>
<p><font color="green"><strong>3. Invent and Simplify*</strong></font><br>Leaders expect and require innovation and invention from their teams and always find ways to simplify. They are externally aware, look for new ideas from everywhere, and are not limited by “not invented here”. As we do new things, we accept that we may be misunderstood for long periods of time.</p>
<p>创新简化<br>领导者期望并要求自己的团队进行创新和发明，并始终寻求使工作简化的方法。他们了解外界动态，四处寻找新的创意，并且不局限于“非我发明”的观念。当我们开展新事物时，我们要接受被长期误解的可能。</p>
<p><font color="green"><strong>4. Are Right, A Lot *</strong></font><br>Leaders are right a lot. They have strong judgment and good instincts. They seek diverse perspectives and work to disconfirm their beliefs.</p>
<p>决策正确<br>领导者在大多数情况下都能做出正确的决定。他们拥有卓越的业务判断能力和敏锐的直觉.他们寻求多样的视角，并挑战自己的观念。</p>
<p><font color="green"><strong>5. Learn and Be Curious *</strong></font><br>Leaders are never done learning and always seek to improve themselves. They are curious about new possibilities and act to explore them.</p>
<p>好奇求知<br>领导者从不停止学习，并不断寻找机会以提升自己。领导者对各种可能性充满好奇并付于行动加以探索。</p>
<p><strong>6. Hire and Develop the Best</strong><br>Leaders raise the performance bar with every hire and promotion. They recognize exceptional talent, and willingly move them throughout the organization. Leaders develop leaders and take seriously their role in coaching others. We work on behalf of our people to invent mechanisms for development like Career Choice.</p>
<p>选贤育能<br>领导者不断提升招聘和晋升员工的标准。他们表彰杰出的人才，并乐于在组织中通过轮岗磨砺他们。领导者培养领导人才，他们严肃地对待自己育才树人的职责。领导者从员工角度出发，创建职业发展机制。</p>
<p><font color="green"><strong>7. Insist on the Highest Standards *</strong></font><br>Leaders have relentlessly high standards - many people may think these standards are unreasonably high. Leaders are continually raising the bar and drive their teams to deliver high quality products, services and processes. Leaders ensure that defects do not get sent down the line and that problems are fixed so they stay fixed.</p>
<p>最高标准<br>领导者有着近乎严苛的高标准 — 这些标准在很多人看来可能高得不可理喻。领导者不断提高标准，激励自己的团队提供优质产品、服务和流程。领导者会确保任何问题不会蔓延，及时彻底解决问题并确保问题不再出现。</p>
<p><font color="green"><strong>8. Think Big *</strong></font><br>Thinking small is a self-fulfilling prophecy. Leaders create and communicate a bold direction that inspires results. They think differently and look around corners for ways to serve customers.</p>
<p>远见卓识<br>局限性思考只能带来局限性的结果。领导者大胆提出并阐明大局策略，由此激发良好的成果。他们从不同角度考虑问题，并广泛寻找服务客户的方式。</p>
<p><font color="green"><strong>9. Bias for Action *</strong></font><br>Speed matters in business. Many decisions and actions are reversible and do not need extensive study. We value calculated risk taking. </p>
<p>崇尚行动<br>速度对业务影响至关重要。很多决策和行动都可以改变，因此不需要进行过于广泛的推敲。我们提倡在深思熟虑前提下进行冒险。</p>
<p><strong>10. Frugality</strong><br>Accomplish more with less. Constraints breed resourcefulness, self-sufficiency and invention. There are no extra points for growing headcount, budget size or fixed expense.</p>
<p>勤俭节约<br>力争以更少的投入实现更大的产出。勤俭节约可以让我们开动脑筋、自给自足并不断创新。增加人力、预算以及固定支出并不会为你赢得额外加分。</p>
<p><font color="green"><strong>11. Earn Trust *</strong></font><br>Leaders listen attentively, speak candidly, and treat others respectfully. They are vocally self-critical, even when doing so is awkward or embarrassing. Leaders do not believe their or their team’s body odor smells of perfume. They benchmark themselves and their teams against the best.</p>
<p>赢得信任<br>领导者专注倾听，坦诚沟通，尊重他人。领导者敢于自我批评，即便这样做会令自己尴尬或难堪。他们并不认为自己或其团队总是对的。领导者会以最佳领导者和团队为标准来要求自己及其团队。</p>
<p><font color="green"><strong>12. Dive Deep *</strong></font><br>Leaders operate at all levels, stay connected to the details, audit frequently, and are skeptical when metrics and anecdote differ. No task is beneath them.</p>
<p>刨根问底<br>领导者深入各个环节，随时掌控细节，经常进行审核，当数据与传闻不一致时持有怀疑态度。领导者不会遗漏任何工作。</p>
<p><font color="green"><strong>13. Have Backbone; Disagree and Commit *</strong></font><br>Leaders are obligated to respectfully challenge decisions when they disagree, even when doing so is uncomfortable or exhausting. Leaders have conviction and are tenacious. They do not compromise for the sake of social cohesion. Once a decision is determined, they commit wholly.</p>
<p>敢于谏言，服从大局<br>领导者必须要能够不卑不亢地质疑他们无法苟同的决策，哪怕这样做让人心烦意乱，精疲力尽。领导者要信念坚定，矢志不移。他们不会为了保持一团和气而屈就妥协。一旦做出决定，他们就会全身心地致力于实现目标。</p>
<p><font color="green"><strong>14. Deliver Results *</strong></font><br>Leaders focus on the key inputs for their business and deliver them with the right quality and in a timely fashion. Despite setbacks, they rise to the occasion and never settle.</p>
<p>达成业绩<br>领导者会关注其业务的关键决定条件，确保工作质量并及时完成。尽管遭受挫折，领导者依然勇于面对挑战，从不气馁。</p>
<p>其中标记<font color="blue"><strong>蓝色**</strong></font>是最重要的准则，各类职位最好都能在某些回答中提及这两条。<font color="green"><strong>绿色*</strong></font>是对于技术岗位比较重要的，应该尽可能在不同问题的回答中覆盖这些准则。其他条目如果能覆盖当然最好，但可能领导岗位会更加看重些。当然最好是面试前和HR多聊一聊，对方很可能会暗示（明示）哪些条目对于你面试的岗位比较重要。</p>
<h4 id="Amazon官方面试指南"><a href="#Amazon官方面试指南" class="headerlink" title="Amazon官方面试指南"></a>Amazon官方面试指南</h4><p>面试前HR一般会根据不同职位发一个官方面试指南，我们截取其中共同的部分罗列如下，同学们看后应该会更了解如何回答行为面试问题，其中大部分内容对于<strong>其他公司</strong>也是适用的。</p>
<img src="/Amazon-Behavior-Questions/amazon_interview.jpg">
<p>The LPs (Leadership Principals) represent the core competencies that interviewers will be looking for from you. Each interviewer will be assigned <strong>2-3 LPs</strong> which they will be asked to evaluate you on. They will ask you questions like “Tell me about a time when…” where the question is geared toward evaluating each LP. </p>
<p>The interviewer will likely follow-up asking you to dive deeper in your story, so don’t fluff your story. If you say “I used X method to solve Y”. They’ll want to know how X works and what the business and customer focused results were of your actions. If you can’t explain X to a novice or the results of your actions, tell a different story.</p>
<p>We will ask you to give us examples from your experience to illustrate your strengths in these areas. That is, we don’t just ask, “Do you think it’s important to have a bias for action?” (to pick one of the leadership principles above). Rather, we will ask a question like, “Tell me about a time when you took action and made something happen.” We want to hear <strong>(true!) stories</strong> from your own history that provide the necessary evidence. We would recommend that you take some time before the interview to make a list of the technical &amp; leadership skills above, and think of <strong>2-3 stories</strong> from your background that show that you have those skills.</p>
<p><strong>STAR Method</strong> </p>
<p>The STAR method is a common interviewing practice of framing your stories around a situation, outlining the tasks or actions taken, and a result. All stories should start with a problem that is business and customer focused, list the tasks or actions that were taken, and end with the result.</p>
<p><strong>Be Guidable</strong></p>
<p>Interviewers will ask you to change directions frequently.</p>
<p><strong>Be Detail Orientated</strong></p>
<p>Don’t skim stories.</p>
<p><strong>Be Data Oriented</strong></p>
<p>Talk about numbers and results.</p>
<p><strong>Be Concise</strong></p>
<p>Don’t tell long monologues.</p>
<p><strong>Talk About Yourself</strong></p>
<p>Amazonians are interested in YOUR contribution.</p>
<p><strong>Be Earnest</strong></p>
<p>If you don’t know an answer, say so. Say how have found similar answers before.</p>
<h4 id="真题分析"><a href="#真题分析" class="headerlink" title="真题分析"></a>真题分析</h4><p>我们列举了两个比较难回答的问题为例进行分析。按照官方指南，我们要通过<strong>详实的例子</strong>，交代当时的<strong>情况</strong>，你面对的任务和<strong>处理方法</strong>，和最后的<strong>结果</strong>，最好能够有<strong>数据</strong>作为支撑，不能泛泛而谈。在实际面试时，应该多和面试官交流，先确定面试官要问的是不是自己所想的问题，这对于行为面试和技术面试都是同样适用的，有时候面试官甚至会故意问一些比较模糊的问题，希望你能够<strong>首先clarify问题</strong>，<strong>think loud</strong>，而不是盲目作答。另外，面试时面试官很可能会问更多细节或者转变问题方向，这时候一定要和挺清楚问题，而不是一味背之前准备好的答案。</p>
<p><strong>1. 说说你遇到的失败经历</strong></p>
<p>这个问题其实更注重的是你遇到了失败之后，从中学习到了什么，如果补救失败的经历。我们可以举例比如某个机器学习的项目，想当然用了linear regression结果效果不好（列出accuracy），没有达到要求 （这就是失败经历，但不要停在这里）。这时候离客户说的deadline还有一天，于是我们加班加点通过分析validation set，发现是under-fitting了。于是我们研究了更加复杂的模型，比如CNN，Random Forest等等，比较了他们的accuracy是多少多少，最终赶在ddl前解决了问题，让客户/老师满意，获得了第几名等等。</p>
<p>在这样一个例子中，我们就涉及了Bias to action, dive deep, customer obsession等等好几条准则。</p>
<p><strong>2. 你是否和你的领导有过不同的意见</strong></p>
<p>可以说有一个项目，你想用技术A来做，因为从长远的角度，这个方法更加scalable，可以让客户有更好的体验，但是你的领导认为应该用方法B，因为容易实现可以尽快上线。你和你的领导进行了细致的交流，分析了利弊，也听取了其他同事的意见，你认为多花一点时间努力工作技术A也可以快速上线，于是最终领导同意了你的方案，你每天多工作x个小时，最终在Y天内完成了该项目上线，现在这个项目可以很容易scale到同时间有Z用户在线。</p>
<p>这样一个例子中，就包括了Ownership，Right a lot, Think big, Earn trust等等多条LP。</p>
<blockquote><p>大家如果有疑问或是希望得到回答的Behavior Questions，可以在留言区评论，我们会一一解答。</p>
</blockquote>
<p>想要发现更多求职信息请<a href="https://article.xingxingpark.com/category/career/" target="_blank" rel="noopener">点击这里</a>:)</p>
]]></content>
      <categories>
        <category>career</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Behavior Question</tag>
        <tag>Leadership Principles</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1] Two Sum</title>
    <url>/Leetcode-1-Two-Sum/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have <strong>exactly</strong> one solution, and you may not use the same element twice.</p>
<p><strong>Example</strong>:<br><blockquote><p>Given <code>nums = [2, 7, 11, 15]</code>, <code>target = 9</code>,</p>
<p>Because <code>nums[0] + nums[1] = 2 + 7 = 9</code>,<br>return <code>[0, 1]</code>.</p>
</blockquote></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道非常经典的面试题. 由于被面的太多, 现在一般会考察这道题的变种, 但是原题也还是经常出现在电话面试中, 或者被当做热身题.</p>
<p>这道题的<code>O(n)</code>解法是利用<code>hash table</code>来存储遍历过的元素, 对于当前的元素<code>nums[i]</code>, 我们只需要判断<code>target - nums[i]</code>是否在哈希表中即可.</p>
<p>这道题可能会有follow up问能否不用额外空间, 那么就需要牺牲时间复杂度: 可以先排序, 然后用双指针两头扫遍历一遍即可, 这个方法此处不做赘述, 在<code>Three Sum</code>中会详细介绍.</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapping.count(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;mapping[target - nums[i]], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            mapping[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        numsIdxDict = dict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> (target - nums[i]) <span class="keyword">in</span> numsIdxDict:</span><br><span class="line">                <span class="keyword">return</span> [i, numsIdxDict[(target - nums[i])]]</span><br><span class="line">            numsIdxDict[nums[i]] = i</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code> <code>n</code>为<code>nums</code>数组长度<br>空间复杂度: <code>O(n)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>面试中如果遇到这道题, 也不要太高兴直接开始写答案, 还是要好好分析思路, 问清楚要求, 比如是不是一定有解, 可能有多少解, 能不能用额外空间等等.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Facebook</tag>
        <tag>Microsoft</tag>
        <tag>Bloomberg</tag>
        <tag>Uber</tag>
        <tag>Linkedin</tag>
        <tag>Apple</tag>
        <tag>Airbnb</tag>
        <tag>Yelp</tag>
        <tag>Yahoo</tag>
        <tag>Adobe</tag>
        <tag>Dropbox</tag>
        <tag>Array</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 10] Regular Expression Matching</title>
    <url>/Leetcode-10-Regular-Expression-Matching/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an input string (<code>s</code>) and a pattern (<code>p</code>), implement regular expression matching with support for <code>&#39;.&#39;</code> and <code>&#39;*&#39;</code>.</p>
<blockquote><p>‘.’ Matches any single character.<br>‘*’ Matches zero or more of the preceding element.</p>
</blockquote>
<p>The matching should cover the <strong>entire</strong> input string (not partial).</p>
<p><strong>Note:</strong></p>
<ul>
<li><code>s</code> could be empty and contains only lowercase letters <code>a-z</code>.</li>
<li><code>p</code> could be empty and contains only lowercase letters <code>a-z</code>, and characters like <code>.</code> or <code>*</code>.</li>
</ul>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong><br>s = “aa”<br>p = “a”<br><strong>Output:</strong> false<br><strong>Explanation:</strong> “a” does not match the entire string “aa”.</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong><br>s = “aa”<br>p = “a*“<br><strong>Output:</strong> true<br><strong>Explanation:</strong> ‘*‘ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”.</p>
</blockquote></p>
<p><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong><br>s = “ab”<br>p = “.*“<br><strong>Output:</strong> true<br><strong>Explanation:</strong> “.*“ means “zero or more (*) of any character (.)”.</p>
</blockquote></p>
<p><strong>Example 4:</strong><br><blockquote><p><strong>Input:</strong><br>s = “aab”<br>p = “c*a*b”<br><strong>Output:</strong> true<br><strong>Explanation:</strong> c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”.</p>
</blockquote></p>
<p><strong>Example 5:</strong><br><blockquote><p><strong>Input:</strong><br>s = “mississippi”<br>p = “mis*is*p*.”<br><strong>Output:</strong> false</p>
</blockquote></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p><em>以下解题思路以python版本为准, cpp版本则是简化的(无递归)动态规划解答, 读者任选其一即可</em></p>
<p>如果熟悉<a href="https://en.wikipedia.org/wiki/Edit_distance" target="_blank" rel="noopener">Edit distance</a>的话, 可以比较容易得想到用动态规划的办法求解.<br>类似<a href="https://en.wikipedia.org/wiki/Edit_distance" target="_blank" rel="noopener">Edit distance</a>的解法, 我们可以构建一个<code>SxP</code>的矩阵来记录状态.<br>该矩阵中位于坐标<code>i, j</code>的值代表字符串<code>s[i:]</code>和Pattern<code>p[j:]</code>是否匹配(若为None, 则代表未知).<br>求解该矩阵的过程可以看作遵循一定走法的同时，试图寻找一条从<code>(0, 0)</code>走到<code>(S + 1, P + 1)</code>的路径. (<code>S + 1</code>和<code>P + 1</code>可以看作是s和p的终结状态)</p>
<p>如果<code>s[i]</code>和<code>p[j]</code>是匹配的(<code>s[i] == p[j]</code> 或者 <code>p[j] == &#39;.&#39;</code>):</p>
<ul>
<li>如果<code>j + 1</code>是<code>*</code>的话，我们可以从<code>(i, j)</code>走到<code>(i, j + 2)</code>代表我们跳过这个pattern, 或者从<code>(i, j)</code>走到<code>(i + 1, j)</code>代表我们选择匹配这个字符</li>
<li>如果不是<code>*</code>的话，那么我们直接从<code>(i, j)</code>走到<code>(i + 1, j + 1)</code>. 这意味着我们匹配了<code>(i, j)</code></li>
</ul>
<p>如果不匹配:</p>
<ul>
<li>如果<code>j + 1</code>是<code>*</code>的话, 我们可以从<code>(i, j)</code>走到<code>(i, j + 2)</code>代表我们跳过这个pattern</li>
<li>如果不是, 那么说明必然不匹配, <code>(i, j)</code>的状态是<code>False</code><br>终结状态就是<code>s</code>和<code>p</code>都用完, 也就是走到<code>(S + 1, P + 1)</code>的时候.<br>如果<code>p</code>用完了, 但是<code>s</code>还有剩余, 那么显然不匹配.<br>如果<code>s</code>用完了, <code>p</code>还有剩余, 那么只有当接下来都是有<code>*</code>的pattern的时候才匹配.</li>
</ul>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, i, j, s, p, dp)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> j == len(p):</span><br><span class="line">            <span class="keyword">return</span> i == len(s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> i == len(s):</span><br><span class="line">            <span class="keyword">if</span> j &lt; len(p) - <span class="number">1</span> <span class="keyword">and</span> p[j + <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">return</span> self.dfs(i, j + <span class="number">2</span>, s, p, dp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> dp[i][j] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[i][j]</span><br><span class="line">        </span><br><span class="line">        curr_match = p[j] == <span class="string">'.'</span> <span class="keyword">or</span> s[i] == p[j]</span><br><span class="line">        <span class="keyword">if</span> j + <span class="number">1</span> &lt; len(p) <span class="keyword">and</span> p[j + <span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            dp[i][j] = self.dfs(i, j + <span class="number">2</span>, s, p, dp) \</span><br><span class="line">                        <span class="keyword">or</span> curr_match <span class="keyword">and</span> self.dfs(i + <span class="number">1</span>, j, s, p, dp)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = curr_match <span class="keyword">and</span> self.dfs(i + <span class="number">1</span>, j + <span class="number">1</span>, s, p, dp)</span><br><span class="line">        <span class="keyword">return</span> dp[i][j]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s, p)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type p: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = [[<span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(p))] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        <span class="keyword">return</span> self.dfs(<span class="number">0</span>, <span class="number">0</span>, s, p, dp)</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = s.size(), n = p.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] != <span class="string">'*'</span> &amp;&amp; p[j - <span class="number">1</span>] != <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (p[j - <span class="number">2</span>] == <span class="string">'.'</span> || p[j - <span class="number">2</span>] == s[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                        dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(SP)</code>, 其中<code>S</code>为<code>s</code>的长度, <code>P</code>为<code>p</code>的长度.<br>空间复杂度: <code>O(SP)</code>, 其中<code>S</code>为<code>s</code>的长度, <code>P</code>为<code>p</code>的长度</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这道题的思路还是比较容易想到用动态规划/递归来做的. 虽然这里python版本使用了DFS，但是因为记录了中间状态，本质上就是动态规划(如果读者细心比较，会发现时间空间复杂度也是一样的). 面试时, 还需要额外注意终结状态的判断和边界条件, 避免出现edge case或者访问了超出边界的矩阵坐标.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Uber</tag>
        <tag>Airbnb</tag>
        <tag>Google</tag>
        <tag>Twitter</tag>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1000] Minimum Cost to Merge Stones</title>
    <url>/Leetcode-1000-Minimum-Cost-to-Merge-Stones/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>There are <code>N</code> piles of stones arranged in a row.  The i-th pile has <code>stones[i]</code> stones.</p>
<p>A move consists of merging <strong>exactly K consecutive</strong> piles into one pile, and the cost of this move is equal to the total number of stones in these K piles.</p>
<p>Find the minimum cost to merge all piles of stones into one pile.  If it is impossible, return <code>-1</code>.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>stones = [3,2,4,1], K = 2</code><br><strong>Output:</strong> <code>20</code><br><strong>Explanation:</strong><br>We start with <code>[3, 2, 4, 1]</code>.<br>We merge <code>[3, 2]</code> for a cost of 5, and we are left with <code>[5, 4, 1]</code>.<br>We merge <code>[4, 1]</code> for a cost of 5, and we are left with <code>[5, 5]</code>.<br>We merge <code>[5, 5]</code> for a cost of 10, and we are left with <code>[10]</code>.<br>The total cost was <code>20</code>, and this is the minimum possible.</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>stones = [3,2,4,1], K = 3</code><br><strong>Output:</strong> <code>-1</code><br><strong>Explanation:</strong> After any merge operation, there are <code>2</code> piles left, and we can’t merge anymore.  So the task is impossible.</p>
</blockquote></p>
<p><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> <code>stones = [3,5,1,2,6], K = 3</code><br><strong>Output:</strong> <code>25</code><br><strong>Explanation:</strong><br>We start with <code>[3, 5, 1, 2, 6]</code>.<br>We merge <code>[5, 1, 2]</code> for a cost of 8, and we are left with <code>[3, 8, 6]</code>.<br>We merge <code>[3, 8, 6]</code> for a cost of 17, and we are left with <code>[17]</code>.<br>The total cost was 25, and this is the minimum possible.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>2 &lt;= K &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 100</code><a id="more"></a>
</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p><strong>动态规划：</strong><br><code>dp[i][j][k]</code> := 将<code>i</code>到<code>j</code>合并成<code>k</code>堆的最小cost<br><strong>初始状态：</strong><br><code>dp[i][j][k] = 0 if i==j and k == 1 else inf</code><br><strong>最终返回：</strong><br><code>dp[0][n-1][1]</code><br><strong>状态转移方程:</strong></p>
<ol>
<li><code>k &gt;= 2</code><br><code>dp[i][j][k] = min{dp[i][m][1] + dp[m+1][j][k-1]}</code> for all <code>i &lt;= m &lt; j</code></li>
<li><code>k == 1</code><br><code>dp[i][j][1] = dp[i][j][K] + sum of (stones[i] to stones[j])</code></li>
</ol>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergeStones</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        <span class="keyword">if</span> ((n - K) % (K - <span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// calculate the sum from 0 to i        </span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sumStones</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            sumStones[i + <span class="number">1</span>] = sumStones[i] + stones[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// initialize the 3d vector dp</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(K + <span class="number">1</span>, <span class="number">1e9</span>)))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// compute the transition functions</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> stepLen = <span class="number">2</span>; stepLen &lt;= n; ++stepLen) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt;= n - stepLen; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + stepLen - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k = <span class="number">2</span>; k &lt;= K; k++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> ( <span class="keyword">auto</span> m = i; m &lt; j; m += K - <span class="number">1</span>) &#123;</span><br><span class="line">                        dp[i][j][k] = min(dp[i][j][k], dp[i][m][<span class="number">1</span>] + dp[m + <span class="number">1</span>][j][k - <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = dp[i][j][K] + sumStones[j + <span class="number">1</span>] - sumStones[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n^3)</code><br>空间复杂度: <code>O(n^2 * K)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这道题还有更加优化的动态规划解法，但是思路不是非常直接，面试时也不太会要求掌握，同学们如果希望看到讲解，可以留言告诉我们。<br>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/F9FJEOXNn9M" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1001] Grid Illumination</title>
    <url>/Leetcode-1001-Grid-Illumination/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>On a N x N grid of cells, each cell <code>(x, y)</code> with <code>0 &lt;= x &lt; N</code> and <code>0 &lt;= y &lt; N</code> has a lamp.</p>
<p>Initially, some number of lamps are on.  <code>lamps[i]</code> tells us the location of the i-th lamp that is on.  Each lamp that is on illuminates every square on its x-axis, y-axis, and both diagonals (similar to a Queen in chess).</p>
<p>For the i-th query <code>queries[i] = (x, y)</code>, the answer to the query is 1 if the cell <code>(x, y)</code> is illuminated, else 0.</p>
<p>After each query <code>(x, y)</code> [in the order given by queries], we turn off any lamps that are at cell <code>(x, y)</code> or are adjacent 8-directionally (ie., share a corner or edge with cell <code>(x, y)</code>.)</p>
<p>Return an array of answers.  Each value <code>answer[i]</code> should be equal to the answer of the i-th query <code>queries[i]</code>.</p>
<p><strong>Example 1:</strong></p>
<p><strong>Input:</strong> <code>N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]</code><br><strong>Output:</strong> <code>[1,0]</code><br><strong>Explanation:</strong><br>Before performing the first query we have both lamps <code>[0,0]</code> and <code>[4,4]</code> on.<br>The grid representing which cells are lit looks like this, where <code>[0,0]</code> is the top left corner, and <code>[4,4]</code> is the bottom right corner:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1 1 1 1</span><br><span class="line">1 1 0 0 1</span><br><span class="line">1 0 1 0 1</span><br><span class="line">1 0 0 1 1</span><br><span class="line">1 1 1 1 1</span><br></pre></td></tr></table></figure></p>
<p>Then the query at <code>[1, 1]</code> returns 1 because the cell is lit.  After this query, the lamp at <code>[0, 0]</code> turns off, and the grid now looks like this:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 0 0 0 1</span><br><span class="line">0 1 0 0 1</span><br><span class="line">0 0 1 0 1</span><br><span class="line">0 0 0 1 1</span><br><span class="line">1 1 1 1 1</span><br></pre></td></tr></table></figure></p>
<p>Before performing the second query we have only the lamp <code>[4, 4]</code> on.  Now the query at <code>[1, 0]</code> returns 0, because the cell is no longer lit.</p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
<li><code>0 &lt;= lamps.length &lt;= 20000</code></li>
<li><code>0 &lt;= queries.length &lt;= 20000</code></li>
<li><code>lamps[i].length == queries[i].length == 2</code><a id="more"></a>
</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>每个点对于横向(<code>x</code>)、纵向(<code>y</code>)、斜向(<code>x - y</code>)和反斜向(<code>x + y</code>)，都有各自对应的位置变量，一共4个<br>以这四种位置变量为基础，建立4个hash table。hash table的key是位置变量，value是对应位置变量上的亮灯个数<br>每个点是否被照亮取决于这个点对应的四个位置变量在对应的hash table中是否存在（当<code>value == 0</code>时，我们会直接erase这对key-value）</p>
<p><strong>亮灯阶段:</strong><br>    更新四个hash table，同时用一个hash table (命名为<code>lamps_status</code>) 记录灯的坐标和状态</p>
<p><strong>query阶段:</strong></p>
<ol>
<li>对于每一个query，先以该query点的4个位置变量check这个点是不是会被照亮</li>
<li>遍历该点的邻居和它自身。如果有灯并且灯亮着，需要update相应的4个hash map的信息以及<code>lamps_status</code>的信息</li>
</ol>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">                                &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">                                &#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">gridIllumination</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; lamps, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; row_count; <span class="comment">// row information, value is the number of lightening lamps in the same row</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; col_count; <span class="comment">// column information</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; diag_count; <span class="comment">// diag information</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; anti_diag_count; <span class="comment">// anti_diag information</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; lamps_status; <span class="comment">//lamps information, key is the coordinate of the lamp, value is the status of lamp</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; lamp : lamps) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = lamp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = lamp[<span class="number">1</span>];</span><br><span class="line">            lamps_status[x][y] = <span class="number">1</span>;</span><br><span class="line">            row_count[x]++;</span><br><span class="line">            col_count[y]++;</span><br><span class="line">            diag_count[x - y]++;</span><br><span class="line">            anti_diag_count[x + y]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; query : queries) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = query[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> y = query[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// check if this query point is light</span></span><br><span class="line">            <span class="keyword">if</span> (row_count.count(x) || col_count.count(y) || diag_count.count(x-y) || anti_diag_count.count(x + y)) &#123;</span><br><span class="line">                res.push_back(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// turn off the light if necessary</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> xNew = x + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> yNew = y + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (xNew &gt;= <span class="number">0</span> &amp;&amp; xNew &lt; N &amp;&amp; yNew &gt;= <span class="number">0</span> &amp;&amp; yNew &lt; N &amp;&amp; lamps_status.count(xNew) &amp;&amp; lamps_status[xNew].count(yNew) &amp;&amp; lamps_status[xNew][yNew]) &#123;</span><br><span class="line">                    <span class="comment">// update the lamp status, turn it off</span></span><br><span class="line">                    lamps_status[xNew][yNew] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (row_count.count(xNew) &amp;&amp; --row_count[xNew] == <span class="number">0</span>) &#123;</span><br><span class="line">                        row_count.erase(xNew);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (col_count.count(yNew) &amp;&amp; --col_count[yNew] == <span class="number">0</span>) &#123;</span><br><span class="line">                        col_count.erase(yNew);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (diag_count.count(xNew - yNew) &amp;&amp; --diag_count[xNew - yNew] == <span class="number">0</span>) &#123;</span><br><span class="line">                        diag_count.erase(xNew - yNew);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (anti_diag_count.count(xNew + yNew) &amp;&amp; --anti_diag_count[xNew + yNew] == <span class="number">0</span>) &#123;</span><br><span class="line">                        anti_diag_count.erase(xNew + yNew);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>如果我们有<code>k</code>个queries<br>时间复杂度: <code>O(N^2 + K)</code><br>空间复杂度: <code>O(4N + N^2) = O(N^2)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/V0ebjgzDZdA" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Dropbox</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1002] Find Common Characters</title>
    <url>/Leetcode-1002-Find-Common-Characters/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an array <code>A</code> of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates).  For example, if a character occurs <code>3</code> times in all strings but not <code>4</code> times, you need to include that character three times in the final answer.</p>
<p>You may return the answer in any order.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</code><br><strong>Output:</strong> <code>[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</code></p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</code><br><strong>Output:</strong> <code>[&quot;c&quot;,&quot;o&quot;]</code></p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ul>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 100</code></li>
<li><code>A[i][j]</code> is a lowercase letter<a id="more"></a>
</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>用哈希表<code>ansMap</code>记录当前可能字符以及其出现次数，也就是把字符作为<code>key</code>，频率作为<code>value</code><br>用哈希表<code>midMap</code>记录当前字符串的字符以及出现次数，同样把字符作为<code>key</code>，频率作为<code>value</code></p>
<p><strong>核心思想</strong>:</p>
<ol>
<li>用第一个字符串初始化<code>ansMap</code></li>
<li>遍历剩余字符串，每次遍历前，先清空<code>midMap</code>，再遍历当前字符串，更新<code>midMap</code>；<br>将<code>ansMap</code>中的<code>key</code>与<code>midMap</code>做比较：<ul>
<li>如果不在<code>midMap</code>中，直接在<code>ansMap</code>中删除这个<code>key</code>； </li>
<li>否则更新<code>ansMap</code>中<code>key</code>对应的<code>value</code>，取为<code>midMap</code>和<code>ansMap</code>中值较小的那个</li>
</ul>
</li>
<li>遍历<code>ansMap</code>，确定返回的<code>vector&lt;string&gt;</code></li>
</ol>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">commonChars</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; ansMap;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; midMap;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : A[<span class="number">0</span>]) &#123;</span><br><span class="line">            ansMap[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt; A.size() ; ++i) &#123;</span><br><span class="line">            midMap.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : A[i]) &#123;</span><br><span class="line">                midMap[c]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ansMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> iter = ansMap.begin(); iter != ansMap.end(); ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (midMap.count(iter-&gt;first)) &#123; </span><br><span class="line">                    ansMap[iter-&gt;first] = min(ansMap[iter-&gt;first], midMap[iter-&gt;first]);</span><br><span class="line">                    iter++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    iter = ansMap.erase(iter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = ansMap.begin(); iter != ansMap.end(); iter++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; ansMap[iter-&gt;first]; ++i) &#123;</span><br><span class="line">                ans.push_back(<span class="built_in">string</span>(<span class="number">1</span>, iter-&gt;first));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/ldnAFjkS22k" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Hash Table</tag>
        <tag>TripAdvisor</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1003] Check If Word Is Valid After Substitutions</title>
    <url>/Leetcode-1003-Check-If-Word-Is-Valid-After-Substitutions/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>We are given that the string <code>&quot;abc&quot;</code> is valid.</p>
<p>From any valid string <code>V</code>, we may split <code>V</code> into two pieces <code>X</code> and <code>Y</code> such that <code>X + Y</code> (<code>X</code> concatenated with <code>Y</code>) is equal to <code>V</code>.  (<code>X</code> or <code>Y</code> may be empty.)  Then, <code>X + &quot;abc&quot; + Y</code> is also valid.</p>
<p>If for example <code>S = &quot;abc&quot;</code>, then examples of valid strings are: <code>&quot;abc&quot;</code>, <code>&quot;aabcbc&quot;</code>, <code>&quot;abcabc&quot;</code>, <code>&quot;abcabcababcc&quot;</code>.  Examples of invalid strings are: <code>&quot;abccba&quot;</code>, <code>&quot;ab&quot;</code>, <code>&quot;cababc&quot;</code>, <code>&quot;bac&quot;</code>.</p>
<p>Return true if and only if the given string <code>S</code> is valid.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>&quot;aabcbc&quot;</code><br><strong>Output:</strong> <code>true</code><br><strong>Explanation:</strong><br>We start with the valid string <code>&quot;abc&quot;</code>.<br>Then we can insert another <code>&quot;abc&quot;</code> between <code>&quot;a&quot;</code> and <code>&quot;bc&quot;</code>, resulting in <code>&quot;a&quot; + &quot;abc&quot; + &quot;bc&quot;</code> which is <code>&quot;aabcbc&quot;</code>.</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>&quot;abcabcababcc&quot;</code><br><strong>Output:</strong> <code>true</code><br><strong>Explanation:</strong><br><code>&quot;abcabcabc&quot;</code> is valid after consecutive insertings of <code>&quot;abc&quot;</code>.<br>Then we can insert <code>&quot;abc&quot;</code> before the last letter, resulting in <code>&quot;abcabcab&quot; + &quot;abc&quot; + &quot;c&quot;</code> which is <code>&quot;abcabcababcc&quot;</code>.</p>
</blockquote></p>
<p><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> <code>&quot;abccba&quot;</code><br><strong>Output:</strong> <code>false</code></p>
</blockquote></p>
<p><strong>Example 4:</strong><br><blockquote><p><strong>Input:</strong> <code>&quot;cababc&quot;</code><br><strong>Output:</strong> <code>false</code></p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= S.length &lt;= 20000</code></li>
<li><code>S[i]</code> is <code>&#39;a&#39;</code>, <code>&#39;b&#39;</code>, or <code>&#39;c&#39;</code></li>
</ol>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题和括号相关的题很像<br>遍历<code>S</code>:<br>1) 当遇到<code>&#39;a&#39;</code>或<code>&#39;b&#39;</code>时，用一个栈<code>stk</code>来存储<br>2) 当遇到<code>&#39;c&#39;</code>时，pop栈中的元素，看能否依次pop出<code>&#39;b&#39;</code>和<code>&#39;c&#39;</code>，如果不能则返回<code>false</code><br>遍历结束后，如果<code>stk</code>为空，则返回<code>true</code>，不然为<code>false</code></p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != <span class="string">'c'</span>) &#123;</span><br><span class="line">                stk.push(ch);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stk.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (stk.top() != <span class="string">'b'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.pop();</span><br><span class="line">                <span class="keyword">if</span> (stk.top() != <span class="string">'a'</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code> <code>n</code>为<code>S</code>的长度<br>空间复杂度: <code>O(n)</code> </p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/1fYgCFsQCxk" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Nutanix</tag>
        <tag>Stack</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1004] Max Consecutive Ones III</title>
    <url>/Leetcode-1004-Max-Consecutive-Ones-III/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an array <code>A</code> of 0s and <code>1</code>s, we may change up to <code>K</code> values from <code>0</code> to <code>1</code>.</p>
<p>Return the length of the longest (contiguous) subarray that contains only <code>1</code>s. </p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> A = <code>[1,1,1,0,0,0,1,1,1,1,0], K = 2</code><br><strong>Output:</strong> <code>6</code><br><strong>Explanation:</strong><br>[1, 1, 1, 0, 0, <strong><u>1</u></strong>, <u>1</u>, <u>1</u>, <u>1</u>, <u>1</u>, <strong><u>1</u></strong>]<br>Bolded numbers were flipped from <code>0</code> to <code>1</code>.  The longest subarray is underlined.</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3</code><br><strong>Output:</strong> <code>10</code><br><strong>Explanation:</strong><br>[0, 0, <u>1</u>, <u>1</u>, <u><strong>1</strong></u>, <u><strong>1</strong></u>, <u>1</u>, <u>1</u>, <u>1</u>, <u><strong>1</strong></u>, <u>1</u>, <u>1</u>, 0, 0, 0, 1, 1, 1, 1]<br>Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ul>
<li><code>1 &lt;= A.length &lt;= 20000</code></li>
<li><code>0 &lt;= K &lt;= A.length</code></li>
<li><code>A[i] is 0 or 1</code></li>
</ul>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>使用双指针解题：</p>
<ul>
<li><code>zeros</code>用来记录我们考察的子序列中将<code>0</code>变为<code>1</code>的次数。</li>
<li>用<code>right</code>指针从左向右遍历数组<code>A</code>，<code>right</code>指针表示当前我们考察的子序列的最右位置，如果遇到<code>0</code>，则<code>zeros++</code>，表示增加一次翻转。</li>
<li><code>left</code>指针用来记录当前子序列最左的位置，如果发现<code>zeros &gt; K</code>, 则将<code>left</code>向右推进，直到<code>zeros &lt;= K</code>。<br>推进过程中，如果遇到<code>0</code>，则<code>zeros--</code>，表示当前的<code>0</code>不在考察子序列当中。</li>
<li><code>left</code>指针实际上一直在追赶<code>right</code>。</li>
</ul>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> zeros = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> right = <span class="number">0</span>; right &lt; A.size(); ++right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[right] == <span class="number">0</span>)</span><br><span class="line">                zeros++;</span><br><span class="line">            <span class="keyword">while</span> (zeros &gt; K) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[left] == <span class="number">0</span>) &#123;</span><br><span class="line">                    zeros--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = max(right - left + <span class="number">1</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/g1eMPnclJfU" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Two Pointers</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1005] Maximize Sum Of Array After K Negations</title>
    <url>/Leetcode-1005-Maximize-Sum-Of-Array-After-K-Negations/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an array <code>A</code> of integers, we must modify the array in the following way: we choose an i and replace <code>A[i]</code> with <code>-A[i]</code>, and we repeat this process <code>K</code> times in total.  (We may choose the same index <code>i</code> multiple times.)</p>
<p>Return the largest possible sum of the array after modifying it in this way.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>A = [4,2,3], K = 1</code><br><strong>Output:</strong> <code>5</code><br><strong>Explanation:</strong> Choose indices (1,) and A becomes <code>[4,-2,3]</code>.</p>
</blockquote><br><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>A = [3,-1,0,2], K = 3</code><br><strong>Output:</strong> 6<br><strong>Explanation:</strong> Choose indices (1, 2, 2) and A becomes <code>[3,1,0,2]</code>.</p>
</blockquote><br><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> <code>A = [2,-3,-1,5,-4], K = 2</code><br><strong>Output:</strong> <code>13</code><br><strong>Explanation:</strong> Choose indices (1, 4) and A becomes <code>[2,3,-1,5,4]</code>.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>1 &lt;= K &lt;= 10000</code></li>
<li><code>-100 &lt;= A[i] &lt;= 100</code></li>
</ol>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们首先排序数组<code>A</code>，然后按顺序从小到大遍历数组，将负的元素变为正数，每改变一个元素，需要<code>--K</code>来记录翻转的个数，停止的条件有三个：<br> 1）如果数组遍历完毕<br> 2）如果<code>K</code>不再大于<code>0</code>，则说明翻转次数用完了<br> 3）如果当前元素<code>A[i] &gt;= 0</code>, 为了保证最终结果最大，不用继续翻转<br>遍历结束后得到的<code>A</code>的和已经是最大可能，当然还必须将剩余的<code>K</code>次翻转用掉：<br> 1）如果K为偶数，只需要对任意元素翻转相同次数，<code>A</code>的和不变<br> 2）如果K为奇数，则对最小的元素翻转K次，最终结果为A的和减去两倍的最小元素<br>所以我们再顺序遍历一遍数组（用<code>getSum</code>函数），取得当前的和<code>sum</code>，以及数组最小元素<code>min_ele</code>。<br>返回 <code>sum - (K % 2) * 2 * min_ele</code> 即可。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// Get the sum of vector A, and make min_ele equal to the minimum element in A</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span>&amp; min_ele)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        min_ele = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ele : A) &#123;</span><br><span class="line">            min_ele = min(min_ele, ele); </span><br><span class="line">            sum += ele;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; K &gt; <span class="number">0</span> &amp;&amp; i &lt; A.size() &amp;&amp; A[i] &lt; <span class="number">0</span>; ++i, --K) &#123;</span><br><span class="line">            A[i] = -A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min_ele;</span><br><span class="line">        <span class="keyword">int</span> sum = getSum(A, min_ele);</span><br><span class="line">        <span class="keyword">return</span> sum - (K % <span class="number">2</span>) * min_ele * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestSumAfterKNegations</span><span class="params">(self, A, K)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type K: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        A.sort()</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(A) <span class="keyword">and</span> i &lt; K <span class="keyword">and</span> A[i] &lt; <span class="number">0</span>:</span><br><span class="line">            A[i] = -A[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sum(A) - (K - i) % <span class="number">2</span> * min(A) * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; K &gt; <span class="number">0</span> &amp;&amp; i &lt; A.length &amp;&amp; A[i] &lt; <span class="number">0</span>; ++i, --K)</span><br><span class="line">            A[i] = -A[i];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            res += a;</span><br><span class="line">            min = Math.min(min, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res - (K % <span class="number">2</span>) * min * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(nlog(n))</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/7iMipH_1mKo?list=PLwVaSd26TDqoGHGYifjGqGx9o87LuuRcS" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>druva</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 101] Symmetric Tree</title>
    <url>/Leetcode-101-Symmetric-Tree/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<p>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</p>
<pre><code>    1   
   / \
  2   2
 / \ / \
3  4 4  3
</code></pre><p>But the following</p>
<pre><code>  1   
 / \
2   2
 \   \
 3    3
</code></pre><p>Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题要求判断二叉树是否对称。简单来说，对一颗二叉树做镜像翻转，如果翻转后的二叉树与原树相同，即可判断为对称，反之则不对称。</p>
<p>我们可以用递归与非递归两种解法来完成这题，但总体思路上就是之前所说的。</p>
<p>在递归方法总是相对简单，我们使用深度搜索<code>DFS</code>来实现。用一个辅助函数<code>helpcheck</code>来完成对两棵树的同时遍历。这里我们只要对原本该遍历<code>left</code>的地方换成<code>right</code>,<code>right</code>的地方换成<code>left</code>,就完成了对镜像树的遍历。</p>
<p>在非递归方法中，我们使用广度搜索<code>BFS</code>来实现。使用双端队列来实现。每次从队列头部pop出两棵树的对应节点做判断，节点值不同，则返回<em>False</em>；如果满足条件，在把它们对应的左右子节点存入队尾。直到队列为空时，返回<em>True</em></p>
<h4 id="示例代码-（递归-python）"><a href="#示例代码-（递归-python）" class="headerlink" title="示例代码 （递归 python）"></a>示例代码 （递归 python）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.helpcheck(root, root)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helpcheck</span><span class="params">(self, left, right)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">or</span> <span class="keyword">not</span> right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.helpcheck(left.left, right.right) <span class="keyword">and</span> self.helpcheck(left.right, right.left)</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-（递归-cpp）"><a href="#示例代码-（递归-cpp）" class="headerlink" title="示例代码 （递归 cpp）"></a>示例代码 （递归 cpp）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkHelper</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!left &amp;&amp; !right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!left || !right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left-&gt;val != right-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> checkHelper(left-&gt;left, right-&gt;right) &amp;&amp; checkHelper(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> checkHelper(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-（非递归-python）"><a href="#示例代码-（非递归-python）" class="headerlink" title="示例代码 （非递归 python）"></a>示例代码 （非递归 python）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        q.extend([root,root])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmpNode1 = q.popleft()</span><br><span class="line">            tmpNode2 = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> tmpNode1.val != tmpNode2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> tmpNode1.left <span class="keyword">and</span> tmpNode2.right:</span><br><span class="line">                q.extend([tmpNode1.left, tmpNode2.right])</span><br><span class="line">            <span class="keyword">elif</span> (tmpNode1.left <span class="keyword">and</span> <span class="keyword">not</span> tmpNode2.right) <span class="keyword">or</span> (<span class="keyword">not</span> tmpNode1.left <span class="keyword">and</span> tmpNode2.right):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> tmpNode1.right <span class="keyword">and</span> tmpNode2.left:</span><br><span class="line">                q.extend([tmpNode1.right, tmpNode2.left])</span><br><span class="line">            <span class="keyword">elif</span> (tmpNode1.right <span class="keyword">and</span> <span class="keyword">not</span> tmpNode2.left) <span class="keyword">or</span> (<span class="keyword">not</span> tmpNode1.right <span class="keyword">and</span> tmpNode2.left):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="示例代码-（非递归-cpp）"><a href="#示例代码-（非递归-cpp）" class="headerlink" title="示例代码 （非递归 cpp）"></a>示例代码 （非递归 cpp）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* left = root;</span><br><span class="line">        TreeNode* right = root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodeStackL;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodeStackR;</span><br><span class="line">        <span class="keyword">while</span>(left || !nodeStackL.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(left) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                nodeStackL.push(left);</span><br><span class="line">                nodeStackR.push(right);</span><br><span class="line">                left = left-&gt;left;</span><br><span class="line">                right = right-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!nodeStackL.empty()) &#123;</span><br><span class="line">                left = nodeStackL.top();</span><br><span class="line">                right = nodeStackR.top();</span><br><span class="line">                nodeStackL.pop();</span><br><span class="line">                nodeStackR.pop();</span><br><span class="line">                left = left-&gt;right;</span><br><span class="line">                right = right-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>对递归深度搜索，每个节点被访问一次，因此时间复杂度为<code>O(n)</code>。考虑到本题并非平衡二叉树，最差将退化成链表，递归栈最大深度为<code>O(n)</code>。因此其复杂度为：</p>
<ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>空间复杂度：<code>O(1)</code>, &#160; 递归栈深度<code>O(n)</code></li>
</ul>
<p>对非递归广度搜索，每个节点被访问一次，时间复杂度为<code>O(n)</code>。队的最大长度为其中最宽的层的节点数，因此空间复杂度仍然为<code>O(n)</code>.</p>
<ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>空间复杂度： <code>O(n)</code></li>
</ul>
<h4 id="总结归纳："><a href="#总结归纳：" class="headerlink" title="总结归纳："></a>总结归纳：</h4><p>本题想清楚树的对称的定义，便能利用深度搜索<code>DFS</code>和广度搜索<code>BFS</code>两种树的遍历的方法解题。类似的题目在实现的过程中一般都是利用这两种遍历方法，所以需要大家对树的遍历能够比较熟悉，以便加以利用。</p>
<p>之后我们还会添加一些相关的练习。同时大家可以在<a href="/tags/Tree">Tree Tag</a> 中找到更多和树有关的内容。种香蕉树去了：）</p>
<p><a href="/Leetcode-144-Binary-Tree-Preorder-Traversal">[LeetCode 144] Binary Tree Preorder Traversal 二叉树前序遍历</a></p>
<p><a href="/Leetcode-94-Binary-Tree-Inorder-Traversal">[LeetCode 94] Binary Tree Inorder Traversal 二叉树中序遍历</a></p>
<p><a href="/leetcode-145-Binary-Tree-Postorder-Traversal">[LeetCode 145] Binary Tree Postorder Traversal 二叉树后序遍历</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Bloomberg</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1010] Pairs of Songs With Total Durations Divisible by 60</title>
    <url>/Leetcode-1010-Pairs-of-Songs-With-Total-Durations-Divisible-by-60/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>In a list of songs, the <code>i</code>-th song has a duration of <code>time[i]</code> seconds. </p>
<p>Return the number of pairs of songs for which their total duration in seconds is divisible by 60.  Formally, we want the number of indices <code>i &lt; j</code> with <code>(time[i] + time[j]) % 60 == 0</code>.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>[30,20,150,100,40]</code><br><strong>Output:</strong> <code>3</code><br><strong>Explanation:</strong> Three pairs have a total duration divisible by 60:<br>(time[0] = 30, time[2] = 150): total duration 180<br>(time[1] = 20, time[3] = 100): total duration 120<br>(time[1] = 20, time[4] = 40): total duration 60</p>
</blockquote><br><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>[60,60,60]</code><br><strong>Output:</strong> 3<br><strong>Explanation:</strong> All three pairs have a total duration of 120, which is divisible by 60.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= time.length &lt;= 60000</code></li>
<li><code>1 &lt;= time[i] &lt;= 500</code></li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>一个pair能被60整除，意味着两个数的余数的和也能被<code>60</code>整除。因此，一个数可以按照对<code>60</code>的余数进行分类。这样，按题目给出的要求，一共有<code>0，1，2，...，59</code>一共<code>60</code>个分类。当两个分类的和被<code>60</code>整除时，从每个分类中任意选取1个数，都能组成满足题目要求的一个pair。</p>
<p>因此，我们可以用一个哈希表<code>mapping</code>记录上述的分类，哈希表的<code>key</code>是余数，<code>value</code>是有着对应余数的数的个数。</p>
<p>这里，最简单的做法是先遍历一边<code>time</code>，将<code>mapping</code>更新好。然后再遍历一边<code>mapping</code>,按照余数计算pair的数量。但是这个方法的缺点在于：</p>
<ol>
<li>需要遍历一遍<code>time</code>，再遍历一遍<code>mapping</code></li>
<li>需要对<code>0</code>和<code>30</code>两类余数的情况做特殊处理。因为他们对应的满足题目条件的余数就是他们自身。</li>
</ol>
<p>所以我们提供一种只遍历一遍<code>time</code>的方法，并且不需要特别处理余数是<code>0</code>和<code>30</code>的情况</p>
<p>算法：遍历<code>time</code>，在每个 iteration 中，当前元素对<code>60</code>的余数是<code>remainder</code>，在pair中对应的余数是<code>c_remainder</code>。这样，pair增加的数量就是<code>mapping</code>中<code>c_remainder</code>的<code>value</code>。同时，需要再更新<code>mapping</code>，使得<code>mapping[remainder]++</code>。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numPairsDivisibleBy60</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; time)</span> </span>&#123;        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mapping;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ele : time) &#123;</span><br><span class="line">            <span class="keyword">int</span> remainder = ele % <span class="number">60</span>;</span><br><span class="line">            <span class="keyword">int</span> c_remainder = (<span class="number">60</span> - remainder) % <span class="number">60</span>;</span><br><span class="line">            <span class="keyword">if</span> (mapping.count(c_remainder)) &#123;</span><br><span class="line">                res += mapping[c_remainder];</span><br><span class="line">            &#125;</span><br><span class="line">            mapping[remainder]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/i9VSosl-2Js" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Array</tag>
        <tag>Goldman Sachs</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1012] Numbers With Repeated Digits</title>
    <url>/Leetcode-1012-Numbers-With-Repeated-Digits/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a positive integer N, return the number of positive integers less than or equal to N that have at least 1 repeated digit.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>20</code><br><strong>Output:</strong> <code>1</code><br><strong>Explanation:</strong> The only positive number <code>(&lt;= 20)</code> with at least <code>1</code> repeated digit is <code>11</code>.</p>
</blockquote><br><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>100</code><br><strong>Output:</strong> <code>10</code><br><strong>Explanation:</strong> The positive numbers <code>(&lt;= 100)</code> with atleast <code>1</code> repeated digit are <code>11, 22, 33, 44, 55, 66, 77, 88, 99</code>, and <code>100</code>.</p>
</blockquote><br><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> <code>1000</code><br><strong>Output:</strong> <code>262</code>.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求求出比<code>N</code>小，同时至少存在一个重复数字的正整数的个数。运用<code>brute force</code>方法直接计算满足题目要求的数会有超时的问题，时间复杂度是<code>O(N)</code>，不满足要求。更好的方法是先求出所有不满足要求的数的个数<code>res</code>，再用<code>N</code>减去<code>res</code>，反过来得出答案。</p>
<p>这里，不满足题目要求的数可以分为两类;</p>
<ol>
<li>第一类是位数比<code>N</code>小的数，同时数字各不相同</li>
<li>第二类是位数与<code>N</code>相同的，比N小，同时数字各不相同。</li>
</ol>
<p>这两类数就包含了所有不大于N，同时数字各不相同的数，而剩下的数就是至少包含一个相同数字，且不大于<code>N</code>的数。</p>
<p>同时，我们需要一个辅助函数<code>helper</code>,它的作用是用来求出<code>m</code>个不同数字组成长度是<code>n</code>位的数的个数。</p>
<p>第一类数的求解相对简单，最高位的可能是<code>1~9</code>一共9中可能，之后可以直接调用<code>helper</code>方便求解。</p>
<p>第二类数，需要分别对不同的相同前缀做分类计算。在确定相同前缀之后，再次调用<code>helper</code>可以求出对应的数的个数。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">example: 8765</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">the number with digits &lt; N</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">XXX</span></span><br><span class="line"><span class="comment">XX</span></span><br><span class="line"><span class="comment">X</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">number with same prefix</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1XXX ~ 7XXX</span></span><br><span class="line"><span class="comment">80XX ~ 86XX</span></span><br><span class="line"><span class="comment">870X ~ 875X</span></span><br><span class="line"><span class="comment">8760 ~ 8765</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDupDigitsAtMostN</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N_copy = N + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">        <span class="keyword">while</span> (N_copy &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr.insert(arr.begin(), N_copy % <span class="number">10</span>);</span><br><span class="line">            N_copy = N_copy / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = arr.size();</span><br><span class="line">        <span class="comment">// count the number with digits &lt; N</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            res += <span class="number">9</span> * helper(<span class="number">9</span> , i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout the number with same prefix</span></span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; seen;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>; j &lt; arr[i]; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!seen.count(j)) &#123;</span><br><span class="line">                    res += helper(<span class="number">9</span> - i, n - i - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (seen.count(arr[i])) &#123; <span class="comment">//相同前缀中有相同的数字，不符合要求，不用继续计算之后的前缀了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            seen.insert(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> N - res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// helper函数，返回由m个digit，n位数位可以组成的数的个数</span></span><br><span class="line">    <span class="comment">// m--可以用于组合数字的digit个数</span></span><br><span class="line">    <span class="comment">// n--需要组成的位数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">1</span> : m * helper(m - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(log N)<br>空间复杂度: O(log N)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://www.youtube.com/watch?v=Xi-YfchDa5U&amp;feature=youtu.be" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1014] Best Sightseeing Pair</title>
    <url>/Leetcode-1014-Best-Sightseeing-Pair/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an array <code>A</code> of positive integers, <code>A[i]</code> represents the value of the <code>i</code> - th sightseeing spot, and two sightseeing spots <code>i</code> and <code>j</code> have distance <code>j - i</code> between them.</p>
<p>The score of a pair (<code>i &lt; j</code>) of sightseeing spots is (<code>A[i] + A[j] + i - j</code>) : the sum of the values of the sightseeing spots, minus the distance between them.</p>
<p>Return the maximum score of a pair of sightseeing spots.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>[8, 1, 5, 2, 6]</code><br><strong>Output:</strong> <code>11</code><br><strong>Explanation:</strong> <code>i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11</code>.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>2 &lt;= A.length &lt;= 50000</code></li>
<li><code>1 &lt;= A[i] &lt;= 1000</code></li>
</ol>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>遍历数组<code>A</code>，我们用<code>max_score</code>来记录当前最大的分数，用<code>pre_max</code>来记录当前元素之前最高的分数<br>每遍历一个元素<code>a</code>，我们首先更新<code>max_score</code>: <code>max_score = max(max_score, a + pre_max)</code><br>然后更新<code>pre_max</code>: <code>pre_max = max(pre_max, a) - 1</code><br>这里<code>-1</code>是因为每往后一个元素，距离会增加<code>1</code></p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max_score = <span class="number">0</span>, pre_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : A) &#123;</span><br><span class="line">            max_score = max(max_score, a + pre_max);</span><br><span class="line">            pre_max = max(pre_max, a) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码（java）"><a href="#示例代码（java）" class="headerlink" title="示例代码（java）"></a>示例代码（java）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a: A) &#123;</span><br><span class="line">            res = Math.max(res, cur + a);</span><br><span class="line">            cur = Math.max(cur, a) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码（python）"><a href="#示例代码（python）" class="headerlink" title="示例代码（python）"></a>示例代码（python）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxScoreSightseeingPair</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> a <span class="keyword">in</span> A:</span><br><span class="line">            res = max(res, cur + a)</span><br><span class="line">            cur = max(cur, a) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/CoyAaGEhmFY" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>wayfair</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1016] Binary String With Substrings Representing 1 To N</title>
    <url>/Leetcode-1016-Binary-String-With-Substrings-Representing-1-To-N/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary string <code>S</code> (a string consisting only of <code>&#39;0&#39;</code> and <code>&#39;1&#39;</code>s) and a positive integer <code>N</code>, return true if and only if for every integer <code>X</code> from <code>1</code> to <code>N</code>, the binary representation of <code>X</code> is a substring of <code>S</code>.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>S = &quot;0110&quot;, N = 3</code><br><strong>Output:</strong> <code>true</code></p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>S = &quot;0110&quot;, N = 4</code><br><strong>Output:</strong> <code>false</code></p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= S.length &lt;= 1000</code></li>
<li><code>1 &lt;= N &lt;= 10^9</code></li>
</ol>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题最重要的是估计<code>N</code>的上限，超过上限全都是<code>false</code>了。<br>由于题目中给了<code>S.length</code>最大为<code>1000</code>，我们考虑11位二进制数（也就是1024 - 2047）总共有 &gt; 1000个<br>然而长度为1000的字符串，取连续的11位数（即长度为11的子串），总共只能取<code>1000 - 10 = 990</code>种 &lt; 1000 =&gt; 不可能包含所有11位binary，所以N最多也就是11位数，其上限为<code>2^11 = 2048</code><br>一般来说（分析时间复杂度会用到）：<code>2^(k+1) - 2^k &lt;= S.length =&gt; 2^k &lt;= S.length</code>, 上限为<code>2^(k+1)</code>次也就是<code>2 * S.length</code><br>知道了这一上限，我们直接暴力求解即可: 将1 - N每一个转化为二进制，然后在S中寻找看是否能找到。<br>另外有一个优化是：我们只需要算 &gt; N/2的数，因为如果一个数k的二进制是<code>S</code>的子串，那么<code>k/2</code>只不过少了一位，一定也是<code>S</code>的子串，没有必要再算。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">intToBinary</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> binary = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span> (N) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N &amp; <span class="number">1</span>) &#123;</span><br><span class="line">                binary = <span class="string">"1"</span> + binary;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                binary = <span class="string">"0"</span> + binary;</span><br><span class="line">            &#125;</span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> binary;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">queryString</span><span class="params">(<span class="built_in">string</span> S, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &gt;= <span class="number">2048</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt; N / <span class="number">2</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.find(intToBinary(i)) == <span class="built_in">string</span>::npos) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码（java）"><a href="#示例代码（java）" class="headerlink" title="示例代码（java）"></a>示例代码（java）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">queryString</span><span class="params">(String S, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N; i &gt; N / <span class="number">2</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> (!S.contains(Integer.toBinaryString(i)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码（python）"><a href="#示例代码（python）" class="headerlink" title="示例代码（python）"></a>示例代码（python）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">queryString</span><span class="params">(self, S, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> all(bin(i)[<span class="number">2</span>:] <span class="keyword">in</span> S <span class="keyword">for</span> i <span class="keyword">in</span> xrange(N, N / <span class="number">2</span>, <span class="number">-1</span>))</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(S.length^2)</code> 平方是因为每一次在<code>S</code>中查找子串需要<code>O(S.length)</code>的时间，而<code>N</code>最大就是<code>2 * S.length</code><br>空间复杂度: <code>O(log(S.length))</code> 因为转化成字符串需要空间，<code>N</code>最大是<code>2 * S.length</code>, 对应二进制的长度就是<code>O(log(S.length))</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/bYoc35QYUhI" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1018] Binary Prefix Divisible By 5</title>
    <url>/Leetcode-1018-Binary-Prefix-Divisible-By-5/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an array <code>A</code> of <code>0</code>s and <code>1</code>s, consider <code>N_i</code>: the <code>i-th</code> subarray from <code>A[0]</code> to <code>A[i]</code> interpreted as a binary number (from most-significant-bit to least-significant-bit.)</p>
<p>Return a list of booleans <code>answer</code>, where <code>answer[i]</code> is true if and only if <code>N_i</code> is divisible by <code>5</code>.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>[0,1,1]</code><br><strong>Output:</strong> <code>[true,false,false]</code><br><strong>Explanation:</strong> The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.  Only the first number is divisible by 5, so answer[0] is true.</p>
</blockquote><br><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>[1,1,1]</code><br><strong>Output:</strong> [false, false, false]</p>
</blockquote><br><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> <code>[0,1,1,1,1,1]</code><br><strong>Output:</strong> <code>[true,false,false,false,true,false]</code></p>
</blockquote><br><strong>Example 4:</strong><br><blockquote><p><strong>Input:</strong> <code>[1,1,1,0,1]</code><br><strong>Output:</strong> <code>[false,false,false,false,false]</code></p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>A[i] is 0 or 1</code></li>
</ol>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求检查从<code>A[0]</code> 到 <code>A[i]</code> <code>(0 &lt;= i &lt; A.size())</code>的字符串，对应的二进制数是否能被5整除。</p>
<p>我们按顺序依次检查二进制对应的数是否能被5整除。</p>
<p>这里有一个小技巧：两个数的和对5的余数，等于它们各自对5的余数的和对5的余数。运用这个事实，我们可以防止整数溢出。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">prefixesDivBy5</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; ans;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : A) &#123;</span><br><span class="line">            tmp = (tmp * <span class="number">2</span> + a) % <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="number">0</span>) &#123;</span><br><span class="line">                ans.push_back(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ans.push_back(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(N)<br>空间复杂度: O(N)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/-sPywZWtmK4" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 102] Binary Tree Level Order Traversal</title>
    <url>/Leetcode-102-Binary-Tree-Level-Order-Traversal/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary tree, return the <em>level order</em> of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:</p>
<p>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>
<pre><code>  3   
 / \
9  20
   / \
  15  7
</code></pre><p>return its level order traversal as:</p>
<pre><code>[
 [3],
 [9,20],
 [15,7]
]
</code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题要求层序遍历一个二叉树，与普通的广度遍历（<code>Breadth First Search</code>）稍有不同的是，需要按层分开。所以我们需要判断当前层的遍历是否结束。我们使用队<code>queue</code>来实现遍历，具体思路为：</p>
<ol>
<li>建立一个队<code>q</code>,并将当前节点<code>cur</code>存入队中：</li>
<li>当前层的长度由变量<code>count</code>记录 </li>
<li>如果队<code>q</code>非空：<ul>
<li>2.1 建立一个空列<code>tmplevel</code>存放下一层的节点</li>
<li>2.2 如果<code>count</code>非零：<ul>
<li>当前节点<code>cur</code>更新为退队节点</li>
<li>将当前节点<code>cur</code>的值存入列<code>tmplevel</code>中</li>
<li>count减1</li>
<li>如果当前节点<code>cur</code>的左子节点非空，存入队<code>q</code></li>
<li>如果当前节点<code>cur</code>的右子节点非空，存入队<code>q</code></li>
<li>回到步骤2.2</li>
</ul>
</li>
<li>2.3 将列<code>tmplevel</code>存入答案列<code>ans</code></li>
<li>2.4 更新count为当前队列<code>q</code>长度</li>
</ul>
</li>
<li>返回<code>ans</code></li>
</ol>
<p>算法过程中，我们用变量<code>count</code>追踪当前层剩余的未访问节点的个数，从而判断何时按层分开。思路还是比较简单的。</p>
<h4 id="示例代码-（python版）"><a href="#示例代码-（python版）" class="headerlink" title="示例代码 （python版）"></a>示例代码 （python版）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        cur = root</span><br><span class="line">        q = collections.deque([cur])</span><br><span class="line">        count = len(q)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmplevel = []</span><br><span class="line">            <span class="keyword">while</span> count:</span><br><span class="line">                cur = q.popleft()</span><br><span class="line">                tmplevel.append(cur.val)</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> cur.left:</span><br><span class="line">                    q.append(cur.left)</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    q.append(cur.right)</span><br><span class="line">            ans.append(tmplevel)</span><br><span class="line">            count = len(q)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>每个节点被访问一次，因此时间复杂度为<code>O(n)</code>。另一方面，队的最大长度为其中最宽的层的节点数，因此空间复杂度仍然为<code>O(n)</code>.</p>
<ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>空间复杂度： <code>O(n)</code></li>
</ul>
<h4 id="总结归纳："><a href="#总结归纳：" class="headerlink" title="总结归纳："></a>总结归纳：</h4><p>层序遍历<code>level order</code>也是树遍历的一种方法，结合我们之前讨论过的前序<code>preorder</code>、中序<code>inorder</code>、后序<code>postorder</code>遍历，希望大家能体会它们实现过程中的区别。</p>
<p>层序遍历使用队列<code>queue</code>这一数据结构实现，这点和前序<code>preorder</code>、中序<code>inorder</code>、后序<code>postorder</code>遍历是不同的。同时，层序遍历的空间复杂度大于另外三种深度遍历的复杂度，这点也值得我们注意。</p>
<p>相关的练习还有：</p>
<p><a href="/Leetcode-144-Binary-Tree-Preorder-Traversal">[LeetCode 144] Binary Tree Preorder Traversal 二叉树前序遍历</a></p>
<p><a href="/Leetcode-94-Binary-Tree-Inorder-Traversal">[LeetCode 94] Binary Tree Inorder Traversal 二叉树中序遍历</a></p>
<p><a href="/leetcode-145-Binary-Tree-Postorder-Traversal">[LeetCode 145] Binary Tree Postorder Traversal 二叉树后序遍历</a></p>
<p>好了，今天就和大家讨论到这里，种香蕉树去了</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1020] Number of Enclaves</title>
    <url>/Leetcode-1020-Number-of-Enclaves/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a 2D array <code>A</code>, each cell is <code>0</code> (representing sea) or <code>1</code> (representing land)</p>
<p>A move consists of walking from one land square <code>4</code>-directionally to another land square, or off the boundary of the grid.</p>
<p>Return the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves.</p>
<p>Return the largest possible sum of the array after modifying it in this way.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]</code><br><strong>Output:</strong> <code>3</code><br><strong>Explanation:</strong> There are three 1s that are enclosed by 0s, and one 1 that isn’t enclosed because its on the boundary.</p>
</blockquote><br><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]</code><br><strong>Output:</strong> <code>0</code><br><strong>Explanation:</strong> All 1s are either on the boundary or can reach the boundary.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 500</code></li>
<li><code>1 &lt;= A[i].length &lt;= 500</code></li>
<li><code>0 &lt;= A[i][j] &lt;= 1</code></li>
<li>All rows have the same size.</li>
</ol>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目给出一个二维数组A，0表示sea，1表示land。要求求出不能连接到边界的land的数量。</p>
<p>题目很明显可以使用DFS的方法来求解。重点在于如果选择DFS。若是对每一个land进行DFS的方法来检查，会造成大量的重复计算。更好的方法是检查一个边界上的每一个land，以此为start point，通过DFS记录下它能达到的所有的land。这样就能保证所有能达到边界的land都会被visit到。同时，这样的方法能保证每个点至多只被check一次，保证了效率，时间复杂度为O(row * col)。</p>
<p>最后返回所有没被visit过并且cell是 1(land)的个数。</p>
<h5 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h5><p>这里我们用一个二维数组visitMap来记录某个点是否被visit过，这样开辟了O(row * col)的空间。如果允许改变A中的值，可以直接将visit过的land的点变成2。这样能避免额外空间的使用。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs= &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = A.size();</span><br><span class="line">        <span class="keyword">int</span> col = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">visitMap</span><span class="params">(row, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(col, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; row; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; col; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span> || r == row - <span class="number">1</span> || c == <span class="number">0</span> || c == col <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (A[r][c] &amp;&amp; !visitMap[r][c]) &#123;</span><br><span class="line">                        checkFunc(A, visitMap, r, c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; row; r++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; col; c++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visitMap[r][c] &amp;&amp; A[r][c]) &#123;</span><br><span class="line">                    ans++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkFunc</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visitMap, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        visitMap[r][c] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> new_r = r + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> new_c = c + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (new_r &gt;= <span class="number">0</span> &amp;&amp; new_r &lt; A.size() &amp;&amp; new_c &gt;= <span class="number">0</span> &amp;&amp; new_c &lt; A[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[new_r][new_c] &amp;&amp; !visitMap[new_r][new_c]) &#123;</span><br><span class="line">                    checkFunc(A, visitMap, new_r, new_c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(row*col)<br>空间复杂度: O(row*col)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/lYpfeWBzzJA" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1021] Remove Outermost Parentheses</title>
    <url>/Leetcode-1021-Remove-Outermost-Parentheses/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>A valid parentheses string is either empty <code>(&quot;&quot;)</code>, <code>&quot;(&quot; + A + &quot;)&quot;</code>, or <code>A + B</code>, where <code>A</code> and <code>B</code> are valid parentheses strings, and + represents string concatenation.  For example, <code>&quot;&quot;</code>, <code>&quot;()&quot;</code>, <code>&quot;(())()&quot;</code>, and <code>&quot;(()(()))&quot;</code> are all valid parentheses strings.</p>
<p>A valid parentheses string <code>S</code> is primitive if it is nonempty, and there does not exist a way to split it into <code>S = A+B</code>, with A and B nonempty valid parentheses strings.</p>
<p>Given a valid parentheses string <code>S</code>, consider its primitive decomposition: <code>S = P_1 + P_2 + ... + P_k</code>, where <code>P_i</code> are primitive valid parentheses strings.</p>
<p>Return <code>S</code> after removing the outermost parentheses of every primitive string in the primitive decomposition of <code>S</code>.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>&quot;(()())(())&quot;</code><br><strong>Output:</strong> <code>&quot;()()()&quot;</code><br><strong>Explanation:</strong><br>The input string is <code>&quot;(()())(())&quot;</code>, with primitive decomposition <code>&quot;(()())&quot; + &quot;(())&quot;</code>.<br>After removing outer parentheses of each part, this is <code>&quot;()()&quot; + &quot;()&quot; = &quot;()()()&quot;</code>.</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>&quot;(()())(())(()(()))&quot;</code><br><strong>Output:</strong> <code>&quot;()()()()(())&quot;</code><br><strong>Explanation:</strong><br>The input string is <code>&quot;(()())(())(()(()))&quot;</code>, with primitive decomposition <code>&quot;(()())&quot; + &quot;(())&quot; + &quot;(()(()))&quot;</code>.<br>After removing outer parentheses of each part, this is <code>&quot;()()&quot; + &quot;()&quot; + &quot;()(())&quot; = &quot;()()()()(())&quot;</code>.</p>
</blockquote></p>
<p><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> <code>&quot;()()&quot;</code><br><strong>Output:</strong> <code>&quot;&quot;</code><br><strong>Explanation:</strong><br>The input string is <code>&quot;()()&quot;</code>, with primitive decomposition <code>&quot;()&quot; + &quot;()&quot;</code>.<br>After removing outer parentheses of each part, this is <code>&quot;&quot; + &quot;&quot; = &quot;&quot;</code>.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>S.length &lt;= 10000</code></li>
<li><code>S[i]</code> is <code>&quot;(&quot;</code> or <code>&quot;)&quot;</code></li>
<li><code>S</code> is a valid parentheses string<a id="more"></a>
</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>用一个整型变量<code>opened</code>来记录左括号比右括号多出的数量<br>遍历S，遇到左括号<code>++opened</code>，遇到右括号<code>--opened</code><br>除非遇到第一个左括号（<code>opened = 1</code>）或者最后一个右括号（<code>opened = 0</code>）<br>不然其余字符均加入最终结果<code>res</code></p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeOuterParentheses</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> opened = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ch : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">'('</span>) &#123;</span><br><span class="line">                ++opened;</span><br><span class="line">                <span class="keyword">if</span> (opened != <span class="number">1</span>) &#123;</span><br><span class="line">                    res += ch;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --opened;</span><br><span class="line">                <span class="keyword">if</span> (opened != <span class="number">0</span>) &#123;</span><br><span class="line">                    res += ch;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码（java）"><a href="#示例代码（java）" class="headerlink" title="示例代码（java）"></a>示例代码（java）</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeOuterParentheses</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> opened = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : S.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'('</span> &amp;&amp; opened++ &gt; <span class="number">0</span>) s.append(c);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">')'</span> &amp;&amp; opened-- &gt; <span class="number">1</span>) s.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码（python）"><a href="#示例代码（python）" class="headerlink" title="示例代码（python）"></a>示例代码（python）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeOuterParentheses</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        res, opened = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">'('</span> <span class="keyword">and</span> opened &gt; <span class="number">0</span>: res.append(c)</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">')'</span> <span class="keyword">and</span> opened &gt; <span class="number">1</span>: res.append(c)</span><br><span class="line">            opened += <span class="number">1</span> <span class="keyword">if</span> c == <span class="string">'('</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(res)</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N)</code><br>空间复杂度: <code>O(N)</code> 如果包含返回的<code>string</code>，不然为<code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/e1yJ40MdF50" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1022] Sum of Root To Leaf Binary Numbers</title>
    <url>/Leetcode-1022-Sum-of-Root-To-Leaf-Binary-Numbers/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary tree, each node has value <code>0</code> or <code>1</code>.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is <code>0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1</code>, then this could represent <code>01101</code> in binary, which is <code>13</code>.</p>
<p>For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</p>
<p>Return the sum of these numbers.</p>
<p><strong>Example 1:</strong><br><img src="/Leetcode-1022-Sum-of-Root-To-Leaf-Binary-Numbers/lc1022.png" width="400"><br><blockquote><p><strong>Input:</strong> <code>[1,0,1,0,1,0,1]</code><br><strong>Output:</strong> <code>22</code><br><strong>Explanation:</strong> (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li>The number of nodes in the tree is between <code>1</code> and <code>1000</code>.</li>
<li>node.val is <code>0</code> or <code>1</code>.</li>
<li>The answer will not exceed <code>2^31 - 1</code>.</li>
</ol>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这题比较简单，通过dfs先序遍历二叉树，分别计算每一条从root到leaf的二进制数，累加即可。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRootToLeaf</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        helperFunc(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helperFunc</span><span class="params">(TreeNode* Node, <span class="keyword">int</span>&amp; ans, <span class="keyword">int</span> tmpSum = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        tmpSum = tmpSum * <span class="number">2</span> + Node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (Node-&gt;right) &#123;</span><br><span class="line">            helperFunc(Node-&gt;right, ans, tmpSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Node-&gt;left) &#123;</span><br><span class="line">            helperFunc(Node-&gt;left, ans, tmpSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!Node-&gt;right &amp;&amp; !Node-&gt;left) &#123;</span><br><span class="line">            ans += tmpSum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(n)<br>空间复杂度: O(1)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/bnvE2hfjbdo" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1023] Camelcase Matching</title>
    <url>/Leetcode-1023-Camelcase-Matching/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>A query word matches a given <code>pattern</code> if we can insert lowercase letters to the pattern word so that it equals the <code>query</code>. (We may insert each character at any position, and may insert 0 characters.)</p>
<p>Given a list of <code>queries</code>, and a <code>pattern</code>, return an <code>answer</code> list of booleans, where <code>answer[i]</code> is true if and only if <code>queries[i]</code> matches the pattern.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FB&quot;</code><br><strong>Output:</strong> <code>[true,false,true,true,false]</code><br><strong>Explanation:</strong><br><code>&quot;FooBar&quot;</code> can be generated like this <code>&quot;F&quot; + &quot;oo&quot; + &quot;B&quot; + &quot;ar&quot;</code>.<br><code>&quot;FootBall&quot;</code> can be generated like this <code>&quot;F&quot; + &quot;oot&quot; + &quot;B&quot; + &quot;all&quot;</code>.<br><code>&quot;FrameBuffer&quot;</code> can be generated like this <code>&quot;F&quot; + &quot;rame&quot; + &quot;B&quot; + &quot;uffer&quot;</code>.</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBa&quot;</code><br><strong>Output:</strong> <code>[true,false,true,false,false]</code><br><strong>Explanation:</strong><br><code>&quot;FooBar&quot;</code> can be generated like this <code>&quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot;</code>.<br><code>&quot;FootBall&quot;</code> can be generated like this <code>&quot;Fo&quot; + &quot;ot&quot; + &quot;Ba&quot; + &quot;ll&quot;</code>.</p>
</blockquote></p>
<p><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> <code>queries = [&quot;FooBar&quot;,&quot;FooBarTest&quot;,&quot;FootBall&quot;,&quot;FrameBuffer&quot;,&quot;ForceFeedBack&quot;], pattern = &quot;FoBaT&quot;</code><br><strong>Output:</strong> <code>[false,true,false,false,false]</code><br><strong>Explanation:</strong><br><code>&quot;FooBarTest&quot;</code> can be generated like this <code>&quot;Fo&quot; + &quot;o&quot; + &quot;Ba&quot; + &quot;r&quot; + &quot;T&quot; + &quot;est&quot;</code>.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= queries.length &lt;= 100</code></li>
<li><code>1 &lt;= queries[i].length &lt;= 100</code></li>
<li><code>1 &lt;= pattern.length &lt;= 100</code><br>All strings consists only of lower and upper case English letters.</li>
</ol>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>判断每一条<code>query</code>与<code>pattern</code>是否match：<br>用<code>i</code>和<code>j</code>两个<code>index</code>分别指向<code>query</code>和<code>pattern</code>，遍历<code>query</code><br> 1）当<code>query[i] == pattern[j]</code>时，<code>++j</code><br> 2）如果不等且<code>query[i]</code>为大写字母，<code>return false</code><br>遍历<code>query</code>结束后，判断<code>j</code>是否走到<code>pattern</code>末尾</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; query, <span class="keyword">const</span> <span class="built_in">string</span>&amp; pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; query.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; pattern.size() &amp;&amp; query[i] == pattern[j]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (query[i] &lt; <span class="string">'a'</span> || query[i] &gt; <span class="string">'z'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == pattern.size();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">camelMatch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; queries, <span class="built_in">string</span> pattern)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; query : queries) &#123;</span><br><span class="line">            res.push_back(isMatch(query, pattern));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Boolean&gt; <span class="title">camelMatch</span><span class="params">(String[] queries, String pattern)</span> </span>&#123;</span><br><span class="line">        List&lt;Boolean&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String query : queries)</span><br><span class="line">            res.add(isMatch(query, pattern));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String query, String pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: query.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; pattern.length() &amp;&amp; c == pattern.charAt(i))</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &lt; <span class="string">'a'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == pattern.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">camelMatch</span><span class="params">(self, queries, pattern)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type queries: List[str]</span></span><br><span class="line"><span class="string">        :type pattern: str</span></span><br><span class="line"><span class="string">        :rtype: List[bool]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">u</span><span class="params">(s)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> s <span class="keyword">if</span> c.isupper()]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">issup</span><span class="params">(s, t)</span>:</span></span><br><span class="line">            it = iter(t)</span><br><span class="line">            <span class="keyword">return</span> all(c <span class="keyword">in</span> it <span class="keyword">for</span> c <span class="keyword">in</span> s)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [u(pattern) == u(query) <span class="keyword">and</span> issup(pattern, query) <span class="keyword">for</span> query <span class="keyword">in</span> queries]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(m * n)</code>, <code>n</code> is the size of <code>queries</code>, <code>m</code> is the length of each query<br>空间复杂度: <code>O(n)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/keHhIMAauP8" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>String</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1024] Video Stitching</title>
    <url>/Leetcode-1024-Video-Stitching/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>You are given a series of video clips from a sporting event that lasted <code>T</code> seconds.  These video clips can be overlapping with each other and have varied lengths.</p>
<p>Each video clip <code>clips[i]</code> is an interval: it starts at time <code>clips[i][0]</code> and ends at time <code>clips[i][1]</code>.  We can cut these clips into segments freely: for example, a clip <code>[0, 7]</code> can be cut into segments <code>[0, 1] + [1, 3] + [3, 7]</code>.</p>
<p>Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event (<code>[0, T]</code>).  If the task is impossible, return <code>-1</code>.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10</code><br><strong>Output:</strong> <code>3</code><br><strong>Explanation:</strong><br>We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.<br>Then, we can reconstruct the sporting event as follows:<br>We cut [1,9] into segments [1,2] + [2,8] + [8,9].<br>Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].</p>
</blockquote><br><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>clips = [[0,1],[1,2]], T = 5</code><br><strong>Output:</strong> <code>-1</code><br><strong>Explanation:</strong><br>We can’t cover [0,5] with only [0,1] and [0,2].</p>
</blockquote><br><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> <code>clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9</code><br><strong>Output:</strong> <code>3</code><br><strong>Explanation:</strong><br>We can take clips [0,4], [4,7], and [6,9].</p>
</blockquote><br><strong>Example 4:</strong><br><blockquote><p><strong>Input:</strong> <code>clips = [[0,4],[2,8]], T = 5</code><br><strong>Output:</strong> <code>2</code><br><strong>Explanation:</strong><br>Notice you can have extra video after the event ends.</p>
</blockquote></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先对<code>clips</code>按起始段位置从小到大排序。然后我们用贪心算法，用<code>cur_end</code>记录当前实际位置的最远端，<code>potential_end</code>记录目前可能的最远端。分别初始化为<code>-1</code>和<code>0</code>。</p>
<p>对clips进行遍历：</p>
<ol>
<li>当<code>potential_end</code>大于T或者<code>clip</code>的起始位置大于<code>potential_end</code>，意味着之后所有的<code>clip</code>都不需要再做考虑了，要么已经满足题意，要么就会出现不能覆盖的区间。</li>
<li>否则，当<code>clip</code>的起始位置大于<code>cur_end</code>，意味着为了覆盖所有区间，必须更新<code>cur_end</code> 和 <code>potential_end</code>，同时有一个<code>clip</code>需要加入<code>res</code>中。</li>
</ol>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">clipCmp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; clipA, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; clipB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clipA[<span class="number">0</span>] == clipB[<span class="number">0</span>] ? clipA[<span class="number">1</span>] &lt;= clipB[<span class="number">1</span>] : clipA[<span class="number">0</span>] &lt; clipB[<span class="number">0</span>]; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">        sort(clips.begin(), clips.end(), clipCmp);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_end = <span class="number">-1</span>; <span class="comment">// 当前实际的最远端</span></span><br><span class="line">        <span class="keyword">int</span> potential_end = <span class="number">0</span>; <span class="comment">// 当前可能的最远端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> clip : clips) &#123;</span><br><span class="line">            <span class="keyword">if</span> (potential_end &gt;= T || clip[<span class="number">0</span>] &gt; potential_end) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (clip[<span class="number">0</span>] &gt; cur_end) &#123; <span class="comment">//当前的这个clip不可能被选取，需要更新cur_end，并让res++</span></span><br><span class="line">                res++;</span><br><span class="line">                cur_end = potential_end;</span><br><span class="line">            &#125;</span><br><span class="line">            potential_end = max(potential_end, clip[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> potential_end &gt;= T ? res : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(n*log n)<br>空间复杂度: O(1)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/tEx3z4L7F-c" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1025] Divisor Game</title>
    <url>/Leetcode-1025-Divisor-Game/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Alice and Bob take turns playing a game, with Alice starting first.</p>
<p>Initially, there is a number N on the chalkboard.  On each player’s turn, that player makes a move consisting of:</p>
<p>Choosing any <code>x</code> with <code>0 &lt; x &lt; N</code> and <code>N % x == 0</code>.<br>Replacing the number <code>N</code> on the chalkboard with <code>N - x</code>.<br>Also, if a player cannot make a move, they lose the game.</p>
<p>Return True if and only if Alice wins the game, assuming both players play optimally.</p>
<blockquote><p><strong>Example 1:</strong><br><strong>Input:</strong> <code>2</code><br><strong>Output:</strong> <code>true</code><br><strong>Explanation:</strong> Alice chooses 1, and Bob has no more moves.</p>
</blockquote>
<blockquote><p><strong>Example 2:</strong><br><strong>Input:</strong> <code>3</code><br><strong>Output:</strong> <code>false</code><br><strong>Explanation:</strong> Alice chooses 1, Bob chooses 1, and Alice has no more moves.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code><a id="more"></a>
</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果<code>N</code>为偶数，则坚持选择<code>x = 1</code>，对方得到<code>N - 1</code>为大于<code>0</code>的奇数<br>如果<code>N</code>为奇数：</p>
<ol>
<li>如果<code>N &gt; 1</code>, 其因子必然也是奇数，所以无论选择任何<code>x</code>，<code>N - x</code>都将变为偶数<br>由于<code>x &lt; N</code>，给予对方的<code>N - x</code>必然是 <code>&gt; 0</code>的偶数</li>
<li>如果<code>N = 1</code>，直接失败。<br>综上，<code>N</code>为偶数时必然大于<code>0</code>，只需要坚持选择<code>x = 1</code>，最终对方会得到<code>N = 1</code>而失败。<br>所以<code>N</code>为偶数时返回<code>true</code>。</li>
</ol>
<blockquote><p>用Flip Game II的方法也可以。</p>
</blockquote>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divisorGame</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(1)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/p5CeIwHRVxQ" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Visa</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1026] Maximum Difference Between Node and Ancestor</title>
    <url>/Leetcode-1026-Maximum-Difference-Between-Node-and-Ancestor/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given the root of a binary tree, find the maximum value <code>V</code> for which there exists different nodes <code>A</code> and <code>B</code> where <code>V = |A.val - B.val|</code> and <code>A</code> is an ancestor of <code>B</code>.</p>
<p>(A node <code>A</code> is an ancestor of <code>B</code> if either: any child of <code>A</code> is equal to <code>B</code>, or any child of <code>A</code> is an ancestor of <code>B</code>.)</p>
<p><strong>Example 1:</strong><br><img src="/Leetcode-1026-Maximum-Difference-Between-Node-and-Ancestor/lc1026.png" width="400"><br><blockquote><p><strong>Input:</strong> <code>[8,3,10,1,6,null,14,null,null,4,7,13]</code><br><strong>Output:</strong> <code>7</code><br><strong>Explanation:</strong><br>We have various ancestor-node differences, some of which are given below :<br>|8 - 3| = 5<br>|3 - 7| = 4<br>|8 - 1| = 7<br>|10 - 13| = 3<br>Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li>The number of nodes in the tree is between <code>2</code> and <code>5000</code>.</li>
<li>Each node will have value between <code>0</code> and <code>100000</code>.</li>
</ol>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题有两种解法，自下而上记录下子树的最大与最小值，或者自上而下记录下子树的最大与最小值。需要注意的事，自下而上的方法需要后序遍历二叉树，自上而下则需要前序遍历二叉树。</p>
<p>这里我们采用自上而下的方法前序遍历二叉树。每次更新从根节点到当前节点的路径中，最大值与最小值的差的绝对值。因为是在一条路径中，所以其中一个节点一定是另外一个节点的祖先。又因为是前序遍历二叉树，时间复杂度就是<code>O(n)</code>。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAncestorDiff</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> maxAncestorDiffHelper(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAncestorDiffHelper</span><span class="params">(TreeNode* root, <span class="keyword">int</span> imax = INT_MIN, <span class="keyword">int</span> imin = INT_MAX)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">        <span class="comment">//root</span></span><br><span class="line">        imax = max(imax, root -&gt; val);</span><br><span class="line">        imin = min(imin, root -&gt; val);</span><br><span class="line">        v_max = max(v_max, <span class="built_in">abs</span>(imax - imin));</span><br><span class="line">        maxAncestorDiffHelper(root -&gt; left, imax, imin);<span class="comment">//go to left child</span></span><br><span class="line">        maxAncestorDiffHelper(root -&gt; right, imax, imin);<span class="comment">//go to right child</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> v_max;  </span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> v_max = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.v_max = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAncestorDiff</span><span class="params">(self, root, imax = <span class="number">0</span>, imin = <span class="number">5001</span>)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        imax = max(imax, root.val)</span><br><span class="line">        imin = min(imin, root.val)</span><br><span class="line">        self.v_max = max(self.v_max, abs(imax - imin))</span><br><span class="line">        self.maxAncestorDiff(root.left, imax, imin)</span><br><span class="line">        self.maxAncestorDiff(root.right, imax, imin)</span><br><span class="line">        <span class="keyword">return</span> self.v_max</span><br></pre></td></tr></table></figure>
<!-- #### 示例代码 (java)
```java
``` -->
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(n)<br>空间复杂度: O(1)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/WJ67QC7LghU" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1027] Longest Arithmetic Sequence</title>
    <url>/Leetcode-1027-Longest-Arithmetic-Sequence/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an array <code>A</code> of integers, return the length of the longest arithmetic subsequence in <code>A</code>.</p>
<p>Recall that a subsequence of <code>A</code> is a list <code>A[i_1]</code>, <code>A[i_2]</code>, …, <code>A[i_k]</code> with <code>0 &lt;= i_1 &lt; i_2 &lt; ... &lt; i_k &lt;= A.length - 1</code>, and that a sequence <code>B</code> is arithmetic if <code>B[i+1] - B[i]</code> are all the same value (for <code>0 &lt;= i &lt; B.length - 1</code>).</p>
<blockquote><p><strong>Example 1:</strong><br><strong>Input:</strong> <code>[3,6,9,12]</code><br><strong>Output:</strong> <code>4</code><br><strong>Explanation:</strong><br>The whole array is an arithmetic sequence with steps of length = 3.</p>
</blockquote>
<blockquote><p><strong>Example 2:</strong><br><strong>Input:</strong> <code>[9,4,7,2,10]</code><br><strong>Output:</strong> <code>3</code><br><strong>Explanation:</strong><br>The longest arithmetic subsequence is <code>[4,7,10]</code>.</p>
</blockquote>
<blockquote><p><strong>Example 3:</strong><br><strong>Input:</strong> <code>[20,1,15,3,10,5,8]</code><br><strong>Output:</strong> <code>4</code><br><strong>Explanation:</strong><br>The longest arithmetic subsequence is <code>[20,15,10,5]</code>.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li><code>2 &lt;= A.length &lt;= 2000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
</ol>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>动态规划，<code>dp[diff][idx]</code>表示等差为<code>diff</code>，以系数<code>idx</code>结尾的最长子序列长度。<br><code>dp[diff][idx]</code>最初都为<code>0</code>，但凡遍历到的最小则为<code>2</code>。<br>双重循环，外循环系数<code>i</code>，内循环系数<code>j</code>，每一次我们让<code>j</code>从<code>0</code>走到<code>i-1</code>，通过<code>A[j]</code>与<code>A[i]</code>组成等差数列(<code>diff = A[i] - A[j]</code>)，更新<code>dp[diff][i]</code>的值为：<code>max(dp[diff][j] + 1, dp[diff][i])</code>，同时更新返回值<code>res = max(res, dp[diff][i])</code><br>最后返回<code>res</code>即可。<br><strong>Testcase 示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3, 6, 9, 12]</span><br><span class="line">i = 1, j = 0: dp[3][1] = 2, dp[3][1] = max(dp[3][0] + 1, dp[3][1]) = 2</span><br><span class="line">i = 2, j = 0: dp[6][2] = 2, ...</span><br><span class="line">i = 2, j = 1: dp[3][2] = 2, dp[3][2] = max(dp[3][1] + 1, dp[3][2]) = 3</span><br><span class="line">i = 3, j = 0: dp[9][3] = 2, ...</span><br><span class="line">i = 3, j = 1: dp[6][3] = 2, ...</span><br><span class="line">i = 3, j = 2: dp[3][3] = 2, dp[3][3] = max(dp[3][2] + 1, dp[3][3]) = 4</span><br></pre></td></tr></table></figure></p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">        <span class="keyword">if</span> (A.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> diff = A[i] - A[j];</span><br><span class="line">                <span class="keyword">if</span> (!dp[diff].count(i)) &#123;</span><br><span class="line">                    dp[diff][i] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[diff][i] = max(dp[diff][j] + <span class="number">1</span>, dp[diff][i]);</span><br><span class="line">                res = max(res, dp[diff][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestArithSeqLength</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; dp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; A.length; j++) &#123;</span><br><span class="line">                Map&lt;Integer, Integer&gt; m = dp.computeIfAbsent(A[j] - A[i], d -&gt; <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">                m.put(j, m.getOrDefault(i, <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">                res = Math.max(res, m.get(j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestArithSeqLength</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(len(A)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i + <span class="number">1</span>, len(A)):</span><br><span class="line">                dp[j, A[j] - A[i]] = dp.get((i, A[j] - A[i]), <span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(dp.values())</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N^2)</code><br>空间复杂度: <code>O(N^2)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/mSplC7Q-Rm8" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Google</tag>
        <tag>Dynamic Programming</tag>
        <tag>snapdeal</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1028] Recover a Tree From Preorder Traversal</title>
    <url>/Leetcode-1028-Recover-a-Tree-From-Preorder-Traversal/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>We run a preorder depth first search on the root of a binary tree.</p>
<p>At each node in this traversal, we output <code>D</code> dashes (where <code>D</code> is the depth of this node), then we output the value of this node.  (If the depth of a node is <code>D</code>, the depth of its immediate child is <code>D+1</code>.  The depth of the root node is <code>0</code>.)</p>
<p>If a node has only one child, that child is guaranteed to be the left child.</p>
<p>Given the output <code>S</code> of this traversal, recover the tree and return its root.</p>
<p><strong>Example 1:</strong><br><img src="/Leetcode-1028-Recover-a-Tree-From-Preorder-Traversal/lc1028_1.png" width="400"><br><blockquote><p><strong>Input:</strong> <code>&quot;1-2--3--4-5--6--7&quot;</code><br><strong>Output:</strong> <code>[1,2,5,3,4,6,7]</code></p>
</blockquote><br><strong>Example 2:</strong><br><img src="/Leetcode-1028-Recover-a-Tree-From-Preorder-Traversal/lc1028_2.png" width="400"><br><blockquote><p><strong>Input:</strong> <code>&quot;1-2--3---4-5--6---7&quot;</code><br><strong>Output:</strong> <code>[1,2,5,3,null,6,null,4,null,7]</code></p>
</blockquote><br><strong>Example 3:</strong><br><img src="/Leetcode-1028-Recover-a-Tree-From-Preorder-Traversal/lc1028.png" width="400"><br><blockquote><p><strong>Input:</strong> <code>&quot;1-401--349---90--88&quot;</code><br><strong>Output:</strong> <code>[1,401,null,349,88,90]</code></p>
</blockquote></p>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>parse String <code>S</code>, 遍历获取每个<code>node</code>以及它对应的<code>level</code>。类似于用非递归法前序遍历二叉树，我们来重构二叉树。使用<code>stack</code>的数据结构(这里我们用vector代替stack，本质是一样的）。<code>stack</code>的<code>size</code>就是当前遍历到的二叉树的深度。当<code>stack.size() &gt; level</code>时，意味着当前节点为根节点的子树都被遍历过了，需要退栈，直到<code>stack.size == level</code>，插入当前新遍历到的node。</p>
<p>最后返回<code>stack[0]</code>， 即二叉树的根节点。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">recoverFromPreorder</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.size();) &#123;</span><br><span class="line">            <span class="keyword">int</span> level;</span><br><span class="line">            <span class="keyword">int</span> val;</span><br><span class="line">            <span class="keyword">for</span> (level = <span class="number">0</span>; S[i] == <span class="string">'-'</span>; i++) &#123;</span><br><span class="line">                level++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (val = <span class="number">0</span>; S[i] != <span class="string">'-'</span> &amp;&amp; i &lt; S.size(); i++) &#123;</span><br><span class="line">                val = val * <span class="number">10</span> + S[i] - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">stack</span>.size() &gt; level) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">stack</span>.empty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">stack</span>.back()-&gt;left) &#123;</span><br><span class="line">                    <span class="built_in">stack</span>.back()-&gt;right = node;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">stack</span>.back()-&gt;left = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">stack</span>.push_back(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">recoverFromPreorder</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level, val;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length();) &#123;</span><br><span class="line">            <span class="keyword">for</span> (level = <span class="number">0</span>; S.charAt(i) == <span class="string">'-'</span>; i++) &#123;</span><br><span class="line">                level++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (val = <span class="number">0</span>; i &lt; S.length() &amp;&amp; S.charAt(i) != <span class="string">'-'</span>; i++) &#123;</span><br><span class="line">                val = val * <span class="number">10</span> + (S.charAt(i) - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (stack.size() &gt; level) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode node = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">            <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.peek().left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.peek().left = node;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    stack.peek().right = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (stack.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">recoverFromPreorder</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack, i = [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(S):</span><br><span class="line">            level, val = <span class="number">0</span>, <span class="string">""</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; len(S) <span class="keyword">and</span> S[i] == <span class="string">'-'</span>:</span><br><span class="line">                level, i = level + <span class="number">1</span>, i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; len(S) <span class="keyword">and</span> S[i] != <span class="string">'-'</span>:</span><br><span class="line">                val, i = val + S[i], i + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> len(stack) &gt; level:</span><br><span class="line">                stack.pop()</span><br><span class="line">            node = TreeNode(val)</span><br><span class="line">            <span class="keyword">if</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].left <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                stack[<span class="number">-1</span>].left = node</span><br><span class="line">            <span class="keyword">elif</span> stack:</span><br><span class="line">                stack[<span class="number">-1</span>].right = node</span><br><span class="line">            stack.append(node)</span><br><span class="line">        <span class="keyword">return</span> stack[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/oweZKtx9yws" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1029] Two City Scheduling</title>
    <url>/Leetcode-1029-Two-City-Scheduling/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>There are <code>2N</code> people a company is planning to interview. The cost of flying the i-th person to city A is <code>costs[i][0]</code>, and the cost of flying the i-th person to city B is <code>costs[i][1]</code>.</p>
<p>Return the minimum cost to fly every person to a city such that exactly N people arrive in each city.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>[[10,20],[30,200],[400,50],[30,20]]</code><br><strong>Output:</strong> <code>110</code><br><strong>Explanation:</strong><br>The first person goes to city A for a cost of <code>10</code>.<br>The second person goes to city A for a cost of <code>30</code>.<br>The third person goes to city B for a cost of <code>50</code>.<br>The fourth person goes to city B for a cost of <code>20</code>.</p>
<p>The total minimum cost is <code>10 + 30 + 50 + 20 = 110</code> to have half the people interviewing in each city.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= costs.length &lt;= 100</code></li>
<li>It is guaranteed that costs.length is even.</li>
<li><code>1 &lt;= costs[i][0], costs[i][1] &lt;= 1000</code><a id="more"></a>
</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们排序每一个面试者到A地和到B地<code>cost</code>之差，前<code>N</code>个（到A地<code>cost</code>较小的<code>N</code>个）取到A地cost，后<code>N</code>个取到B地cost，这样平均情况时间复杂度是<code>NlogN</code><br>考虑到我们只需要到A地较小的元素在前半部分（较小元素之间的排序无关紧要），而到B地<code>cost</code>较小的元素在后半部分，所以可以考虑使用快速选择算法替代快速排序，将平均复杂度从<code>NlogN</code>减小到<code>N</code></p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">twoCitySchedCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// sort(costs.begin(), costs.end(), [](const vector&lt;int&gt;&amp; c1, const vector&lt;int&gt;&amp; c2) &#123;</span></span><br><span class="line">        <span class="comment">//     return (c1[0] - c1[1]) &lt; (c2[0] - c2[1]);</span></span><br><span class="line">        <span class="comment">//  &#125;);</span></span><br><span class="line">        nth_element(costs.begin(), costs.begin() + costs.size() / <span class="number">2</span> - <span class="number">1</span>, costs.end(), [](<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; c1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> (c1[<span class="number">0</span>] - c1[<span class="number">1</span>]) &lt; (c2[<span class="number">0</span>] - c2[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> res_cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = costs.size() - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            res_cost += costs[i][<span class="number">0</span>] + costs[j][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">twoCitySchedCost</span><span class="params">(<span class="keyword">int</span>[][] costs)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(costs, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (a[<span class="number">1</span>] - a[<span class="number">0</span>]) - (b[<span class="number">1</span>] - b[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; costs.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            cost += costs[i][<span class="number">1</span>] + costs[costs.length-i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoCitySchedCost</span><span class="params">(self, costs: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        costs.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>]-x[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> sum(i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> costs[:len(costs)//<span class="number">2</span>]) + sum(j[<span class="number">1</span>] <span class="keyword">for</span> j <span class="keyword">in</span> costs[len(costs)//<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N)</code> for cpp, <code>O(Nlog(N))</code> for java and python<br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/vTtOqONCWbs" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Bloomberg</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1030] Matrix Cells in Distance Order</title>
    <url>/Leetcode-1030-Matrix-Cells-in-Distance-Order/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>We are given a matrix with <code>R</code> rows and <code>C</code> columns has cells with integer coordinates <code>(r, c)</code>, where <code>0 &lt;= r &lt; R</code> and <code>0 &lt;= c &lt; C</code>.</p>
<p>Additionally, we are given a cell in that matrix with coordinates <code>(r0, c0)</code>.</p>
<p>Return the coordinates of all cells in the matrix, sorted by their distance from <code>(r0, c0)</code> from smallest distance to largest distance.  Here, the distance between two cells <code>(r1, c1)</code> and <code>(r2, c2)</code> is the Manhattan distance, <code>|r1 - r2| + |c1 - c2|</code>.  (You may return the answer in any order that satisfies this condition.)</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>R = 1, C = 2, r0 = 0, c0 = 0</code><br><strong>Output:</strong> <code>[[0,0],[0,1]]</code><br><strong>Explanation:</strong> <code>The distances from (r0, c0) to other cells are: [0,1]</code></p>
</blockquote><br><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>&quot;R = 2, C = 2, r0 = 0, c0 = 1&quot;</code><br><strong>Output:</strong> <code>[[0,1],[0,0],[1,1],[1,0]]</code><br><strong>Explanation:</strong> <code>The distances from (r0, c0) to other cells are: [0,1,1,2]
The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct.</code></p>
</blockquote><br><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> <code>R = 2, C = 3, r0 = 1, c0 = 2</code><br><strong>Output:</strong> <code>[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</code><br><strong>Explanation:</strong>  <code>The distances from (r0, c0) to other cells are: [0,1,1,2,2,3]
There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]].</code> </p>
</blockquote></p>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>按照Manhattan距离的定义，我们需要从小到大所搜所有的坐标，并按离给定点的距离，返回所有的坐标。<br>显然，最小的距离一定是１，而最大的距离不会超过R+C-1。我们那给定点为中心，从里向外依次搜索。这本质上与BFS是一个思想。这里不直接使用BFS的原因，是为了避免使用额外空间记录某个cell是否被visit过。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">allCellsDistOrder</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = &#123;&#123;r0, c0&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> level = <span class="number">1</span>; level &lt; R + C - <span class="number">1</span>; ++level) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = -level; x &lt;= level; ++x) &#123;</span><br><span class="line">                <span class="keyword">int</span> r1 = r0 + x;</span><br><span class="line">                <span class="keyword">int</span> c1_a = c0 + level - <span class="built_in">abs</span>(x);</span><br><span class="line">                <span class="keyword">int</span> c1_b = c0 + <span class="built_in">abs</span>(x) - level;</span><br><span class="line">                <span class="keyword">if</span> (r1 &gt;= <span class="number">0</span> &amp;&amp; r1 &lt; R) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c1_a &gt;= <span class="number">0</span> &amp;&amp; c1_a &lt; C)&#123;</span><br><span class="line">                        res.push_back(&#123;r1, c1_a&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (c1_a != c1_b &amp;&amp; c1_b &gt;= <span class="number">0</span> &amp;&amp; c1_b &lt; C) &#123;</span><br><span class="line">                        res.push_back(&#123;r1, c1_b&#125;);    </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] allCellsDistOrder(<span class="keyword">int</span> R, <span class="keyword">int</span> C, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] origin = <span class="keyword">new</span> <span class="keyword">int</span>[R * C][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; C; j++) &#123;</span><br><span class="line">                origin[i * C + j] = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(origin, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Math.abs(a[<span class="number">0</span>] - r0) + Math.abs(a[<span class="number">1</span>] - c0)</span><br><span class="line">                        - Math.abs(b[<span class="number">0</span>] - r0) - Math.abs(b[<span class="number">1</span>] - c0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">allCellsDistOrder</span><span class="params">(self, R, C, r0, c0)</span>:</span></span><br><span class="line">        ans, dist = [], []</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(R):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span><br><span class="line">                dist += [abs(r - r0) + abs(c - c0)]</span><br><span class="line">                ans += [[r, c]]</span><br><span class="line">        dist, ans = zip(*sorted(zip(dist, ans)))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(RC）<br>空间复杂度: O(1)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/mHOs-Uzq-Fk" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Yahoo</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1031] Maximum Sum of Two Non-Overlapping Subarrays</title>
    <url>/Leetcode-1031-Maximum-Sum-of-Two-Non-Overlapping-Subarrays/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an array <code>A</code> of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths <code>L</code> and <code>M</code>.  (For clarification, the L-length subarray could occur before or after the M-length subarray.)</p>
<p>Formally, return the largest <code>V</code> for which <code>V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1])</code> and either:<br><code>0 &lt;= i &lt; i + L - 1 &lt; j &lt; j + M - 1 &lt; A.length</code>, or<br><code>0 &lt;= j &lt; j + M - 1 &lt; i &lt; i + L - 1 &lt; A.length</code>.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2</code><br><strong>Output:</strong> <code>20</code><br><strong>Explanation:</strong> One choice of subarrays is <code>[9]</code> with length <code>1</code>, and <code>[6,5]</code> with length <code>2</code>.</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2</code><br><strong>Output:</strong> <code>29</code><br><strong>Explanation:</strong> One choice of subarrays is <code>[3,8,1]</code> with length <code>3</code>, and <code>[8,9]</code> with length <code>2</code>.</p>
</blockquote></p>
<p><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> <code>A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3</code><br><strong>Output:</strong> <code>31</code><br><strong>Explanation:</strong> One choice of subarrays is <code>[5,6,0,9]</code> with length <code>4</code>, and <code>[3,8]</code> with length <code>3</code>.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>L &gt;= 1</code></li>
<li><code>M &gt;= 1</code></li>
<li><code>L + M &lt;= A.length &lt;= 1000</code></li>
<li><code>0 &lt;= A[i] &lt;= 1000</code></li>
</ol>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>动态规划<br>凡是要求数组某一段的和，要想到用<code>pre_sum</code>，<code>pre_sum[i]</code>表示指数<code>i</code>之前左右数的和。<br>这样我们要求<code>A[i]</code>到<code>A[j]</code>之间所有数的和，就可以用<code>pre_sum[j] - pre_sum[i - 1]</code><br>回到这道题，我们第一遍遍历数组A求pre_sum。</p>
<p>第二遍遍历，指数为<code>i</code>，用<code>max_L</code>记录指数<code>i - M</code>之前的最大连续<code>L</code>个数之和，<br>每次更新<code>max_L</code>为<code>max(max_L, pre_sum[i - M] - pre_sum[i - L - M])</code><br><code>max_L + pre_sum[i] - pre_sum[i - M]</code>表示以<code>i</code>结尾最后连续<code>M</code>个数，与之前最大的连续<code>L</code>个数的和。<br>同理<code>max_M + pre_sum[i] - pre_sum[i - L]</code>就表示以i结尾最后连续<code>L</code>个数，与之前最大的连续<code>M</code>个数的和。<br>取其中较大的与最终要返回的值<code>res</code>比较，并更新即可。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> L, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.size() &lt; L + M) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre_sum = A;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            pre_sum[i] += pre_sum[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = pre_sum[L + M - <span class="number">1</span>], max_L = pre_sum[L - <span class="number">1</span>], max_M = pre_sum[M - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L + M; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            max_L = max(max_L, pre_sum[i - M] - pre_sum[i - L - M]);</span><br><span class="line">            max_M = max(max_M, pre_sum[i - L] - pre_sum[i - L - M]);</span><br><span class="line">            res = max(res, max(max_L + pre_sum[i] - pre_sum[i - M], max_M + pre_sum[i] - pre_sum[i - L]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> L, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; ++i)</span><br><span class="line">            A[i] += A[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = A[L + M - <span class="number">1</span>], Lmax = A[L - <span class="number">1</span>], Mmax = A[M - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L + M; i &lt; A.length; ++i) &#123;</span><br><span class="line">            Lmax = Math.max(Lmax, A[i - M] - A[i - L - M]);</span><br><span class="line">            Mmax = Math.max(Mmax, A[i - L] - A[i - L - M]);</span><br><span class="line">            res = Math.max(res, Math.max(Lmax + A[i] - A[i - M], Mmax + A[i] - A[i - L]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumTwoNoOverlap</span><span class="params">(self, A, L, M)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :type L: int</span></span><br><span class="line"><span class="string">        :type M: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, len(A)):</span><br><span class="line">            A[i] += A[i - <span class="number">1</span>]</span><br><span class="line">        res, Lmax, Mmax = A[L + M - <span class="number">1</span>], A[L - <span class="number">1</span>], A[M - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(L + M, len(A)):</span><br><span class="line">            Lmax = max(Lmax, A[i - M] - A[i - L - M])</span><br><span class="line">            Mmax = max(Mmax, A[i - L] - A[i - L - M])</span><br><span class="line">            res = max(res, Lmax + A[i] - A[i - M], Mmax + A[i] - A[i - L])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N)</code><br>空间复杂度: <code>O(N)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/XTGEbhZmqCY" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1032] Stream of Characters</title>
    <url>/Leetcode-1032-Stream-of-Characters/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Implement the StreamChecker class as follows:</p>
<p>  <em>StreamChecker(words):</em> Constructor, init the data structure with the given words.<br>  <em>query(letter):</em> returns true if and only if for some k &gt;= 1, the last k characters queried (in order from oldest to newest, including this letter just queried) spell one of the words in the given list.</p>
<p><strong>Example</strong><br><blockquote><p>StreamChecker streamChecker = new StreamChecker([“cd”,”f”,”kl”]); // init the dictionary.<br>streamChecker.query(‘a’);          // return false<br>streamChecker.query(‘b’);          // return false<br>streamChecker.query(‘c’);          // return false<br>streamChecker.query(‘d’);          // return true, because ‘cd’ is in the wordlist<br>streamChecker.query(‘e’);          // return false<br>streamChecker.query(‘f’);          // return true, because ‘f’ is in the wordlist<br>streamChecker.query(‘g’);          // return false<br>streamChecker.query(‘h’);          // return false<br>streamChecker.query(‘i’);          // return false<br>streamChecker.query(‘j’);          // return false<br>streamChecker.query(‘k’);          // return false<br>streamChecker.query(‘l’);          // return true, because ‘kl’ is in the wordlist</p>
</blockquote></p>
<p><strong>Note</strong></p>
<ol>
<li><code>1 &lt;= words.length &lt;= 2000</code></li>
<li><code>1 &lt;= words[i].length &lt;= 2000</code></li>
<li>Words will only consist of lowercase English letters.</li>
<li>Queries will only consist of lowercase English letters.</li>
<li>The number of queries is at most 40000.<a id="more"></a>
</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求输入一个字符串数组作为字典， 然后不断查询字符，如果最近的<code>k</code>个字符构成一个完整的字典单词的话，返回<code>true</code>，否则返回<code>false</code>。</p>
<p>这个题目可以使用字典树(<code>Trie</code>)求解。 对每个字符查询，当返回<code>true</code>时，一定是一个完整的单词。值得注意的技巧是，反向查询可以节省很多开销。因为正向查询的话要保存很多上次访问到的节点，因为开始的地方可能会很多，所以这个<code>Trie</code>可以反过来建， 这样每次查询的时候都可以从最后面开始查询起。</p>
<p>建<code>Trie</code>的过程是对每个单词逆序插入<code>Trie</code>， 从最后一个字符开始到第一个字符插入建立<code>Trie</code>。<br>查询的时候，因为接受的是一个<code>stream</code>，我们需要的<code>stream</code>的长度不应该超过<code>Trie</code>的最大深度。这样保证了我们的空间复杂度不会过大。</p>
<p>每次查询从<code>stream</code>的最后一个字符开始向前查询，查到一个完整的单词就返回<code>true</code>，否则就返回<code>false</code>。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TrieNode*&gt; next;</span><br><span class="line">    TrieNode(): isWord(<span class="literal">false</span>), next(<span class="built_in">vector</span>&lt;TrieNode*&gt;(<span class="number">26</span>, <span class="literal">nullptr</span>)) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">    </span><br><span class="line">    Trie() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span>&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode* cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = word.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = word[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; next[pos] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cur -&gt; next[pos] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur -&gt; next[pos]; </span><br><span class="line">        &#125;</span><br><span class="line">        cur -&gt; isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findWord</span><span class="params">(<span class="built_in">string</span>&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode* cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = word.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = word[i] - <span class="string">'a'</span>;</span><br><span class="line">            cur = cur-&gt;next[pos];</span><br><span class="line">            <span class="keyword">if</span> (cur == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; isWord) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamChecker</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> stream = <span class="string">""</span>;</span><br><span class="line">    Trie trie = Trie();</span><br><span class="line">    <span class="keyword">size_t</span> maxLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StreamChecker(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> word : words) &#123;</span><br><span class="line">            trie.insert(word);</span><br><span class="line">            maxLen = max(maxLen, word.size());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> letter)</span> </span>&#123;</span><br><span class="line">        stream += letter;</span><br><span class="line">        <span class="keyword">if</span> (stream.size() &gt; maxLen) &#123;</span><br><span class="line">            stream.erase(stream.begin());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trie.findWord(stream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StreamChecker object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StreamChecker* obj = new StreamChecker(words);</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;query(letter);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamChecker</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isWord;</span><br><span class="line">        TrieNode[] next = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamChecker</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        createTrie(words);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> letter)</span> </span>&#123;</span><br><span class="line">        sb.append(letter);</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sb.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; node != <span class="keyword">null</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = sb.charAt(i);</span><br><span class="line">            node = node.next[c - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; node.isWord) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTrie</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">            TrieNode node = root;</span><br><span class="line">            <span class="keyword">int</span> len = s.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (node.next[c - <span class="string">'a'</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.next[c - <span class="string">'a'</span>] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.next[c - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            node.isWord = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamChecker</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.n = <span class="number">0</span></span><br><span class="line">        self.root = self.createTrie(words)</span><br><span class="line">        self.window = deque()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createTrie</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        root = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> len(word) &gt; self.n:</span><br><span class="line">                self.n = len(word)</span><br><span class="line">            node = root</span><br><span class="line">            <span class="keyword">for</span> char <span class="keyword">in</span> word[::<span class="number">-1</span>]:</span><br><span class="line">                <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                    node[char] = &#123;&#125;</span><br><span class="line">                node = node[char]</span><br><span class="line">            node[<span class="string">'#'</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self)</span>:</span></span><br><span class="line">        </span><br><span class="line">        word = self.window</span><br><span class="line">        root = self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(word)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'#'</span> <span class="keyword">in</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> word[i] <span class="keyword">in</span> root:</span><br><span class="line">                root = root[word[i]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="string">'#'</span> <span class="keyword">in</span> root <span class="keyword">else</span> <span class="literal">False</span> </span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, letter)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type letter: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.window.append(letter)</span><br><span class="line">        <span class="keyword">if</span> len(self.window) &gt; self.n:</span><br><span class="line">            self.window.popleft()</span><br><span class="line">        <span class="keyword">return</span> self.search()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your StreamChecker object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = StreamChecker(words)</span></span><br><span class="line"><span class="comment"># param_1 = obj.query(letter)</span></span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(d * (# of query))<br>空间复杂度: O(d * (# of dictionary))<br>d是dictionary中最长单词的长度。</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/VaRsfAZwEqI" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1033] Moving Stones Until Consecutive</title>
    <url>/Leetcode-1033-Moving-Stones-Until-Consecutive/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Three stones are on a number line at positions&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">a</code>,&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">b</code>, and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">c</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Each turn, you pick up a stone at an endpoint (ie., either the lowest or highest position stone), and move it to an unoccupied position between those&nbsp;endpoints.&nbsp; Formally, let’s say the stones are currently at positions&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x, y, z</code>&nbsp;with&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x &lt; y &lt; z</code>.&nbsp; You pick up the stone at either position&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x</code>&nbsp;or position&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">z</code>, and move that stone to an integer position&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">k</code>, with&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x &lt; k &lt; z</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">k != y</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">The game ends when you cannot make any more moves, ie. the stones are in consecutive positions.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">When the game ends, what is the minimum and maximum number of moves that you could have made?&nbsp; Return the answer as an length 2 array:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">answer = [minimum_moves, maximum_moves]</code></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>a = <span id="example-input-1-1">1</span>, b = <span id="example-input-1-2">2</span>, c = <span id="example-input-1-3">5</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">[1,2]</span><br><span style="font-weight: bolder;">Explanation: </span>Move the stone from 5 to 3, or move the stone from 5 to 4 to 3.<br></pre><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>a = <span id="example-input-2-1">4</span>, b = <span id="example-input-2-2">3</span>, c = <span id="example-input-2-3">2</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">[0,0]</span><br><span style="font-weight: bolder;">Explanation: </span>We cannot make any moves.<br></pre><div><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>a = <span id="example-input-3-1">3</span>, b = <span id="example-input-3-2">5</span>, c = <span id="example-input-3-3">1</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">[1,2]</span><br><span style="font-weight: bolder;">Explanation: </span>Move the stone from 1 to 4; or move the stone from 1 to 2 to 4.<br></pre><p style="font-size: inherit; margin-bottom: 1em;">&nbsp;</p></div></div><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= a &lt;= 100</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= b &lt;= 100</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= c &lt;= 100</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">a != b, b != c, c != a</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先将<code>a</code>, <code>b</code>, <code>c</code>排序，最多的步数是将两边的石头每次移动一格，因此最多移动<code>c - a - 2</code>格，<code>-2</code>是因为要跳过中间的石头。<br>最少的步数要根据情况判断：<br>1）如果说没有任何两块石头靠在一起（即<code>min(stones[2] - stones[1], stones[1] - stones[0]) &gt; 2</code>）那么要移动两步让三块石头都靠一起<br>2）反之，如果有一边石头已经靠在一起了，那么只需要移动另一边石头一次<br>3）如果两边石头都是靠在一起的（即<code>stones[2] - stones[0] == 2</code>）那么一次都不用移动。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numMovesStones</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stones = &#123;a, b, c&#125;;</span><br><span class="line">        sort(stones.begin(), stones.end());</span><br><span class="line">        <span class="keyword">if</span> (stones[<span class="number">2</span>] - stones[<span class="number">0</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;min(stones[<span class="number">2</span>] - stones[<span class="number">1</span>], stones[<span class="number">1</span>] - stones[<span class="number">0</span>]) &lt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">2</span>, stones[<span class="number">2</span>] - stones[<span class="number">0</span>] - <span class="number">2</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] numMovesStones(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c) &#123;</span><br><span class="line">      <span class="keyword">int</span>[] s = &#123; a, b, c &#125;;</span><br><span class="line">      Arrays.sort(s);</span><br><span class="line">      <span class="keyword">if</span> (s[<span class="number">2</span>] - s[<span class="number">0</span>] == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; Math.min(s[<span class="number">1</span>] - s[<span class="number">0</span>], s[<span class="number">2</span>] - s[<span class="number">1</span>]) &lt;= <span class="number">2</span> ? <span class="number">1</span> : <span class="number">2</span>, s[<span class="number">2</span>] - s[<span class="number">0</span>] - <span class="number">2</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMovesStones</span><span class="params">(self, a: int, b: int, c: int)</span> -&gt; List[int]:</span></span><br><span class="line">        x, y, z = sorted([a, b, c])</span><br><span class="line">        <span class="keyword">if</span> x + <span class="number">1</span> == y == z - <span class="number">1</span>:</span><br><span class="line">            min_steps = <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> y - x &gt; <span class="number">2</span> <span class="keyword">and</span> z - y &gt; <span class="number">2</span>:</span><br><span class="line">            min_steps = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            min_steps = <span class="number">1</span></span><br><span class="line">        max_steps = z - x - <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> [min_steps, max_steps]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(1)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/f1DxytGe2YQ" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Brainteaser</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1034] Coloring A Border</title>
    <url>/Leetcode-1034-Coloring-A-Border/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a 2-dimensional <code>grid</code> of integers, each value in the grid represents the color of the grid square at that location.</p>
<p>Two squares belong to the same connected component if and only if they have the same color and are next to each other in any of the 4 directions.</p>
<p>The <em>border</em> of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).</p>
<p>Given a square at location <code>(r0, c0)</code> in the grid and a <code>color</code>, color the border of the connected component of that square with the given <code>color</code>, and return the final <code>grid</code>.<br><a id="more"></a></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目给我们一个坐标，要求将这个坐标表示的点所属的<code>component</code>的边界用给定的颜色标记出来。</p>
<p>我们用<code>DFS</code>的方法解决这道题。从给定的起点<code>A</code>开始，我们可以方便的遍历<code>A</code>所在的<code>component</code>的所有点。为了不开辟额空间，我们直接将<code>A</code>原来的颜色<code>originColor</code>翻转为<code>-originColor</code>。</p>
<p>那如何在找出边界呢？我们只需要在完成一个点上下左右四个方向的遍历之后，检查这个点是不是在<code>component</code>内部，在的话我们再次翻转<code>-originColor</code>,把它复原为<code>originColor</code>。经过这样的步骤之后，地图上所有标记为<code>-originColor</code>的点就是我们需要的边界了。我们将这些点重新标记为题目要求的<code>color</code>即可。</p>
<p>同学们可以看下图给出的例子有个具体认识（图片引自<em>Discuss</em>中<em>votrubac</em>的发帖）。</p>
<img src="/Leetcode-1034-Coloring-A-Border/lc1034.png" width="800">
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">colorBorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">        dfs(grid, r0, c0, grid[r0][c0]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    grid[i][j] = color;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> originColor)</span> </span>&#123;</span><br><span class="line">        grid[r][c] = -originColor;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> rNew = r + dir[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> cNew = c + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (rNew &gt;= <span class="number">0</span> &amp;&amp; rNew &lt; grid.size() &amp;&amp; cNew &gt;= <span class="number">0</span> &amp;&amp; cNew &lt; grid[<span class="number">0</span>].size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[rNew][cNew] == originColor) &#123;</span><br><span class="line">                    dfs(grid, rNew, cNew, originColor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r &gt; <span class="number">0</span> &amp;&amp; r &lt; grid.size() - <span class="number">1</span> &amp;&amp; c &gt; <span class="number">0</span> &amp;&amp; c &lt; grid[<span class="number">0</span>].size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(grid[r - <span class="number">1</span>][c]) == originColor &amp;&amp;</span><br><span class="line">                <span class="built_in">abs</span>(grid[r + <span class="number">1</span>][c]) == originColor &amp;&amp;</span><br><span class="line">                <span class="built_in">abs</span>(grid[r][c + <span class="number">1</span>]) == originColor &amp;&amp;</span><br><span class="line">                <span class="built_in">abs</span>(grid[r][c - <span class="number">1</span>]) == originColor) &#123;</span><br><span class="line">                grid[r][c] = originColor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] d = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span> &#125;; <span class="comment">// neighbors' relative displacements.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] colorBorder(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r0, <span class="keyword">int</span> c0, <span class="keyword">int</span> color) &#123;</span><br><span class="line">        dfs(grid, r0, c0, grid[r0][c0]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] g : grid) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; g.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i] &lt; <span class="number">0</span>) &#123; g[i] = color; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> clr)</span> </span>&#123;</span><br><span class="line">        grid[r][c] = -clr; <span class="comment">// mark as visited.</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// use to count grid[r][c]'s component neighbors (same color as itself).</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123; <span class="comment">// traverse 4 neighbors.</span></span><br><span class="line">            <span class="keyword">int</span> x = r + d[i], y = c + d[i + <span class="number">1</span>]; <span class="comment">// nieghbor's coordinates.</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= grid.length || y &lt; <span class="number">0</span> || y &gt;= grid[<span class="number">0</span>].length || Math.abs(grid[x][y]) != clr) &#123; <span class="keyword">continue</span>; &#125; <span class="comment">// out of grid or not same component.</span></span><br><span class="line">            ++cnt; <span class="comment">// only if all 4 neighbors of grid[r][c] have same color as itself, it is on inner part.</span></span><br><span class="line">            <span class="keyword">if</span> (grid[x][y] == clr) &#123; dfs(grid, x, y, clr); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">4</span>) &#123; grid[r][c] = clr; &#125; <span class="comment">// inner part, change back.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># python代码提供一种使用额外空间记录遍历点的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">colorBorder</span><span class="params">(self, grid, r0, c0, color)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :type r0: int</span></span><br><span class="line"><span class="string">        :type c0: int</span></span><br><span class="line"><span class="string">        :type color: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        border, seen = set(), set()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= x &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; n <span class="keyword">and</span> grid[x][y] == grid[r0][c0]): </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> (x, y) <span class="keyword">in</span> seen: </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            seen.add((x, y))</span><br><span class="line">            <span class="keyword">if</span> dfs(x + <span class="number">1</span>, y) + dfs(x - <span class="number">1</span>, y) + dfs(x, y + <span class="number">1</span>) + dfs(x, y - <span class="number">1</span>) &lt; <span class="number">4</span>: </span><br><span class="line">                border.add((x, y))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        dfs(r0, c0)</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> border: grid[x][y] = color</span><br><span class="line">        <span class="keyword">return</span> grid</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(N*M)<br>空间复杂度: O(1)<br><code>N</code>, <code>M</code>分别是<code>grid</code>的长和宽。</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/zcbFn8DH0PU" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1036] Escape a Large Maze</title>
    <url>/Leetcode-1036-Escape-a-Large-Maze/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>In a 1 million by 1 million grid, the coordinates of each grid square are <code>(x, y)</code> with <code>0 &lt;= x, y &lt; 10^6</code>.</p>
<p>We start at the <code>source</code> square and want to reach the <code>target</code> square.  Each move, we can walk to a 4-directionally adjacent square in the grid that isn’t in the given list of <code>blocked</code> squares.</p>
<p>Return <code>true</code> if and only if it is possible to reach the target square through a sequence of moves.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> The target square is inaccessible starting from the source square, because we can’t walk outside the grid.</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> blocked = [], source = [0,0], target = [999999,999999]<br><strong>Output:</strong> true<br><strong>Explanation:</strong> Because there are no blocked cells, it’s possible to reach the target square.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>0 &lt;= blocked.length &lt;= 200</code></li>
<li><code>blocked[i].length == 2</code></li>
<li><code>0 &lt;= blocked[i][j] &lt; 10^6</code></li>
<li><code>source.length == target.length == 2</code></li>
<li><code>0 &lt;= source[i][j], target[i][j] &lt; 10^6</code></li>
<li><code>source != target</code></li>
</ol>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目给我们一个1百万乘1百万的迷宫，同时告诉你其中一些点是阻隔的，不能通过。问你是否有一条通路可以从点<code>source</code>连接到<code>target</code>。</p>
<p>按照常规思路，我们首先想到的肯定是用<code>DFS</code>或者<code>BFS</code>的方法，从一个点开始，暴力搜索所有能到的点。但是，由于迷宫非常大，这样做的时间复杂度会达到O(10^12)，你提交的解法会 TLE。</p>
<p>我们回头仔细看题目给我们的<code>Note</code>, 发现<code>blocked</code>的长度是有限制的，最多不超过<code>200</code>。这能给我们带来启发。首先，两个点之所以不能联通，一定是因为被<code>blocked</code>中的点分隔开了。那意味着<code>blocked</code>中的点能将迷宫分割成两个部分，每个部分分别包含<code>source</code>和<code>target</code>中的一个点。而因为<code>blocked</code>的点数量不超过<code>200</code>，因此，它所能围城的面积也是有限制的。</p>
<p>我们可以将问题抽象成这样一个数学问题，在一个<code>1000000 \* 1000000</code>的矩形中，用一条长<code>200</code>的线，最多能围出多大的面积？这个问题可以用泛函的知识求解，这里不多做说明。但其实我们利用对称性可以知道，在任意一个角，围出一个弧长<code>200</code>的<code>1/4</code>圆就是最大的面积，也就是<code>4/pi \* 10000</code>。</p>
<p>知道了这个面积，我们只需要对<code>source</code>和<code>target</code>分别做两次<code>BFS</code>。每次BFS，我们设定所搜的次数不超过我们求出的这个最大面积。如果在这些点中找到了<code>target</code>或<code>source</code>,那自然说明有这样一条通路。否则：</p>
<ol>
<li>如果我们发现<code>BFS</code>在我们设定的搜索次数内，已经完成，那么说明<code>source</code>或者<code>target</code>处于被<code>blocked</code>点和迷宫边界构成的一个封闭区间内，不存在通路。 </li>
<li>如果<code>BFS</code>在设定的搜索次数内没有完成，说明并没有这样一个封闭区间能包裹住<code>source</code>或者<code>target</code>,那它们两个点一定是能够连通的。</li>
</ol>
<p>下图给出<code>target</code>和<code>source</code>别阻隔时，可能的情况。(图片引子<code>Discuss</code>中<code>2017111303</code>的帖子)<br><img src="/Leetcode-1036-Escape-a-Large-Maze/lc1036.png" width="1000"></p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; bSet;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span>  len = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> maxArea = <span class="number">4</span>/<span class="number">3.14</span>*<span class="number">10000</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEscapePossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; blocked, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; source, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> b : blocked) &#123;</span><br><span class="line">            bSet.insert(<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(b[<span class="number">0</span>] * len + b[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bfs(source, target) &amp;&amp; bfs(target, source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; source, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; aSet;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line">        q.push_back(&#123;source[<span class="number">0</span>], source[<span class="number">1</span>]&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (q.size() != <span class="number">0</span> &amp;&amp; aSet.size() &lt; maxArea) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = q.front()[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> c = q.front()[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (r == target[<span class="number">0</span>] &amp;&amp; c == target[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            aSet.insert(r * len + c);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> rNew = r + dir[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> cNew = c + dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (rNew &gt;= <span class="number">0</span> &amp;&amp; rNew &lt; len &amp;&amp; cNew &gt;= <span class="number">0</span> &amp;&amp; cNew &lt; len) &#123;</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> locNew = rNew * len + cNew;</span><br><span class="line">                    <span class="keyword">if</span> (aSet.find(locNew) == aSet.end() &amp;&amp; bSet.find(locNew) == bSet.end()) &#123;</span><br><span class="line">                        q.push_back(&#123;rNew, cNew&#125;);</span><br><span class="line">                        aSet.insert(locNew);</span><br><span class="line">                    &#125;                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            q.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> aSet.size() &gt;= maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Long M = <span class="number">1000000L</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEscapePossible</span><span class="params">(<span class="keyword">int</span>[][] bs, <span class="keyword">int</span>[] s, <span class="keyword">int</span>[] t)</span> </span>&#123;</span><br><span class="line">        Set&lt;Long&gt; b = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] n : bs) b.add(n[<span class="number">0</span>]*M + n[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> check(b, s, t, s, <span class="keyword">new</span> HashSet&lt;&gt;()) &amp;&amp; check(b, t, s, t, <span class="keyword">new</span> HashSet&lt;&gt;());<span class="comment">//make sure that both s ant t will not be surrouded by the block.</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Set&lt;Long&gt; b, <span class="keyword">int</span>[] s, <span class="keyword">int</span>[] t, <span class="keyword">int</span>[] p, Set&lt;Long&gt; v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(p[<span class="number">0</span>] - s[<span class="number">0</span>]) == <span class="number">200</span> || Math.abs(p[<span class="number">1</span>] - s[<span class="number">1</span>]) == <span class="number">200</span> || v.size() &gt; <span class="number">0</span> &amp;&amp; p[<span class="number">0</span>] == t[<span class="number">0</span>] &amp;&amp; p[<span class="number">1</span>] == t[<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        v.add(p[<span class="number">0</span>]*M+p[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] dir : dirs) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = p[<span class="number">0</span>] + dir[<span class="number">0</span>], y = p[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x == M || y &lt; <span class="number">0</span> || y == M || v.contains(x*M+y) || b.contains(x*M+y)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(b, s, t, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;, v)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEscapePossible</span><span class="params">(self, blocked, source, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type blocked: List[List[int]]</span></span><br><span class="line"><span class="string">        :type source: List[int]</span></span><br><span class="line"><span class="string">        :type target: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> blocked: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        blocked = set(map(tuple, blocked))</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(blocked, source, target)</span>:</span></span><br><span class="line">            si, sj = source</span><br><span class="line">            ti, tj = target</span><br><span class="line">            level = <span class="number">0</span></span><br><span class="line">            q = collections.deque([(si,sj)])</span><br><span class="line">            vis = set()</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(q)):</span><br><span class="line">                    i,j = q.popleft()</span><br><span class="line">                    <span class="keyword">if</span> i == ti <span class="keyword">and</span> j == tj: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">for</span> x,y <span class="keyword">in</span> ((i+<span class="number">1</span>,j),(i<span class="number">-1</span>,j),(i,j+<span class="number">1</span>),(i,j<span class="number">-1</span>)):</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span>&lt;=x&lt;<span class="number">10</span>**<span class="number">6</span> <span class="keyword">and</span> <span class="number">0</span>&lt;=y&lt;<span class="number">10</span>**<span class="number">6</span> <span class="keyword">and</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> vis <span class="keyword">and</span> (x,y) <span class="keyword">not</span> <span class="keyword">in</span> blocked:</span><br><span class="line">                            vis.add((x,y))</span><br><span class="line">                            q.append((x,y))</span><br><span class="line">                level += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> level == len(blocked): <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> check(blocked, source, target) <span class="keyword">and</span> check(blocked, target, source)</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(len(blocked)^2)<br>空间复杂度: O(len(blocked))</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://www.youtube.com/watch?v=rvHYB6HOmxw&amp;feature=youtu.be" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1037] Valid Boomerang</title>
    <url>/Leetcode-1037-Valid-Boomerang/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">A&nbsp;<em>boomerang</em>&nbsp;is a set of 3 points that are all distinct and&nbsp;<span style="font-weight: bolder;">not</span>&nbsp;in a straight line.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given a list&nbsp;of three points in the plane, return whether these points are a boomerang.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-1-1">[[1,1],[2,3],[3,2]]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">true</span><br></pre><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-2-1">[[1,1],[2,2],[3,3]]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">false</span></pre></div><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">points.length == 3</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">points[i].length == 2</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0 &lt;= points[i][j] &lt;= 100</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>判断AB，AC斜率是否相同，如果相同则在一条线上<br>注意用乘法好过除法, 因为不用判断分母为0了。<br>面试时要考虑特殊情况，比如两个点重合是否算同线 (本题是distinct的点，所以不用考虑)</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBoomerang</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (points[<span class="number">0</span>][<span class="number">0</span>] - points[<span class="number">1</span>][<span class="number">0</span>]) * (points[<span class="number">0</span>][<span class="number">1</span>] - points[<span class="number">2</span>][<span class="number">1</span>]) != (points[<span class="number">0</span>][<span class="number">0</span>] - points[<span class="number">2</span>][<span class="number">0</span>]) * (points[<span class="number">0</span>][<span class="number">1</span>] - points[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBoomerang</span><span class="params">(<span class="keyword">int</span>[][] p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (p[<span class="number">0</span>][<span class="number">0</span>] - p[<span class="number">1</span>][<span class="number">0</span>]) * (p[<span class="number">0</span>][<span class="number">1</span>] - p[<span class="number">2</span>][<span class="number">1</span>]) != (p[<span class="number">0</span>][<span class="number">0</span>] - p[<span class="number">2</span>][<span class="number">0</span>]) * (p[<span class="number">0</span>][<span class="number">1</span>] - p[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBoomerang</span><span class="params">(self, points: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> (points[<span class="number">0</span>][<span class="number">0</span>] - points[<span class="number">1</span>][<span class="number">0</span>]) * (points[<span class="number">0</span>][<span class="number">1</span>] - points[<span class="number">2</span>][<span class="number">1</span>]) != (points[<span class="number">0</span>][<span class="number">0</span>] - points[<span class="number">2</span>][<span class="number">0</span>]) * (points[<span class="number">0</span>][<span class="number">1</span>] - points[<span class="number">1</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(1)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/8al3wkgvpcQ" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1038] Binary Search Tree to Greater Sum Tree</title>
    <url>/Leetcode-1038-Binary-Search-Tree-to-Greater-Sum-Tree/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given the root of a binary search tree with distinct values, modify it so that every <code>node</code> has a new value equal to the sum of the values of the original tree that are greater than or equal to <code>node.val</code>.</p>
<p>As a reminder, a <em>binary search tree</em> is a tree that satisfies these constraints:</p>
<p>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<p><strong>Example 1:</strong><br><blockquote><p><img src="/Leetcode-1038-Binary-Search-Tree-to-Greater-Sum-Tree/lc1038.png" width="400"><br><strong>Input:</strong><br>[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br><strong>Output:</strong><br>[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p>
</blockquote></p>
<p><strong>Constraints:</strong></p>
<p>The number of nodes in the tree is between <code>1</code> and <code>100</code>.<br>Each node will have value between <code>0</code> and <code>100</code>.<br>The given tree is a binary search tree.<br><strong>Note</strong>: This question is the same as 538: <a href="https://leetcode.com/problems/convert-bst-to-greater-tree/" target="_blank" rel="noopener">https://leetcode.com/problems/convert-bst-to-greater-tree/</a></p>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求将<code>binary search tree</code>中每个节点的值替换成不小于当前节点的所有元素的和。我们可以利用中序遍历的思想，进行发”反向“的中序遍历。也就是说将元素从大到小的进行搜索。遍历过程中，用一个变量记录到当前节点位置为止，所遍历过的元素的和。将其与当前节点的值进行替换。</p>
<p>代码可以用<code>recursion</code>和<code>iteration</code>两种方法实现。这里使用<code>iteration</code>的方法.优点在于，一是加深对中序遍历的理解， 二是避免<code>stack overflow</code>。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bstToGst</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        TreeNode* tmp = root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; sk;</span><br><span class="line">        <span class="keyword">while</span> (!sk.empty() || tmp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">                sk.push(tmp);</span><br><span class="line">                tmp = tmp-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp = sk.top();</span><br><span class="line">                curSum += tmp-&gt;val;</span><br><span class="line">                tmp-&gt;val = curSum;</span><br><span class="line">                sk.pop();</span><br><span class="line">                tmp = tmp-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">bstToGst</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) bstToGst(root.right);</span><br><span class="line">        pre = root.val = pre + root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) bstToGst(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    val = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bstToGst</span><span class="params">(self, root: TreeNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root.right: self.bstToGst(root.right)</span><br><span class="line">        root.val = self.val = self.val + root.val</span><br><span class="line">        <span class="keyword">if</span> root.left: self.bstToGst(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(n)<br>空间复杂度: O(1)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/QaR9Jarf6Hw" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Binary Search Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1039] Minimum Score Triangulation of Polygon</title>
    <url>/Leetcode-1039-Minimum-Score-Triangulation-of-Polygon/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">N</code>, consider a convex&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">N</code>-sided polygon with vertices labelled&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A[0], A[i], …, A[N-1]</code>&nbsp;in clockwise order.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Suppose you triangulate the polygon into&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">N-2</code>&nbsp;triangles.&nbsp; For each triangle, the value of that triangle is the&nbsp;<span style="font-weight: bolder;">product</span>&nbsp;of the labels of the vertices, and the&nbsp;<em>total score</em>&nbsp;of the triangulation is the sum of these values over all&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">N-2</code>&nbsp;triangles in the triangulation.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return the smallest possible total score that you can achieve with some triangulation of the polygon.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"></ol><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-1-1">[1,2,3]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">6</span><br><span style="font-weight: bolder;">Explanation: </span>The polygon is already triangulated, and the score of the only triangle is 6.<br></pre><div><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 2:</span></p><p style="font-size: inherit; margin-bottom: 1em;"><img alt src="https://assets.leetcode.com/uploads/2019/05/01/minimum-score-triangulation-of-polygon-1.png" style="border-style: none; max-width: 100%; height: 150px; width: 253px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-2-1">[3,7,4,5]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">144</span><br><span style="font-weight: bolder;">Explanation: </span>There are two triangulations, with possible scores: 3<em>7</em>5 + 4<em>5</em>7 = 245, or 3<em>4</em>5 + 3<em>4</em>7 = 144.  The minimum score is 144.<br></pre><div><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-3-1">[1,3,1,4,1,5]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">13</span><br><span style="font-weight: bolder;">Explanation: </span>The minimum score triangulation has score 1<em>1</em>3 + 1<em>1</em>4 + 1<em>1</em>5 + 1<em>1</em>1 = 13.<br></pre><p style="font-size: inherit; margin-bottom: 1em;">&nbsp;</p><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">3 &lt;= A.length &lt;= 50</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= A[i] &lt;= 100</code></li></ol></div></div></div><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>动态规划，递归可以使逻辑简单（本质还是动态规划）</p>
<ol>
<li>将多边形起始位置设为<code>start</code>，<code>end</code>, 用一个数组dp来记录任意起始位置的<code>score</code></li>
<li>为了计算<code>dp[start][end]</code>, 我们用一个index <code>k</code>在<code>start</code>到<code>end</code>之间遍历<br><code>dp[start][end] = min(dp[start][k] + dp[k][end] + A[start] * A[k] * A[end])</code></li>
<li>结果为<code>dp[0][n - 1]</code><br><strong>注意</strong>：</li>
<li>相邻的<code>dp[i][i + 1] = 0</code>, 因为两条边无法组成三角形</li>
<li>如果用传统动归的方法，必须<code>i</code>的位置从<code>j</code>开始往前推，不能<code>i</code>和<code>j</code>都从小往大推，不然<code>dp[k][j]</code>是未知的。</li>
</ol>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><p>递归（实际上还是动态规划，因为有memorization）<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getScore</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[start][end] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[start][end];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> score = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = start + <span class="number">1</span>; k &lt;= end - <span class="number">1</span>; ++k) &#123;</span><br><span class="line">            score = min(score, getScore(A, dp, start, k) + getScore(A, dp, k, end) + A[start] * A[k] * A[end]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[start][end] = score;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 递归（实际上还是动态规划，因为有memorization）</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">return</span> getScore(A, dp, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>动态规划<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                dp[i][j] = INT_MAX;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k) &#123;</span><br><span class="line">                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] + A[i] * A[j] * A[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minScoreTriangulation</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = j - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                dp[i][j] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; ++k)</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k][j] + A[i] * A[j] * A[k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minScoreTriangulation</span><span class="params">(self, A: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(A)</span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n - d):</span><br><span class="line">                j = i + d</span><br><span class="line">                dp[i][j] = min(dp[i][k] + dp[k][j] + A[i] * A[j] * A[k] <span class="keyword">for</span> k <span class="keyword">in</span> range(i + <span class="number">1</span>, j))</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度:<code>O(N^3)</code>, 用传统动归可以很容易看出，用递归的方法可以想到任意<code>dp[i][j]</code>都遍历一次<code>O(N^2)</code>，而每一次遍历中<br>都有一个 <code>for (int k = start + 1; k &lt;= end - 1; ++k)</code>用到<code>O(N)</code><br>空间复杂度:<code>O(N^2)</code>, 递归会使用额外的<code>O(N)</code>stack</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/q1tM-6lXwEU" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Uber</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 104] Maximum Depth of Binary Tree</title>
    <url>/Leetcode-104-Maximum-Depth-of-Binary-Tree/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>For example:</p>
<p>Given binary tree [3,9,20,null,null,15,7],</p>
<pre><code>  3   
 / \
9  20
   / \
  15  7
</code></pre><p>return its depth = 3 </p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这题要求我们给出二叉树的最大深度。最大深度是指的从根节点一直到最远的叶节点中所有的节点数目。</p>
<p>因为二叉树有左右两棵，所以二叉树的最大深度为其根节点左右两棵子树中，最深的那棵子树的深度加一.</p>
<p><code>depth(root) = max(depth(root.left), depth(root.right)) + 1</code></p>
<p>显然我们可以用深度搜索（<code>DFS</code>）来实现这一算法，非常简单。</p>
<h4 id="示例代码-（python）"><a href="#示例代码-（python）" class="headerlink" title="示例代码 （python）"></a>示例代码 （python）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-（c-）"><a href="#示例代码-（c-）" class="headerlink" title="示例代码 （c++）"></a>示例代码 （c++）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthHelper</span><span class="params">(TreeNode* curr, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left,right;</span><br><span class="line">        <span class="keyword">if</span>(!curr) &#123;</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        &#125;</span><br><span class="line">        left = depthHelper(curr-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">        right = depthHelper(curr-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> depthHelper(root, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>使用深度搜索<code>DFS</code>,每个节点被访问一次。并且递归过程中，栈的最大深度为O(n)。考虑到本题并非平衡二叉树，最差将退化成链表，而大O代表复杂度的上阈值，因此为O(n)。<br>所以复杂度分析为：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1), &#160; 递归栈深度O(n)</li>
</ul>
<h4 id="总结归纳："><a href="#总结归纳：" class="headerlink" title="总结归纳："></a>总结归纳：</h4><p>这题比较简单，想清楚树的深度的定义，找出递归的关系，就可以利用递归的方法解题。当然也可以使用非递归的方便遍历树来解决这一问题，有兴趣的朋友可以自己试试。</p>
<p>更多Tree相关的内容将更新在 <a href="/tags/Tree">Tree Tag</a>，尽请期待，种香蕉树去了：）</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Uber</tag>
        <tag>Apple</tag>
        <tag>Yahoo</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
        <tag>LinkedIn</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1040] Moving Stones Until Consecutive II</title>
    <url>/Leetcode-1040-Moving-Stones-Until-Consecutive-II/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>On an <em>infinite</em> number line, the position of the i-th stone is given by <code>stones[i]</code>.  Call a stone an <em>endpoint</em> stone if it has the smallest or largest position.</p>
<p>Each turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.</p>
<p>In particular, if the stones are at say, <code>stones = [1,2,5]</code>, you <em>cannot</em> move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.</p>
<p>The game ends when you cannot make any more moves, ie. the stones are in consecutive positions.</p>
<p>When the game ends, what is the minimum and maximum number of moves that you could have made?  Return the answer as an length 2 array: <code>answer = [minimum_moves, maximum_moves]</code></p>
<p><strong>Example 1</strong><br><blockquote><p><strong>Input:</strong> [7,4,9]<br><strong>Output:</strong> [1,2]<br><strong>Explanation:</strong> We can move 4 -&gt; 8 for one move to finish the game.<br>Or, we can move 9 -&gt; 5, 4 -&gt; 6 for two moves to finish the game.</p>
</blockquote></p>
<p><strong>Example 2</strong><br><blockquote><p><strong>Input:</strong> [6,5,4,3,10]<br><strong>Output:</strong> [2,3]<br><strong>Explanation:</strong> We can move 3 -&gt; 8 then 10 -&gt; 7 to finish the game.<br>Or, we can move 3 -&gt; 7, 4 -&gt; 8, 5 -&gt; 9 to finish the game.<br>Notice we cannot move 10 -&gt; 2 to finish the game, because that would be an illegal move.</p>
</blockquote></p>
<p><strong>Example 3</strong><br><blockquote><p><strong>Input:</strong> [100,101,104,102,103]<br><strong>Output:</strong> [0,0]</p>
</blockquote></p>
<p><strong>Note</strong><br><blockquote><ol>
<li><code>3 &lt;= stones.length &lt;= 10^4</code></li>
<li><code>1 &lt;= stones[i] &lt;= 10^9</code></li>
<li><code>stones[i] have distinct values.</code></li>
</ol>
</blockquote></p>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求求出让石头堆连续排列的最大和最小移动步数。我们需要将最大和最小移动步数分成两个问题考虑。将总共的石头堆的数目用<code>n</code>表示。另外，我们首先需要做预处理，将给我们的<code>array</code>做个排序。</p>
<p>对最大移动步数，用贪心的思想，要么都移动到最左端，要么都移动到最右端。我们需要考察<code>stones[n-2]</code>到<code>stones[0]</code>和<code>stones[n-1]</code>到<code>stones[1]</code>的间距，进行比较。在这两个选择中。选择空的position最多的那个。同时，因为一开始需要将一个<code>endpoint</code>做一次移动，所以需要额外加上这次步骤。</p>
<p>对最小移动步数，用sliding window 的方法。<code>window</code>的长度是<code>n</code>。计算每个window中，最多已经被填满的空间数量。剩下的未被填满的空间就是最小的移动数目。</p>
<p>需要额外注意的是，这里存在一种<code>corner case</code>违背了上述的结论，需要特殊处理。举例如下：<br>如果石头堆是<code>1，2，3，6</code>, 那么<code>n</code>是<code>4</code>，对于第一个<code>window</code>，它有一个空位置，在<code>4</code>， 但是<code>6</code>不能移动到<code>4</code>，这不是一个<code>valid move</code>，所以必须将<code>1</code> 移动到<code>5</code>，<code>6</code>移动到<code>4</code>，必须至少<code>2</code>步才能完成要求。</p>
<p>也就是说，当一个<code>window</code>的长度是n，它包含了连续的n-1个非空位，同时这n-1个非空位在原来石头堆的位置也是连续的，那我们就需要<code>2</code>步才能完成石头堆的最小移动。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">numMovesStonesII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = stones.size();</span><br><span class="line">        sort(stones.begin(), stones.end());</span><br><span class="line">        <span class="keyword">int</span> upper;</span><br><span class="line">        <span class="keyword">int</span> lower = n;</span><br><span class="line">        <span class="comment">// calculate upper bound</span></span><br><span class="line">        upper = max(stones[n<span class="number">-1</span>] - stones[<span class="number">1</span>] + <span class="number">1</span> - n  + <span class="number">1</span>, stones[n - <span class="number">2</span>] - stones[<span class="number">0</span>] + <span class="number">1</span> - n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// calculate lower bound</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; end = <span class="number">0</span>; end &lt; n; ++end) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stones[end] - stones[start] + <span class="number">1</span> &gt; n) &#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stones[end] - stones[start] + <span class="number">1</span> == n - <span class="number">1</span> &amp;&amp; end - start + <span class="number">1</span> == n - <span class="number">1</span>) &#123;</span><br><span class="line">                lower = min(lower, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                lower = min(lower, n - (end - start + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;lower, upper&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] numMovesStonesII(<span class="keyword">int</span>[] stones) &#123;</span><br><span class="line">        Arrays.sort(stones);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, n = stones.length, lower = n;</span><br><span class="line">        <span class="keyword">int</span> upper = Math.max(stones[n - <span class="number">1</span>] - n + <span class="number">2</span> - stones[<span class="number">1</span>], stones[n - <span class="number">2</span>] - stones[<span class="number">0</span>] - n + <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stones[j] - stones[i] &gt;= n) ++i;</span><br><span class="line">            <span class="keyword">if</span> (j - i + <span class="number">1</span> == n - <span class="number">1</span> &amp;&amp; stones[j] - stones[i] == n - <span class="number">2</span>)</span><br><span class="line">                lower = Math.min(lower, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lower = Math.min(lower, n - (j - i + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;lower, upper&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numMovesStonesII</span><span class="params">(self, stones: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        stones.sort()</span><br><span class="line">        i, n, lower = <span class="number">0</span>, len(stones), len(stones)</span><br><span class="line">        upper = max(stones[<span class="number">-1</span>] - n + <span class="number">2</span> - stones[<span class="number">1</span>], stones[<span class="number">-2</span>] - stones[<span class="number">0</span>] - n + <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">while</span> stones[j] - stones[i] &gt;= n: i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j - i + <span class="number">1</span> == n - <span class="number">1</span> <span class="keyword">and</span> stones[j] - stones[i] == n - <span class="number">2</span>:</span><br><span class="line">                lower = min(lower, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lower = min(lower, n - (j - i + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> [lower, upper]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(nlogn + n + 1) = O(nlogn)<br>空间复杂度: O(1)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/x7dOswYkMh4" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Array</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1041] Robot Bounded In Circle</title>
    <url>/Leetcode-1041-Robot-Bounded-In-Circle/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">On an infinite plane, a&nbsp;robot initially stands at&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">(0, 0)</code>&nbsp;and faces north.&nbsp;&nbsp;The robot can receive one of three instructions:</p><ul style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">“G”</code>: go straight 1 unit;</li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">“L”</code>: turn 90 degrees to the left;</li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">“R”</code>: turn 90 degress to the right.</li></ul><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">The robot performs the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">instructions</code>&nbsp;given in order, and repeats them forever.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">true</code>&nbsp;if and only if there exists a circle in the plane such that the robot never leaves the circle.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>“GGLLGG”<br><span style="font-weight: bolder;">Output: </span>true<br><span style="font-weight: bolder;">Explanation: </span><br>The robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).<br>When repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>“GG”<br><span style="font-weight: bolder;">Output: </span>false<br><span style="font-weight: bolder;">Explanation: </span><br>The robot moves north indefinitely.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>“GL”<br><span style="font-weight: bolder;">Output: </span>true<br><span style="font-weight: bolder;">Explanation: </span><br>The robot moves from (0, 0) -&gt; (0, 1) -&gt; (-1, 1) -&gt; (-1, 0) -&gt; (0, 0) -&gt; …<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= instructions.length &lt;= 100</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">instructions[i]</code>&nbsp;is in&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">{‘G’, ‘L’, ‘R’}</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>最多执行几遍系列指令能判断是否转圈？<br>实际上只需要执行一遍系列指令，其导致转圈的充分必要条件是：</p>
<ol>
<li>执行完一遍指令后回到原点<br>或者</li>
<li>执行完一遍指令后发生转向（因为只有向左向右的转向，所以转向最终只可能是90，180，270）</li>
</ol>
<p>通过变量<code>x</code>, <code>y</code>表示距离原点的位移，通过<code>direction</code>表示朝向，同时也是单位位移数组的<code>index</code>：<br><code>direction</code>的值 <code>0, 1, 2, 3</code> 分别表示 北，西，南，东<br>对应的单位位移数组<code>move</code>为：<code>{0, 1}, {-1, 0}, {0, -1}, {1, 0}</code><br>遍历<code>instructions</code>，对于每一个指令，改变对应的<code>x</code>，<code>y</code>和<code>direction</code><br>最终只需要判断是否<code>x</code>，<code>y</code>均为0，或者<code>direction</code>不为0即可</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isRobotBounded</span><span class="params">(<span class="built_in">string</span> instructions)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Corresponding to N, W, S, E</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; move = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, direction = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// char, int, float basic type doesn't need reference</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> instruction : instructions) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instruction == <span class="string">'G'</span>) &#123;</span><br><span class="line">                x += move[direction][<span class="number">0</span>];</span><br><span class="line">                y += move[direction][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instruction == <span class="string">'L'</span>) &#123;</span><br><span class="line">                direction = (direction + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cpp could not use -1, otherwise direction &lt; 0</span></span><br><span class="line">                <span class="comment">// cannot be used as move index</span></span><br><span class="line">                direction = (direction + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) | (direction != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRobotBounded</span><span class="params">(String ins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, i = <span class="number">0</span>, d[][] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123; -<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ins.length(); ++j)</span><br><span class="line">            <span class="keyword">if</span> (ins.charAt(j) == <span class="string">'R'</span>)</span><br><span class="line">                i = (i + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ins.charAt(j) == <span class="string">'L'</span>)</span><br><span class="line">                i = (i + <span class="number">3</span>) % <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                x += d[i][<span class="number">0</span>]; y += d[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span> || i &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isRobotBounded</span><span class="params">(self, instructions: str)</span> -&gt; bool:</span></span><br><span class="line">        x, y, dx, dy = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> instructions:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'R'</span>: dx, dy = dy, -dx</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'L'</span>: dx, dy = -dy, dx</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">'G'</span>: x, y = x + dx, y + dy</span><br><span class="line">        <span class="keyword">return</span> (x, y) == (<span class="number">0</span>, <span class="number">0</span>) <span class="keyword">or</span> (dx, dy) != (<span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/EdDPqv6Ymq4" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Paypal</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1042] Flower Planting With No Adjacent</title>
    <url>/Leetcode-1042-Flower-Planting-With-No-Adjacent/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">You have&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">N</code>&nbsp;gardens, labelled&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1</code>&nbsp;to&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">N</code>.&nbsp; In each garden, you want to plant one of 4 types of flowers.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">paths[i] = [x, y]</code>&nbsp;describes the existence of a bidirectional path from garden&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x</code>&nbsp;to garden&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">y</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Also, there is no garden that has more than 3 paths coming into or leaving it.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Your task is to choose a flower type for each garden such that,&nbsp;for any two gardens connected by a path, they have different types of flowers.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return&nbsp;<span style="font-weight: bolder;">any</span>&nbsp;such a choice as an array&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">answer</code>, where&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">answer[i]</code>&nbsp;is the type of flower&nbsp;planted in the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">(i+1)</code>-th garden.&nbsp; The flower types are denoted&nbsp;<font face="monospace">1</font>,&nbsp;<font face="monospace">2</font>,&nbsp;<font face="monospace">3</font>, or&nbsp;<font face="monospace">4</font>.&nbsp; It is guaranteed an answer exists.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>N = <span id="example-input-1-1">3</span>, paths = <span id="example-input-1-2">[[1,2],[2,3],[3,1]]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">[1,2,3]</span><br></pre><div><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>N = <span id="example-input-2-1">4</span>, paths = <span id="example-input-2-2">[[1,2],[3,4]]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">[1,2,1,2]</span><br></pre><div><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>N = <span id="example-input-3-1">4</span>, paths = <span id="example-input-3-2">[[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">[1,2,3,4]</span><br></pre><p style="font-size: inherit; margin-bottom: 1em;">&nbsp;</p><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Note:</span></p><ul style="margin-bottom: 1em;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= N &lt;= 10000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0 &lt;= paths.size &lt;= 20000</code></li><li>No garden has 4 or more paths coming into or leaving it.</li><li>It is guaranteed an answer exists.</li></ul></div></div></div><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题相当与给我们<code>N</code>个点，每个点最多与图中另外三个点相连，要求我们用<code>4</code>种颜色给图染色，同时任意一条边上的<code>2</code>个点不能是相同的颜色。</p>
<p>因为题目保证了一定存在解，所以我们只要搜索出一种染色方法就可以了。对于一个图，它一定是由若干个最大连通子图组成的。任意两个不同的连通图，它们之间的染色互相不影响。而我们对每个连通图，分别做一次<code>dfs</code>就可以把这个连通图中所有的点做一次满足要求的染色，并把结果保存到我们返回的染色数组中即可。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><p><code>Java</code>和<code>Python</code>代码与<code>C++</code>略有不同，但主题思想是一致的。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">gardenNoAdj</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> path : paths) &#123;</span><br><span class="line">            edges[path[<span class="number">0</span>] - <span class="number">1</span>].insert(path[<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            edges[path[<span class="number">1</span>] - <span class="number">1</span>].insert(path[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges.count(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                ans[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ans[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                color(ans, edges, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">color</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ans, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= <span class="number">4</span>; ++c) &#123;</span><br><span class="line">            <span class="keyword">bool</span> canColor = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> next : edges[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[next] == c) &#123;</span><br><span class="line">                    canColor = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (canColor) &#123;</span><br><span class="line">                ans[i] = c;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : edges[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                color(ans, edges, next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] gardenNoAdj(<span class="keyword">int</span> N, <span class="keyword">int</span>[][] paths) &#123;</span><br><span class="line">        Map&lt;Integer, Set&lt;Integer&gt;&gt; G = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) G.put(i, <span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] p : paths) &#123;</span><br><span class="line">            G.get(p[<span class="number">0</span>] - <span class="number">1</span>).add(p[<span class="number">1</span>] - <span class="number">1</span>);</span><br><span class="line">            G.get(p[<span class="number">1</span>] - <span class="number">1</span>).add(p[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j : G.get(i))</span><br><span class="line">                colors[res[j]] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">4</span>; c &gt; <span class="number">0</span>; --c)</span><br><span class="line">                <span class="keyword">if</span> (colors[c] == <span class="number">0</span>)</span><br><span class="line">                    res[i] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gardenNoAdj</span><span class="params">(self, N, paths)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :type paths: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        g = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> paths:</span><br><span class="line">            g[x].append(y)</span><br><span class="line">            g[y].append(x)</span><br><span class="line">        plantdict = &#123;i: <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N + <span class="number">1</span>)&#125;</span><br><span class="line">        <span class="keyword">for</span> garden <span class="keyword">in</span> g: </span><br><span class="line">            pick = set(range(<span class="number">1</span>,<span class="number">5</span>))</span><br><span class="line">            <span class="keyword">for</span> each <span class="keyword">in</span> g[garden]:</span><br><span class="line">                <span class="keyword">if</span> plantdict[each] != <span class="number">0</span> <span class="keyword">and</span> plantdict[each] <span class="keyword">in</span> pick:</span><br><span class="line">                    pick.remove(plantdict[each])</span><br><span class="line">            plantdict[garden] = pick.pop()</span><br><span class="line">        <span class="keyword">return</span> [plantdict[x] <span class="keyword">if</span> plantdict[x] != <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, N+<span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: 每个点都会被<code>visit</code>一次，同时每次<code>visit</code>一个点，都会同时检查它连接的最多<code>3</code>个点。因此，时间复杂度就是O(N + 3*N) = O(N)<br>空间复杂度: O(N)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/bzr104qA5Js" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>LinkedIn</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1043] Partition Array for Maximum Sum</title>
    <url>/Leetcode-1043-Partition-Array-for-Maximum-Sum/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given an integer array&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A</code>, you partition the array into (contiguous) subarrays of length at most&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">K</code>.&nbsp; After partitioning, each subarray has their values changed to become the maximum value of that subarray.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return the largest sum of the given array after partitioning.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>A = <span id="example-input-1-1">[1,15,7,9,2,5,10]</span>, K = <span id="example-input-1-2">3</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">84<br></span><span style="font-weight: bolder;">Explanation</span>: A becomes [15,15,15,9,10,10,10]</pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= K &lt;= A.length&nbsp;&lt;= 500</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0 &lt;= A[i] &lt;= 10^6</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>动态规划，用<code>p[i]</code>来表示<code>A</code>中前<code>i</code>个元素能够得到的最大值。<br>对于下一位<code>dp[i + 1]</code>(即新加入元素<code>A[i]</code>)来说，我们将以<code>A[i]</code>结尾的切分(partition)的长度从<code>len = 1</code>开始向前遍历，直到达到长度上限<code>K</code>：<code>len = K</code><br>或者达到最左边：<code>i - len + 1 = 0</code></p>
<p>对于每一个以<code>A[i]</code>结尾的切分长度<code>len</code>，我们首先计算该切分中的最大值（即从<code>i</code>到<code>i - len + 1</code>之间<code>A</code>的最大值），用<code>max_value</code>表示：<br><code>max_value = max(max_value, A[i - len + 1]);</code><br>然后将<code>dp[i + 1]</code>的值更新为：<br><code>max(dp[i + 1], max_value * len + dp[i - len + 1])</code></p>
<p>返回dp数组最后一个值：<code>dp[A.size()]</code></p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最左边dp[0]始终为0，可以不用判断最左边的边界条件</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(A.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">// i为A的index</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> max_value = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= K &amp;&amp; i - len + <span class="number">1</span> &gt;= <span class="number">0</span>; ++len) &#123;</span><br><span class="line">                max_value = max(max_value, A[i - len + <span class="number">1</span>]);</span><br><span class="line">                <span class="comment">// dp的index相比A的index右移一格</span></span><br><span class="line">                dp[i + <span class="number">1</span>] = max(dp[i + <span class="number">1</span>], max_value * len + dp[i - len + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[A.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = A.length, dp[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= K &amp;&amp; i - k + <span class="number">1</span> &gt;= <span class="number">0</span>; ++k) &#123;</span><br><span class="line">                curMax = Math.max(curMax, A[i - k + <span class="number">1</span>]);</span><br><span class="line">                dp[i] = Math.max(dp[i], (i &gt;= k ? dp[i - k] : <span class="number">0</span>) + curMax * k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSumAfterPartitioning</span><span class="params">(self, A: List[int], K: int)</span> -&gt; int:</span></span><br><span class="line">        N = len(A)</span><br><span class="line">        dp = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">            curMax = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, min(K, i + <span class="number">1</span>) + <span class="number">1</span>):</span><br><span class="line">                curMax = max(curMax, A[i - k + <span class="number">1</span>])</span><br><span class="line">                dp[i] = max(dp[i], dp[i - k] + curMax * k)</span><br><span class="line">        <span class="keyword">return</span> dp[N - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N * K)</code>, <code>N</code>为数组<code>A</code>的长度<br>空间复杂度: <code>O(N)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/OKNR9xE-Luo" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1044] Longest Duplicate Substring</title>
    <url>/Leetcode-1044-Longest-Duplicate-Substring/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given a string&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>, consider all&nbsp;<em>duplicated substrings</em>: (contiguous) substrings of S that occur 2 or more times.&nbsp; (The occurrences&nbsp;may overlap.)</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return&nbsp;<span style="font-weight: bolder;">any</span>&nbsp;duplicated&nbsp;substring that has the longest possible length.&nbsp; (If&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>&nbsp;does not have a duplicated substring, the answer is&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">“”</code>.)</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-1-1">“banana”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">“ana”</span><br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-2-1">“abcd”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">“”</span><br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">2 &lt;= S.length &lt;= 10^5</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>&nbsp;consists of lowercase English letters.</li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求给出一个字符串中，重复出现至少<code>2</code>次的最长子串。</p>
<p>首先，我们考虑如果采用暴力破解，若字符串长度是<code>n</code>，那么从<code>n</code>到<code>1</code>依次从大到小计算，第一次遇到重复出现两次的子串，就是我们的答案。</p>
<p>但是，暴力算法显然不是最优解，也不能AC。</p>
<p>显然，最长子串的长度最大至多是<code>n-1</code>，最小是<code>0</code>。也就提醒我们可以按照这个空间进行<a href="/tags/Binary-Search/"><code>binary search</code></a>。</p>
<p>然后，在每一次二分搜索中，我们判断在当前长度下有没有相同的子串重复出现至少2次。如果存在，那向上搜索；如果不存在，那向下搜索，直到找到答案。这里，用哈希表记录下每一次出现过的子串。但是，如果单纯用子串作为<code>key</code>,我们会发现<code>memory exceed</code>。显然，我们需要对字符串的存储做个优化。但如何优化一开始我也没想出来。提示中告诉我们，<code>To check whether an answer of length K exists, we can use Rabin-Karp &#39;s algorithm.</code>。什么是<code>Rahin-karp</code>算法呢？根据<code>wiki</code> <a href="https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm</a> 给我们的解释，它就是一种优化快速查询文本中出现给定子串的的方法。</p>
<p>简单来说，对于一个字符串，用一个哈希函数求出对应的哈希值。当两个哈希值不同时，这两个字符串一定不同，而当两个哈希值相同时，这两个字符串有大概率相同。因为查找子串的过程，可以高效利用之前求出的哈希值，不用太多的重复计算(<code>wiki</code>中称为<code>rolling hash function</code>)，因此能快速计算哈希值并且高效储存。</p>
<p>具体到哈希值的计算，我们举例说明：<br>首先需要确定一个<code>base</code>，也就是进制，这里我们选择<code>26</code>。然后我们选择一个<code>modulus</code>，比如<code>31</code>。按题目中给出的<code>banana</code>，我们计算长度是<code>3</code>的各个子串的哈希值。</p>
<p><code>ban</code>: (1 * 26 * 26 + 0 * 26 + 13) % 31 = 7<br><code>ana</code>: (0 * 26 * 26 + 13 * 26 + 0) % 31 = 28<br><code>nan</code>: (13 * 26 * 26 + 0 * 26 + 13) % 31 = 28<br><code>ana</code>: (0 * 26 * 26 + 13 * 26 + 0) % 31 = 28</p>
<p>我们可以观察到，<code>ana</code>与<code>nan</code>拥有相同的哈希值，但是它们确实是不同的字符串。因为这种哈希值的计算过程中，有重复计算的部分，所以我们可以<code>rolling</code>这部分的内容，优化时间。同时，哈希值的空间大小也是明显优于那些超长字符串的。</p>
<p>需要说明的是，这个方法会有<code>false positive</code>的可能，因为<code>hash function</code>有<code>collision</code>的产生。但当<code>modulus</code>很大时，概率是极低的。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestDupSubstring</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len = left + (right-left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(search(len, S, n) != <span class="number">-1</span>)</span><br><span class="line">                left = len + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = len - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start = search(left - <span class="number">1</span>, S, n);</span><br><span class="line">        <span class="keyword">return</span> S.substr(start, left - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> len, <span class="built_in">string</span> s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> modulus = (<span class="keyword">long</span>)<span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">34</span>);</span><br><span class="line">        <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">long</span>&gt; sets;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            value = value * <span class="number">26</span> + s[i] - <span class="string">'a'</span>;</span><br><span class="line">            value = value % modulus;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sets.insert(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prepass, cache the remainder</span></span><br><span class="line">        <span class="keyword">long</span> aL = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            aL = (aL * <span class="number">26</span>) % modulus;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n-len; i++) &#123;</span><br><span class="line">            value = value * <span class="number">26</span> - (s[i<span class="number">-1</span>] - <span class="string">'a'</span>) * aL + modulus + s[i+len<span class="number">-1</span>] - <span class="string">'a'</span>;</span><br><span class="line">            value = value % modulus;</span><br><span class="line">            <span class="keyword">if</span>(sets.count(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sets.insert(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> q = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> R = <span class="number">256</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestDupSubstring</span><span class="params">(String S)</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> right = S.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            Map&lt;Long, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">long</span> hash = hash(S, len);</span><br><span class="line">            map.put(hash, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            map.get(hash).add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> RM = <span class="number">1l</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) RM = (R * RM) % q;</span><br><span class="line">            </span><br><span class="line">            loop:</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + len &lt;= S.length(); i++) &#123;</span><br><span class="line">                hash = (hash + q - RM * S.charAt(i - <span class="number">1</span>) % q) % q;</span><br><span class="line">                hash = (hash * R + S.charAt(i + len - <span class="number">1</span>)) % q;</span><br><span class="line">                <span class="keyword">if</span> (!map.containsKey(hash)) &#123;</span><br><span class="line">                    map.put(hash, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j : map.get(hash)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (compare(S, i, j, len)) &#123;</span><br><span class="line">                            found = <span class="keyword">true</span>;</span><br><span class="line">                            start = i;</span><br><span class="line">                            maxLen = len;</span><br><span class="line">                            <span class="keyword">break</span> loop;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                map.get(hash).add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (found) left = len + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = len - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> S.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">hash</span><span class="params">(String S, <span class="keyword">int</span> len)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">long</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) h = (R * h + S.charAt(j)) % q;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(String S, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">0</span>; count &lt; len; count++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i++) != S.charAt(j++)) <span class="keyword">return</span> <span class="keyword">false</span> ; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestDupSubstring</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        A = [ord(c) - ord(<span class="string">'a'</span>) <span class="keyword">for</span> c <span class="keyword">in</span> S]</span><br><span class="line">        mod = <span class="number">2</span>**<span class="number">34</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(L)</span>:</span></span><br><span class="line">            p = pow(<span class="number">26</span>, L, mod)</span><br><span class="line">            cur = reduce(<span class="keyword">lambda</span> x, y: (x * <span class="number">26</span> + y) % mod, A[:L], <span class="number">0</span>)</span><br><span class="line">            seen = &#123;cur&#125;</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(L, len(S)):</span><br><span class="line">                cur = (cur * <span class="number">26</span> + A[i] - A[i - L] * p) % mod</span><br><span class="line">                <span class="keyword">if</span> cur <span class="keyword">in</span> seen: <span class="keyword">return</span> i - L + <span class="number">1</span></span><br><span class="line">                seen.add(cur)</span><br><span class="line">        res, lo, hi = <span class="number">0</span>, <span class="number">0</span>, len(S)</span><br><span class="line">        <span class="keyword">while</span> lo &lt; hi:</span><br><span class="line">            mi = (lo + hi + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">            pos = test(mi)</span><br><span class="line">            <span class="keyword">if</span> pos:</span><br><span class="line">                lo = mi</span><br><span class="line">                res = pos</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mi - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> S[res:res + lo]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(NlogN)，<code>N</code> 是字符串的长度。<br>空间复杂度: O(N)，<code>N</code> 是字符串的长度。</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p><code>Rahin-karp</code>的算法，不知道的人在做题时不会想到。同样，也不大可能在面试的时候自己想出来。非常正常。但我们了解后，还是比较简单的。同时，用哈希的方法转化的思想值得我们注意。<br>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/zzXFu9exKj8" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1045] Customers Who Bought All Products</title>
    <url>/Leetcode-1045-Customers-Who-Bought-All-Products/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Customer</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| customer_id | int     |<br>| product_key | int     |<br>+————-+———+<br>product_key is a foreign key to <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">Product</code> table.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Product</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| product_key | int     |<br>+————-+———+<br>product_key is the primary key column for this table.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Write an SQL query for a report that provides the customer ids from the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Customer</code>&nbsp;table&nbsp;that bought all the products in the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Product</code>&nbsp;table.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">For example:</p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">Customer table:<br>+————-+————-+<br>| customer_id | product_key |<br>+————-+————-+<br>| 1           | 5           |<br>| 2           | 6           |<br>| 3           | 5           |<br>| 3           | 6           |<br>| 1           | 6           |<br>+————-+————-+<p></p>
<p>Product table:<br>+————-+<br>| product_key |<br>+————-+<br>| 5           |<br>| 6           |<br>+————-+</p>
<p>Result table:<br>+————-+<br>| customer_id |<br>+————-+<br>| 1           |<br>| 3           |<br>+————-+<br>The customers who bought all the products (5 and 6) are customers with id 1 and 3.</p></pre><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>筛选customer的条件为：其购买的distinct的商品数量等于Product中商品的数量<br>注意：</p>
<ol>
<li>primary key是unique的</li>
<li>foreign key我们默认是存在的</li>
<li>一般customer与product是多对多的关系，在实际应用中会有一张中间transaction的表</li>
</ol>
<h4 id="示例代码-mysql"><a href="#示例代码-mysql" class="headerlink" title="示例代码 (mysql)"></a>示例代码 (mysql)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> customer_id </span><br><span class="line"><span class="keyword">from</span> Customer</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> customer_id</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">count</span>(<span class="keyword">distinct</span>(product_key)) = (<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> Product);</span><br></pre></td></tr></table></figure>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/hSQPifBvQO4" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1046] Last Stone Weight</title>
    <url>/Leetcode-1046-Last-Stone-Weight/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">We have a collection of stones, each stone&nbsp;has a positive integer weight.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Each turn, we choose the two&nbsp;<span style="font-weight: bolder;">heaviest</span>&nbsp;stones&nbsp;and smash them together.&nbsp; Suppose the stones have weights&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">y</code>&nbsp;with&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x &lt;= y</code>.&nbsp; The result of this smash is:</p><ul style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li>If&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x == y</code>, both stones are totally destroyed;</li><li>If&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x != y</code>, the stone of weight&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x</code>&nbsp;is totally destroyed, and the stone of weight&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">y</code>&nbsp;has new weight&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">y-x</code>.</li></ul><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">At the end, there is at most 1 stone left.&nbsp; Return the weight of this stone (or 0 if there are no stones left.)</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>[2,7,4,1,8,1]<br><span style="font-weight: bolder;">Output: </span>1<br><span style="font-weight: bolder;">Explanation: </span><br>We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,<br>we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,<br>we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,<br>we combine 1 and 1 to get 0 so the array converts to [1] then that’s the value of last stone.</pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= stones.length &lt;= 30</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= stones[i] &lt;= 1000</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求每次取出当前石头堆中最大的两个，若它们相同，则直接销毁，若不同，则将一块重量等于它们差值的石头放入堆中。如此反复，直到最后至多只有一块石头。返回这块石头的重量，如果没有石头，返回<code>0</code>。</p>
<p>既然每次都要取出最大的两个数，我们自然想到利用最大堆来维护数据。现将所有石头放入最大堆中，然后每次取出堆顶两个数进行操作。直到堆的规模小于等于<code>1</code>。如果等于<code>1</code>，返回堆顶元素，否则返回<code>0</code>。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; stone : stones) &#123;</span><br><span class="line">            pq.push(stone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (pq.size() &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> t1 = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">int</span> t2 = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span> (t1 != t2) &#123;</span><br><span class="line">                pq.push(t1 - t2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pq.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pq.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeight</span><span class="params">(<span class="keyword">int</span>[] stones)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b)-&gt; b - a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : stones)</span><br><span class="line">            pq.offer(a);</span><br><span class="line">        <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>)</span><br><span class="line">            pq.offer(pq.poll() - pq.poll());</span><br><span class="line">        <span class="keyword">return</span> pq.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeight</span><span class="params">(self, stones)</span>:</span></span><br><span class="line">        h = [-x <span class="keyword">for</span> x <span class="keyword">in</span> stones]</span><br><span class="line">        heapq.heapify(h)</span><br><span class="line">        <span class="keyword">while</span> len(h) &gt; <span class="number">1</span> <span class="keyword">and</span> h[<span class="number">0</span>] != <span class="number">0</span>:</span><br><span class="line">            heapq.heappush(h, heapq.heappop(h) - heapq.heappop(h))</span><br><span class="line">        <span class="keyword">return</span> -h[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: 假设一共有<code>N</code>数，建立堆后，每次取出两个数，加入一个数，直到堆得规模小于等于<code>1</code>。一共有<code>2N</code>次删除和<code>N</code>次加入。每次删除时间复杂度是<code>O(logN)</code>, 每次加入是<code>O(1)</code>。所有总的时间复杂度是<code>O(NlogN)</code><br>空间复杂度: <code>O(N)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/jkjG2Xnn-i8" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Greedy</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1047] Remove All Adjacent Duplicates In String</title>
    <url>/Leetcode-1047-Remove-All-Adjacent-Duplicates-In-String/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given a string&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>&nbsp;of lowercase letters, a&nbsp;<em>duplicate removal</em>&nbsp;consists of choosing two adjacent and equal letters, and removing&nbsp;them.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">We repeatedly make duplicate removals on S until we no longer can.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return the final string after all such duplicate removals have been made.&nbsp; It is guaranteed the answer is unique.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-1-1">“abbaca”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">“ca”</span><br><span style="font-weight: bolder;">Explanation: </span><br>For example, in “abbaca” we could remove “bb” since the letters are adjacent and equal, and this is the only possible move.&nbsp; The result of this move is that the string is “aaca”, of which only “aa” is possible, so the final string is “ca”.</pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= S.length &lt;= 20000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>&nbsp;consists only of English lowercase letters.</li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>将需要返回的结果<code>res</code>当做一个stack，遍历<code>S</code><br>每次比较当前的元素<code>ch</code>是否与<code>res</code>最后的元素（即栈顶）相同：<br>如果相同则将<code>res</code>最后的元素pop出去<br>如果不同则在<code>res</code>最后插入当前元素<br>最后返回<code>res</code>即可。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> ch : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!res.empty() &amp;&amp; res.back() == ch) &#123;</span><br><span class="line">                res.pop_back();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicates</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, n = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] res = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j, ++i) &#123;</span><br><span class="line">            res[i] = res[j];</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; res[i - <span class="number">1</span>] == res[i]) <span class="comment">// count = 2</span></span><br><span class="line">                i -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(res, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> res <span class="keyword">and</span> res[<span class="number">-1</span>] == c:</span><br><span class="line">                res.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(res)</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N)</code><br>空间复杂度: <code>O(N)</code> for Cpp and Python solution, <code>O(1)</code> for Java solution.</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/8aBnYfiGU4g" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Bloomberg</tag>
        <tag>Google</tag>
        <tag>Stack</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1048] Longest String Chain</title>
    <url>/Leetcode-1048-Longest-String-Chain/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given a list of words, each word consists of English lowercase letters.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Let’s say&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">word1</code>&nbsp;is a predecessor of&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">word2</code>&nbsp;if and only if we can add exactly one letter anywhere in&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">word1</code>&nbsp;to make it equal to&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">word2</code>.&nbsp; For example,&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">“abc”</code>&nbsp;is a predecessor of&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">“abac”</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">A&nbsp;<em>word chain&nbsp;</em>is a sequence of words&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">[word_1, word_2, …, word_k]</code>&nbsp;with&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">k &gt;= 1</code>,&nbsp;where&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">word_1</code>&nbsp;is a predecessor of&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">word_2</code>,&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">word_2</code>&nbsp;is a predecessor of&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">word_3</code>, and so on.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return the longest possible length of a word chain with words chosen from the given list of&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">words</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-1-1">[“a”,”b”,”ba”,”bca”,”bda”,”bdca”]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">4<br><span style="font-weight: bolder;">Explanation</span>: one of </span>the longest word chain is “a”,”ba”,”bda”,”bdca”.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= words.length &lt;= 1000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= words[i].length &lt;= 16</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">words[i]</code>&nbsp;only consists of English lowercase letters.</li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题可以用动态规划的思路来解。</p>
<p>先将给我们的词按长度从小到大排列，然后用一个哈希表记录能从小到大变化到一个词的最大长度。也就是说，<code>key</code>是一个词，<code>value</code>是从小到大能变换到这个词的最大长度。</p>
<p>我们按词的长度从小到大遍历所有的词，对于每一个词<code>cur</code>，遍历这个词的每一个可能的前一个词<code>prev</code>，若存在在哈希表中，则<code>dp[cur] = max(dp[cur], dp[prev] + 1)</code>。这也就是我们的状态转移方程。</p>
<p>最后我们查找哈希表中的最大值，就是我们要的答案。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// static bool compare(const string &amp;s1, const string &amp;s2) &#123;</span></span><br><span class="line">    <span class="comment">//     return s1.length() &lt; s2.length();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        sort(words.begin(), words.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a, <span class="keyword">const</span> <span class="built_in">string</span>&amp; b)&#123;<span class="keyword">return</span> a.size() &lt; b.size();&#125;);</span><br><span class="line">        <span class="comment">// sort(words.begin(), words.end(), compare);</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; dp;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">string</span>&amp; cur : words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur.length(); i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> prev = cur.substr(<span class="number">0</span>, i) + cur.substr(i + <span class="number">1</span>);</span><br><span class="line">                dp[cur] = max(dp[cur], dp[prev] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, dp[cur]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestStrChain</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; dp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Arrays.sort(words, (a, b)-&gt;a.length() - b.length());</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">int</span> best = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); ++i) &#123;</span><br><span class="line">                String prev = word.substring(<span class="number">0</span>, i) + word.substring(i + <span class="number">1</span>);</span><br><span class="line">                best = Math.max(best, dp.getOrDefault(prev, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp.put(word, best);</span><br><span class="line">            res = Math.max(res, best);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestStrChain</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        dp = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> sorted(words, key=len):</span><br><span class="line">            dp[w] = max(dp.get(w[:i] + w[i + <span class="number">1</span>:], <span class="number">0</span>) + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(w)))</span><br><span class="line">        <span class="keyword">return</span> max(dp.values())</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: 假设一共有<code>N</code>个词，词的平均长度是<code>L</code>，时间复杂度是 <code>O(NlogN + NL^2)</code><br>空间复杂度: <code>O(NL)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/aTKpQecBySQ" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Hash Table</tag>
        <tag>Google</tag>
        <tag>Dynamic Programming</tag>
        <tag>Two Sigma</tag>
        <tag>Citadel</tag>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1049] Last Stone Weight II</title>
    <url>/Leetcode-1049-Last-Stone-Weight-II/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">We have a collection of rocks, each rock has a positive integer weight.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Each turn, we choose&nbsp;<span style="font-weight: bolder;">any two rocks</span>&nbsp;and smash them together.&nbsp; Suppose the stones have weights&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">y</code>&nbsp;with&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x &lt;= y</code>.&nbsp; The result of this smash is:</p><ul style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li>If&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x == y</code>, both stones are totally destroyed;</li><li>If&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x != y</code>, the stone of weight&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x</code>&nbsp;is totally destroyed, and the stone of weight&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">y</code>&nbsp;has new weight&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">y-x</code>.</li></ul><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">At the end, there is at most 1 stone left.&nbsp; Return the&nbsp;<span style="font-weight: bolder;">smallest possible</span>&nbsp;weight of this stone (the weight is&nbsp;0 if there are no stones left.)</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;<span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>[2,7,4,1,8,1]<br><span style="font-weight: bolder;">Output: </span>1<br><span style="font-weight: bolder;">Explanation: </span><br>We can combine 2 and 4 to get 2 so the array converts to [2,7,1,8,1] then,<br>we can combine 7 and 8 to get 1 so the array converts to [2,1,1,1] then,<br>we can combine 2 and 1 to get 1 so the array converts to [1,1,1] then,<br>we can combine 1 and 1 to get 0 so the array converts to [1] then that’s the optimal value.&nbsp;</pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= stones.length &lt;= 30</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= stones[i] &lt;= 100</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>假设有三个石头<code>x1，x2, x3</code>, 无论如何组合，最终都会成为三个数之间的加减法<br>比如如果先合并<code>x1</code>，<code>x2</code>,再与<code>x3</code>合并，则最终的重量为<code>x3 - x1 + x2</code> (假设<code>x1 &gt; x2, x3 &gt; (x1 - x2)</code>)<br>所以这道题相当于将数组分为两组，两组分别求和为<code>S1</code>和<code>S2</code>，并希望其差值(<code>S2 - S1 if S2 &gt;= S1</code>)最小:<br><code>S1 + S2 = total_weight</code><br><code>if S1 &lt;= S2 =&gt; S2 - S1 = total_weight - S1 - S1 = total_weight - 2 * S1</code><br>所以相当于我们希望较小的一半石头的重量和尽可能接近 <code>total_weight / 2</code></p>
<p>我们通过动态规划来求解这道题，建立一个数组<code>dp</code>来记录石头重量之和的所有可能值:<br><code>dp[i]</code>为<code>true</code>如果我们可以使得一组<code>stones</code>的重量之和<code>S1</code>等于<code>i</code>，反之则为<code>false</code><br>我们遍历<code>stones</code>数组，用<code>sum_weight</code>来记录当前遍历到的所有重量之和，<br>我们判断加入当前的石头重量<code>stone_weight</code>后，从<code>sum_weight</code>到<code>stone_weight</code>之间的每一个值<code>weight</code>是否可能成为<code>S1</code>的值：<br>如果<code>dp[weight - stone_weight]</code>为<code>true</code>，则对应的<code>dp[weight]</code>也设为<code>true</code>。<br>遍历<code>stones</code>完成后，从<code>weight = sum_weight / 2</code>开始逐渐减小，如果<code>dp[weight] = true</code>,<br>则当前<code>weight</code>即我们希望寻找的<code>S1</code>的值，所以返回对应的<code>total_weight - 2 * weight</code>即可。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; stones)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于限制条件：</span></span><br><span class="line">        <span class="comment">// 1 &lt;= stones.length &lt;= 30</span></span><br><span class="line">        <span class="comment">// 1 &lt;= stones[i] &lt;= 100</span></span><br><span class="line">        <span class="comment">// 所以石头重量总和最多为 30 * 100 = 3000</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">1501</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> sum_weight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> stone_weight : stones) &#123;</span><br><span class="line">            sum_weight += stone_weight;</span><br><span class="line">            <span class="comment">// 一定要用--，而不是++，不然同一块石头的重量会被视作可以反复利用</span></span><br><span class="line">            <span class="comment">// 比如如果stone_weight = 1, 用++的话，会使得dp的所有小于sum_weight的值都为true</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> weight = sum_weight; weight &gt;= stone_weight; --weight) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[weight - stone_weight]) &#123;</span><br><span class="line">                    dp[weight] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> weight = sum_weight / <span class="number">2</span>; weight &gt;= <span class="number">0</span>; --weight) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[weight]) &#123;</span><br><span class="line">                <span class="keyword">return</span> sum_weight - <span class="number">2</span> * weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">1501</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> sumA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : A) &#123;</span><br><span class="line">            sumA += a;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Math.min(<span class="number">1500</span>, sumA); i &gt;= a; --i)</span><br><span class="line">                dp[i] |= dp[i - a];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sumA / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> (dp[i]) <span class="keyword">return</span> sumA - i - i;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeightII</span><span class="params">(self, stones: List[int])</span> -&gt; int:</span></span><br><span class="line">        dp = &#123;<span class="number">0</span>&#125;</span><br><span class="line">        sumA = sum(stones)</span><br><span class="line">        <span class="keyword">for</span> stone <span class="keyword">in</span> stones:</span><br><span class="line">            dp |= &#123;stone + i <span class="keyword">for</span> i <span class="keyword">in</span> dp&#125;</span><br><span class="line">        <span class="keyword">return</span> min(abs(sumA - i - i) <span class="keyword">for</span> i <span class="keyword">in</span> dp)</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N)</code><br>空间复杂度: <code>O(total_weight)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/oPgLkIwq9l0" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 105] Construct Binary Tree from Preorder and Inorder Traversal</title>
    <url>/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given preorder and inorder traversal of a tree, construct the binary tree.</p>
<p><em>Note</em>:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<pre><code>preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
</code></pre><p>Return the following binary tree:</p>
<pre><code>  3
 / \
9   20
   /  \
  15   7
</code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目给出二叉树的前序遍历与中序遍历，要求重新构建原二叉树，返回根节点。</p>
<p>首先我们需要明确：</p>
<ul>
<li>前序遍历的顺序：中、左、右</li>
<li>中序遍历的顺序：左、中、右</li>
</ul>
<p>因此，我们知道前序遍历序列的第一个元素是原二叉树的根节点，而此根节点将中序遍历分为了左子树的中序遍历与右子树的中序遍历。</p>
<p>根据以上思路，我们可以继续对左右子树的分别进行递归，直到序列为空，重构整个二叉树。</p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param inorder, a list of integers</span></span><br><span class="line">    <span class="comment"># @param postorder, a list of integers</span></span><br><span class="line">    <span class="comment"># @return a tree node</span></span><br><span class="line">    <span class="comment"># 12:00</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder, inorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span> </span><br><span class="line">        dicinorder = &#123;&#125; <span class="comment">#用dictionary记录inoder中value和对应index的关系</span></span><br><span class="line">        <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(inorder):</span><br><span class="line">            dicinorder[val] = i</span><br><span class="line">        start, end = <span class="number">0</span>, len(inorder)</span><br><span class="line">        <span class="keyword">return</span> self.helper(start, end, preorder, dicinorder)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, start, end, preorder, dicinorder)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(preorder.pop(<span class="number">0</span>))</span><br><span class="line">        inorderIndex = dicinorder[root.val]</span><br><span class="line">        root.left = self.helper(start, inorderIndex, preorder, dicinorder)</span><br><span class="line">        root.right = self.helper(inorderIndex+<span class="number">1</span>, end, preorder, dicinorder)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>我们使用一个字典记录<code>inorder</code>数组中value与对应index的关系，这样能快速查找每个value的index，每次查找时间复杂度为O(1)。<br>每个节点重构会被访问一次，一共n个节点。同时字典需要空间<code>O(n)</code>。所以复杂度分析为</p>
<ul>
<li>时间复杂度: <code>O(n)</code></li>
<li>空间复杂度: <code>O(n)</code></li>
</ul>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>此题要求重构二叉树，因此需要理解清楚中序遍历与后序遍历的定义。合理使用递归方法即可完成解题。</p>
<p>大家可以结合利用中序遍历与后序遍历构建二叉树这题，更好的理解问题：</p>
<p><a href="/Leetcode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal">[LeetCode 106] Construct Binary Tree from Inorder and Postorder Traversal</a></p>
<p>大家可以在 <a href="/tags/Tree">Tree Tag</a> 中找到更多和树有关的内容。种香蕉树去了^_^</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>[Leetcode 1050] Actors and Directors Who Cooperated At Least Three Times</title>
    <url>/Leetcode-1050-Actors-and-Directors-Who-Cooperated-At-Least-Three-Times/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p><div class="sql-schema-wrapper__3VBi" style="margin-bottom: 15px; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><a class="sql-schema-link__3cEg" style="color: rgb(96, 125, 139); outline: none; cursor: pointer; transition: border-bottom-color 0.3s ease 0s; touch-action: manipulation; pointer-events: auto; padding-bottom: 1px; border-bottom: 1px solid transparent;">SQL Schema<svg viewbox="0 0 24 24" width="1em" height="1em" class="icon__3Su4"><path fill-rule="evenodd" d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg></a></div><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">ActorDirector</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| actor_id    | int     |<br>| director_id | int     |<br>| timestamp   | int     |<br>+————-+———+<br>timestamp is the primary key column for this table.<br></pre><p style="font-size: inherit; margin-bottom: 1em;">&nbsp;</p><p style="font-size: inherit; margin-bottom: 1em;">Write a SQL query for a report that provides the pairs&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">(actor_id, director_id)</code>&nbsp;where the actor have cooperated with the director at least 3 times.</p><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">ActorDirector table:<br>+————-+————-+————-+<br>| actor_id    | director_id | timestamp   |<br>+————-+————-+————-+<br>| 1           | 1           | 0           |<br>| 1           | 1           | 1           |<br>| 1           | 1           | 2           |<br>| 1           | 2           | 3           |<br>| 1           | 2           | 4           |<br>| 2           | 1           | 5           |<br>| 2           | 1           | 6           |<br>+————-+————-+————-+</pre></div></p>
<p>Result table:<br>+————-+————-+<br>| actor_id    | director_id |<br>+————-+————-+<br>| 1           | 1           |<br>+————-+————-+<br>The only pair is (1, 1) where they cooperated exactly 3 times.<br><a id="more"></a></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们需要找出一起至少合作过3次的演员和导演。</p>
<ol>
<li>对二元组(演员,导演)分组，分别计算每组个数，选出每组个数&gt;=3的行。</li>
<li>这里我们需要应用<code>group by</code>语法和<code>count</code>函数。</li>
</ol>
<h4 id="示例代码-mysql"><a href="#示例代码-mysql" class="headerlink" title="示例代码 (mysql)"></a>示例代码 (mysql)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.actor_id, A.director_id</span><br><span class="line"><span class="keyword">FROM</span> ActorDirector <span class="keyword">AS</span> A</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> A.actor_id, A.director_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;= <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/MwkBrrzEibk" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1051] Height Checker</title>
    <url>/Leetcode-1051-Height-Checker/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Students are asked to stand in non-decreasing order of heights for an annual photo.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Notice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students&nbsp;remain on their seats.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;<span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input:</span> heights = [1,1,4,2,1,3]<br><span style="font-weight: bolder;">Output:</span> 3<br><span style="font-weight: bolder;">Explanation:</span><br>Current array : [1,1,4,2,1,3]<br>Target array  : [1,1,1,2,3,4]<br>On index 2 (0-based) we have 4 vs 1 so we have to move this student.<br>On index 4 (0-based) we have 1 vs 3 so we have to move this student.<br>On index 5 (0-based) we have 3 vs 4 so we have to move this student.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input:</span> heights = [5,1,2,3,4]<br><span style="font-weight: bolder;">Output:</span> 5<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input:</span> heights = [1,2,3,4,5]<br><span style="font-weight: bolder;">Output:</span> 0<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Constraints:</span><br></p><ul style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= heights.length &lt;= 100</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= heights[i] &lt;= 100</code></li></ul><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题可以有很多做法。最高效的方法是：<br>建立一个数组<code>height_to_num</code>, 其<code>index</code>为<code>height</code>，对应的值为<code>height</code>出现的次数，该数组可替代排序<br>遍历一遍<code>heights</code>数组来更新<code>height_to_num</code>。<br>然后再遍历一遍<code>heights</code>数组，同时从<code>height_to_num</code>中找到排序后的高度<code>sort_height</code>,<br>比较<code>height</code>和<code>sort_height</code>, 如果不同则返回结果<code>+1</code>。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Use height as vector index to aovid sorting</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; height_to_num = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">101</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> height : heights) &#123;</span><br><span class="line">            height_to_num[height]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> switch_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sort_height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> height : heights) &#123;</span><br><span class="line">            <span class="keyword">while</span> (height_to_num[sort_height] == <span class="number">0</span>) &#123;</span><br><span class="line">                ++sort_height;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sort_height != height) &#123;</span><br><span class="line">                ++switch_count;</span><br><span class="line">            &#125;</span><br><span class="line">            height_to_num[sort_height]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> switch_count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// use sort </span></span><br><span class="line">    <span class="comment">// O(nlogn)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> original_heights = heights;</span><br><span class="line">        sort(heights.begin(), heights.end());</span><br><span class="line">        <span class="keyword">int</span> switch_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] != original_heights[i]) &#123;</span><br><span class="line">                ++switch_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> switch_count;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// use priority queue </span></span><br><span class="line">    <span class="comment">// O(nlogn)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq(heights.begin(), heights.end());</span><br><span class="line">        <span class="keyword">int</span> switch_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> height : heights) &#123;</span><br><span class="line">            <span class="keyword">int</span> sort_height = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span> (sort_height != height) &#123;</span><br><span class="line">                ++switch_count;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> switch_count;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">heightChecker</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] heightToFreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">101</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> height : heights) &#123;</span><br><span class="line">            heightToFreq[height]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curHeight = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; heights.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (heightToFreq[curHeight] == <span class="number">0</span>) &#123;</span><br><span class="line">                curHeight++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (curHeight != heights[i]) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            heightToFreq[curHeight]--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">heightChecker</span><span class="params">(self, heights: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum(h1 != h2 <span class="keyword">for</span> h1, h2 <span class="keyword">in</span> zip(heights, sorted(heights)))</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N)</code><br>空间复杂度: <code>O(height)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/qrfuxwcpJzY" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1052] Grumpy Bookstore Owner</title>
    <url>/Leetcode-1052-Grumpy-Bookstore-Owner/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Today, the bookstore owner has a store open for&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">customers.length</code>&nbsp;minutes.&nbsp; Every minute, some number of customers (<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">customers[i]</code>) enter the store, and all those customers leave after the end of that minute.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">On some minutes, the bookstore owner is grumpy.&nbsp; If the bookstore owner is grumpy on the i-th minute,&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">grumpy[i] = 1</code>, otherwise&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">grumpy[i] = 0</code>.&nbsp; When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">The bookstore owner knows a secret technique to keep themselves&nbsp;not grumpy for&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">X</code>&nbsp;minutes straight, but can only use it once.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return the maximum number of customers that can be satisfied throughout the day.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3<br><span style="font-weight: bolder;">Output: </span>16<br><span style="font-weight: bolder;">Explanation:</span>&nbsp;The bookstore owner keeps themselves&nbsp;not grumpy for the last 3 minutes.<br>The maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ul style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= X &lt;=&nbsp;customers.length ==&nbsp;grumpy.length &lt;= 20000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0 &lt;=&nbsp;customers[i] &lt;= 1000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0 &lt;=&nbsp;grumpy[i] &lt;= 1</code></li></ul><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目给出每分钟顾客的数目和对应的老板的状态， 如果老板<code>grumpy</code>,那么那时候的顾客都不满意，否则满意。因此那个时刻满意的人数是<code>customer[i] * (1-grumpy[i])</code>。同时，给出时间<code>X</code>，老板可以主动控制住在某个连续的<code>X</code>时间段内不<code>grumpy</code>。要求我们求出最大的顾客满意人数。</p>
<p>首先，如果<code>X</code>大于整个时间段，那么老板在任意时刻都是不<code>grumpy</code>的，简单吧所有顾客人数相加就可以。</p>
<p>若<code>X</code>小于整个时间段，我们需要找到某个<code>X</code>时间段：在这一时间段中，能保障老板让最多数量的顾客从不满意转换为满意。因为<code>X</code>是连续的，所以我们可以用<code>sliding window</code>的方法找到这个<code>X</code>对应的最大转换数。最后加上<code>X</code>不存在时，顾客的满意数，就是我们要的答案。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; customers, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> delta = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; customers.size(); ++i) &#123;</span><br><span class="line">            total += customers[i] * (<span class="number">1</span> - grumpy[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tmpDelta = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> end = <span class="number">0</span>; end &lt; customers.size(); end++) &#123;</span><br><span class="line">            tmpDelta += grumpy[end] * customers[end];</span><br><span class="line">            delta = max(delta, tmpDelta);</span><br><span class="line">            <span class="keyword">if</span> (end - start + <span class="number">1</span> == X) &#123;</span><br><span class="line">                tmpDelta -= grumpy[start] * customers[start];</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> delta + total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="keyword">int</span>[] customers, <span class="keyword">int</span>[] grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> satisfied = <span class="number">0</span>, maxMakeSatisfied = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, winOfMakeSatisfied = <span class="number">0</span>; i &lt; grumpy.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grumpy[i] == <span class="number">0</span>) &#123; satisfied += customers[i]; &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; winOfMakeSatisfied += customers[i]; &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= X) &#123;</span><br><span class="line">                winOfMakeSatisfied -= grumpy[i - X] * customers[i - X];</span><br><span class="line">            &#125;</span><br><span class="line">            maxMakeSatisfied = Math.max(winOfMakeSatisfied, maxMakeSatisfied);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> satisfied + maxMakeSatisfied;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSatisfied</span><span class="params">(self, customers: List[int], grumpy: List[int], X: int)</span> -&gt; int:</span></span><br><span class="line">        i = win_of_make_satisfied = satisfied = max_make_satisfied = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c, g <span class="keyword">in</span> zip(customers, grumpy):</span><br><span class="line">            satisfied += (<span class="number">1</span> - g) * c</span><br><span class="line">            win_of_make_satisfied += g * c</span><br><span class="line">            <span class="keyword">if</span> i &gt;= X:</span><br><span class="line">                win_of_make_satisfied -= grumpy[i - X] * customers[i - X]</span><br><span class="line">            max_make_satisfied = max(win_of_make_satisfied, max_make_satisfied)  </span><br><span class="line">            i += <span class="number">1</span>    </span><br><span class="line">        <span class="keyword">return</span> satisfied + max_make_satisfied</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(n)<br>空间复杂度: O(1)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/YdWIatSUiaI" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>[Leetcode 1053]Previous Permutation With One Swap</title>
    <url>/Leetcode-1053-Previous-Permutation-With-One-Swap/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given an array&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A</code>&nbsp;of positive integers (not necessarily distinct), return the lexicographically largest permutation that is smaller than&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A</code>, that can be&nbsp;<span style="font-weight: bolder;">made with one swap</span>&nbsp;(A&nbsp;<em>swap</em>&nbsp;exchanges the positions of two numbers&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A[i]</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A[j]</code>).&nbsp; If it cannot be done, then return the same array.&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>[3,2,1]<br><span style="font-weight: bolder;">Output: </span>[3,1,2]<br><span style="font-weight: bolder;">Explanation: </span>Swapping 2 and 1.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>[1,1,5]<br><span style="font-weight: bolder;">Output: </span>[1,1,5]<br><span style="font-weight: bolder;">Explanation: </span>This is already the smallest permutation.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>[1,9,4,6,7]<br><span style="font-weight: bolder;">Output: </span>[1,7,4,6,9]<br><span style="font-weight: bolder;">Explanation: </span>Swapping 9 and 7.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 4:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>[3,1,1,3]<br><span style="font-weight: bolder;">Output: </span>[1,3,1,3]<br><span style="font-weight: bolder;">Explanation: </span>Swapping 1 and 3.</pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= A.length &lt;= 10000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= A[i] &lt;= 10000</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们找到A当中需要交换的位置<code>left</code>和<code>right</code>：<br>left的位置应当尽量往右：应当为<code>A</code>从右往左第一个变大的位置，因为其右边肯定有比其小的值了。<br>找到<code>left</code>的位置后，<code>right</code>应当是<code>left</code>右侧最大的数：<br>由于<code>left</code>右侧为从右往左递减的序列（从左往右递增），所以需要从右往左找到第一个大于<code>A[left]</code>的数<code>A[right]</code>。<br>如果<code>A[right]</code>有连续相同的数，比如<code>[3, 1, 1, 3]</code>中中间连续的1，那么我们希望<code>right</code>指向最左侧的那个1。<br>所以我们还需要继续将<code>right</code>向左移直到<code>A[right] != A[right - 1]</code>。<br>此时交换<code>A[right]</code>与<code>A[left]</code>，并返回<code>A</code>即可。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prevPermOpt1</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到从右往左第一个增大的位置left, 比如[3 1 1 3]中index 0</span></span><br><span class="line">        <span class="keyword">int</span> left = A.size() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; A[left] &lt;= A[left + <span class="number">1</span>]) &#123;</span><br><span class="line">            --left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到left右侧，从右往左第一个比A[left]小的位置right，比如[3 1 1 3]中index 2</span></span><br><span class="line">        <span class="keyword">int</span> right = A.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (A[right] &gt;= A[left]) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从A[right]开始向左，最左边的连续与A[right]相同的位置，比如 [3 1 1 3]中index 1</span></span><br><span class="line">        <span class="keyword">while</span> (A[right] == A[right - <span class="number">1</span>]) &#123;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(A[left], A[right]);</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] prevPermOpt1(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">        <span class="comment">// 1. 边界情况处理</span></span><br><span class="line">        <span class="keyword">if</span> (A.length == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2. 找左边要交换的位置</span></span><br><span class="line">        <span class="keyword">int</span> left = A.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[left] &gt; A[left + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left--;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2.1 如果一直递减</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> A;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 3. 找右边 第一个小于 left 的值</span></span><br><span class="line">        <span class="keyword">int</span> right = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (A[right] &gt;= A[left]) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 4. 向左错位，如果 right 的左边 跟 right 一样</span></span><br><span class="line">        <span class="keyword">int</span> rightValue = A[right];</span><br><span class="line">        <span class="keyword">while</span> (A[right] == rightValue) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 5. 交换</span></span><br><span class="line">        <span class="keyword">int</span> temp = A[left];</span><br><span class="line">        A[left] = A[right];</span><br><span class="line">        A[right] = temp;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prevPermOpt1</span><span class="params">(self, A: List[int])</span> -&gt; List[int]:</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 1. 边界情况处理</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 2. 找左边要交换的位置</span></span><br><span class="line">        left = len(A) - <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &gt;= <span class="number">0</span> :</span><br><span class="line">            <span class="keyword">if</span> A[left] &gt; A[left + <span class="number">1</span>] :</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            left -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="comment"># 2.1 如果一直递减</span></span><br><span class="line">            <span class="keyword">return</span> A</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 3. 找右边 第一个小于 left 的值</span></span><br><span class="line">        right = len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> A[right] &gt;= A[left] :</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 4. 向左错位，如果 right 的左边 跟 right 一样</span></span><br><span class="line">        right_value = A[right]</span><br><span class="line">        <span class="keyword">while</span> (A[right] == right_value) :</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        right += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 5. 交换</span></span><br><span class="line">        A[left], A[right] = A[right], A[left]</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/5O0erD3KHCU" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Array</tag>
        <tag>Greedy</tag>
        <tag>Quora</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1054] Distant Barcodes</title>
    <url>/Leetcode-1054-Distant-Barcodes/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">In a warehouse, there is a row of barcodes, where the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">i</code>-th barcode is&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">barcodes[i]</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Rearrange the barcodes so that no two adjacent barcodes are equal.&nbsp; You may return any answer, and it is guaranteed an answer exists.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-1-1">[1,1,1,2,2,2]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">[2,1,2,1,2,1]</span><br></pre><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-2-1">[1,1,1,1,2,2,3,3]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">[1,3,1,3,2,1,2,1]</span></pre></div><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= barcodes.length &lt;= 10000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= barcodes[i] &lt;= 10000</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求将给定的数组重新排列，排列后的数组，相同的数不再相邻，并且保证一定存在解。</p>
<p>这题因为一定存在解，我们可以用贪心的算法重排数组。先计算每个数据出现次的频率。每次取出频率最高的两个数据，比较哪个可以放入当前新的数组中，并更新数据出现的频率。直到安排完所有的数据。</p>
<p>因为每次都要取出频率最高的两个数据，所以我们选择使用优先队列<code>heap</code>来储存数据。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; p1, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; p2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.second &lt; p2.second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rearrangeBarcodes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; barcodes)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;, cmp&gt; pq;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dict;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; barcode : barcodes) &#123;</span><br><span class="line">            dict[barcode]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; ele : dict) &#123;</span><br><span class="line">            pq.push(&#123;ele.first, ele.second&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> p1 = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            <span class="keyword">if</span> (ans.size() == <span class="number">0</span> || ans.back() != p1.first) &#123;</span><br><span class="line">                ans.emplace_back(p1.first);</span><br><span class="line">                <span class="keyword">if</span> (p1.second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    pq.push(&#123;p1.first, p1.second - <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                assert(!pq.empty());</span><br><span class="line">                <span class="keyword">auto</span> p2 = pq.top();</span><br><span class="line">                pq.pop();</span><br><span class="line">                ans.emplace_back(p2.first);</span><br><span class="line">                <span class="keyword">if</span> (p2.second &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    pq.push(&#123;p2.first, p2.second - <span class="number">1</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                pq.push(p1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] rearrangeBarcodes(<span class="keyword">int</span>[] barcodes) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : barcodes) cnt.put(i, cnt.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(cnt.entrySet());</span><br><span class="line">        Collections.sort(list, Map.Entry.&lt;Integer, Integer&gt;comparingByValue().reversed());</span><br><span class="line">        <span class="keyword">int</span> l = barcodes.length, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[l];</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; e : list) &#123;</span><br><span class="line">            <span class="keyword">int</span> time = e.getValue();</span><br><span class="line">            <span class="keyword">while</span> (time-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res[i] = e.getKey();</span><br><span class="line">                i += <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= barcodes.length) i = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rearrangeBarcodes</span><span class="params">(self, packages)</span>:</span></span><br><span class="line">        i, n = <span class="number">0</span>, len(packages)</span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> collections.Counter(packages).most_common():</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(v):</span><br><span class="line">                res[i] = k</span><br><span class="line">                i += <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> i &gt;= n: i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(nlogn)<br>空间复杂度: O(1)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/uE2Ai-VRy6M" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>[Leetcode 1055]Shortest Way to Form String</title>
    <url>/Leetcode-1055-Shortest-Way-to-Form-String/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">From any string, we can form a&nbsp;<i>subsequence</i>&nbsp;of that string by deleting some number of characters (possibly no deletions).</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given two strings&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">source</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">target</code>, return the minimum number of subsequences of&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">source</code>&nbsp;such that their concatenation equals&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">target</code>. If the task is impossible, return&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">-1</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>source = <span id="example-input-1-1">“abc”</span>, target = <span id="example-input-1-2">“abcbc”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">2</span><br><span style="font-weight: bolder;">Explanation: </span>The target “abcbc” can be formed by “abc” and “bc”, which are subsequences of source “abc”.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>source = <span id="example-input-2-1">“abc”</span>, target = <span id="example-input-2-2">“acdbc”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">-1</span><br><span style="font-weight: bolder;">Explanation: </span>The target string cannot be constructed from the subsequences of source string due to the character “d” in target string.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>source = <span id="example-input-3-1">“xyz”</span>, target = <span id="example-input-3-2">“xzyxz”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">3</span><br><span style="font-weight: bolder;">Explanation: </span>The target string can be constructed as follows “xz” + “y” + “xz”.</pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Constraints:</span></p><ul style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li>Both the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">source</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">target</code>&nbsp;strings consist of only lowercase English letters from “a”-“z”.</li><li>The lengths of&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">source</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">target</code>&nbsp;string are between&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1000</code>.</li></ul><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p><code>O(MN)</code>的解法较为直观，只需要用两个<code>index</code> <code>i</code>和<code>j</code>分别对应<code>source</code>和<code>target</code>的位置，然后对于每一个<code>target[j]</code>,在<code>source</code>中找到对应的<code>source[i]</code>, 并于每次i归零时计数即可。<br>这里介绍<code>O(M + N)</code>的解法：用一个二维哈希表（或者二维数组）<code>index_to_next</code>来表示当前<code>source</code>的<code>index</code>右边（包括<code>index</code>本身), 每一个字母第一次出现的位置的下一个位置。比如<code>abbc</code>，那么<code>index[0][&#39;a&#39;] = 1, index[0][&#39;b&#39;] = 2, index[1][&#39;b&#39;] = 2, index[2][&#39;b&#39;] = 3...</code><br>从右向左遍历一遍<code>source</code>即可完成更新<code>index_to_next</code>, 然后遍历<code>target</code>，<code>source</code>和<code>target</code>的位置分别记为<code>i</code>和<code>j</code>，我们执行以下操作：</p>
<ol>
<li><code>index_to_next[0]</code>当中是否存在<code>target[j]</code>，即整个<code>source</code>中是否存在<code>j</code>，不存在则返回<code>-1</code></li>
<li><code>index_to_next[i]</code>当中是否存在<code>target[j]</code>，如果不存在，说明<code>source</code>在位置<code>i</code>右侧不存在<code>target[j]</code>，<code>i</code>应当归零从头开始找</li>
<li>如果<code>i == 0</code>，说明<code>source</code>被遍历了一边，返回值<code>round</code>应该增加1</li>
<li>更新<code>i = index_to_next[i][target[i]]</code> 即<code>source</code>中<code>i</code>右侧第一个<code>target[j]</code>的右侧的位置，这样相当于在<code>source</code>中读取了一个最近的<code>target[i]</code><br>最后返回<code>round</code>即可。</li>
</ol>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(<span class="built_in">string</span> source, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一个int：source当前index</span></span><br><span class="line">        <span class="comment">// 第二个int：souce中读取对应的char后，下一个index</span></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt;&gt; index_to_next;</span><br><span class="line">        index_to_next[source.size() - <span class="number">1</span>][source.back()] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = source.size() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            index_to_next[i] = index_to_next[i + <span class="number">1</span>];</span><br><span class="line">            index_to_next[i][source[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> round = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; target.size(); ++j) &#123;</span><br><span class="line">            <span class="comment">// 整个source中都没有target[j]，直接返回-1</span></span><br><span class="line">            <span class="keyword">if</span> (index_to_next[<span class="number">0</span>].count(target[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前source的位置i往后找不到target[j], 则应该将i归零重头开始找</span></span><br><span class="line">            <span class="keyword">if</span> (index_to_next[i].count(target[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                ++round;</span><br><span class="line">            &#125;</span><br><span class="line">            i = index_to_next[i][target[j]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> round;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestWay</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] cs = source.toCharArray(), ts = target.toCharArray();</span><br><span class="line">    <span class="keyword">int</span>[][] idx = <span class="keyword">new</span> <span class="keyword">int</span>[cs.length][<span class="number">26</span>];</span><br><span class="line">    idx[cs.length - <span class="number">1</span>][cs[cs.length - <span class="number">1</span>] - <span class="string">'a'</span>] = cs.length; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cs.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        idx[i] = Arrays.copyOf(idx[i + <span class="number">1</span>],<span class="number">26</span>);</span><br><span class="line">        idx[i][cs[i] - <span class="string">'a'</span>] = i + <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ts.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == cs.length) &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        j = idx[j][ts[i] - <span class="string">'a'</span>];</span><br><span class="line">        <span class="keyword">if</span> (idx[<span class="number">0</span>][ts[i] - <span class="string">'a'</span>] == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            res++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># two pointer greedy O(MN)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestWay</span><span class="params">(self, source: str, target: str)</span> -&gt; int:</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        t_p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> t_p &lt; len(target):</span><br><span class="line">            s_p = <span class="number">0</span></span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">while</span> s_p &lt; len(source) <span class="keyword">and</span> t_p &lt; len(target):</span><br><span class="line">                <span class="keyword">if</span> source[s_p] == target[t_p]:</span><br><span class="line">                    s_p += <span class="number">1</span></span><br><span class="line">                    t_p +=<span class="number">1</span></span><br><span class="line">                    flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    s_p +=<span class="number">1</span></span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> flag == <span class="literal">True</span>:</span><br><span class="line">                num +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> num </span><br><span class="line"></span><br><span class="line"><span class="comment"># binary search O(NlogM)  </span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestWay</span><span class="params">(self, source: str, target: str)</span> -&gt; int:</span></span><br><span class="line">        dic = defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> ind, char <span class="keyword">in</span> enumerate(source):</span><br><span class="line">            dic[char].append(ind)</span><br><span class="line">        </span><br><span class="line">        ind = <span class="number">0</span></span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> target:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ind, ans= self.binarysearch(source, char, ind, dic, ans)</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarysearch</span><span class="params">(self, source, char, ind, dic, ans)</span>:</span></span><br><span class="line">        lis = dic[char]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> lis[<span class="number">-1</span>] &lt; ind:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            ind = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(lis)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            mid = (l+r)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> lis[mid] &lt; ind:</span><br><span class="line">                l = mid +<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> lis[l]+<span class="number">1</span>, ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(N + M) char to index</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestWay</span><span class="params">(self, source: str, target: str)</span> -&gt; int:</span></span><br><span class="line">        source_set = set(source)</span><br><span class="line">        </span><br><span class="line">        lis = [[<span class="number">-1</span>]*len(source) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">26</span>)]</span><br><span class="line">        <span class="keyword">for</span> ind, char <span class="keyword">in</span> enumerate(source):</span><br><span class="line">            lis[ord(char)- ord(<span class="string">'a'</span>)][ind] = ind</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> lis:</span><br><span class="line">            pre = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> l[i] != <span class="number">-1</span>:</span><br><span class="line">                    pre = l[i]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l[i] = pre</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        ind = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> target:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> source_set:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> ind &gt;= len(source):</span><br><span class="line">                ind = <span class="number">0</span></span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            ind = lis[ord(char) - ord(<span class="string">'a'</span>)][ind]</span><br><span class="line">            <span class="keyword">if</span> ind == <span class="number">-1</span>:</span><br><span class="line">                ind = lis[ord(char) - ord(<span class="string">'a'</span>)][<span class="number">0</span>]  </span><br><span class="line">                ans += <span class="number">1</span></span><br><span class="line">            ind +=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># O(N + M)index to char</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestWay</span><span class="params">(self, source: str, target: str)</span> -&gt; int:</span></span><br><span class="line">        source_set = set(source)</span><br><span class="line">        </span><br><span class="line">        lis = [[<span class="number">-1</span>]*<span class="number">26</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(source))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(lis)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == len(lis)<span class="number">-1</span>:</span><br><span class="line">                lis[i][ord(source[i]) - ord(<span class="string">'a'</span>)] = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lis[i][:] = lis[i+<span class="number">1</span>]</span><br><span class="line">                lis[i][ord(source[i])-ord(<span class="string">'a'</span>)] = i </span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        ind = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> target:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> source_set:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> ind &gt;= len(lis):</span><br><span class="line">                ind = <span class="number">0</span> </span><br><span class="line">                ans +=<span class="number">1</span></span><br><span class="line">                </span><br><span class="line">            ind = lis[ind][ord(char)-ord(<span class="string">'a'</span>)]</span><br><span class="line">            <span class="keyword">if</span> ind == <span class="number">-1</span>:</span><br><span class="line">                ans +=<span class="number">1</span></span><br><span class="line">                ind = <span class="number">0</span></span><br><span class="line">                ind = lis[ind][ord(char)-ord(<span class="string">'a'</span>)]</span><br><span class="line">            </span><br><span class="line">            ind +=<span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(M + N)</code><br>空间复杂度: <code>O(M)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/vxuKSdiu-8U" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Dynamic Programming</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1056] Confusing Number</title>
    <url>/Leetcode-1056-Confusing-Number/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given a number&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">N</code>, return&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">true</code>&nbsp;if and only if it is a&nbsp;<em>confusing number</em>, which satisfies the following condition:</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">We can rotate digits by 180 degrees to form new digits. When 0, 1, 6, 8, 9 are rotated 180 degrees, they become 0, 1, 9, 8, 6 respectively. When 2, 3, 4, 5 and 7 are rotated 180 degrees, they become invalid. A&nbsp;<em>confusing number</em>&nbsp;is a number that when rotated 180 degrees becomes a&nbsp;<span style="font-weight: bolder;">different</span>&nbsp;number with each digit valid.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/23/1268_1.png" style="border-style: none; max-width: 100%; height: 90px; width: 180px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-1-1">6</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">true</span><br><span style="font-weight: bolder;">Explanation: </span><br>We get <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">9</code> after rotating <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">6</code>, <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">9</code> is a valid number and <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">9!=6</code>.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/23/1268_2.png" style="border-style: none; max-width: 100%; height: 90px; width: 180px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-2-1">89</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">true</span><br><span style="font-weight: bolder;">Explanation: </span><br>We get <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">68</code> after rotating <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">89</code>, <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">86</code> is a valid number and <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">86!=89</code>.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 3:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/26/1268_3.png" style="border-style: none; max-width: 100%; height: 121px; width: 301px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-3-1">11</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">false</span><br><span style="font-weight: bolder;">Explanation: </span><br>We get <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">11</code> after rotating <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">11</code>, <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">11</code> is a valid number but the value remains the same, thus <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">11</code> is not a confusing number.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 4:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/23/1268_4.png" style="border-style: none; max-width: 100%; height: 90px; width: 180px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-4-1">25</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-4">false</span><br><span style="font-weight: bolder;">Explanation: </span><br>We get an invalid number after rotating <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">25</code>.</pre><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们用哈希表保存每个可以翻转的字符翻转后对应的字符，然后对每一位数字进行翻转，检查翻转后的数字和原来的数字是否相等即可。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; dict = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">6</span>,<span class="number">9</span>&#125;,&#123;<span class="number">8</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">confusingNumber</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rotate = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> init = N;</span><br><span class="line">        <span class="keyword">while</span> (init != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> digit  = init % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dict.count(digit)) &#123;</span><br><span class="line">            	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rotate = rotate * <span class="number">10</span> + dict[digit];</span><br><span class="line">            init = init / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> postNum != N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">confusingNumber</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        map.put(<span class="number">6</span>, <span class="number">9</span>);</span><br><span class="line">        map.put(<span class="number">9</span>, <span class="number">6</span>);</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        map.put(<span class="number">8</span>, <span class="number">8</span>); </span><br><span class="line">        <span class="keyword">int</span> newNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> x = N;</span><br><span class="line">        <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> remainder = x % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(remainder)) </span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(newNum &gt; Integer.MAX_VALUE/<span class="number">10</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            newNum = newNum * <span class="number">10</span> + map.get(remainder);</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> N == newNum? <span class="keyword">false</span>: <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">confusingNumber</span><span class="params">(self, N: int)</span> -&gt; bool:</span></span><br><span class="line">        S = str(N)</span><br><span class="line">        rotation = &#123;<span class="string">"0"</span> : <span class="string">"0"</span>, <span class="string">"1"</span> : <span class="string">"1"</span>, <span class="string">"6"</span> : <span class="string">"9"</span>, <span class="string">"8"</span> : <span class="string">"8"</span>, <span class="string">"9"</span> : <span class="string">"6"</span>&#125;</span><br><span class="line">        result = []        </span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> S[::<span class="number">-1</span>]:           <span class="comment"># iterate in reverse</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> rotation:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            result.append(rotation[c])                </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(result) != S</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(N)<br>空间复杂度: O(1)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/pt7p6WZL0cM" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1057] Campus Bikes</title>
    <url>/Leetcode-1057-Campus-Bikes/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">On a campus represented as a 2D grid, there are&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">N</code>&nbsp;workers and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">M</code>&nbsp;bikes, with&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">N &lt;= M</code>. Each worker and bike is a 2D coordinate on this grid.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Our goal is to assign a bike to each worker. Among the available bikes and workers, we choose the (worker, bike) pair with the shortest Manhattan distance between each other, and assign the bike to that worker. (If there are multiple (worker, bike) pairs with the same shortest Manhattan distance, we choose the pair with the smallest worker index; if there are multiple ways to do that, we choose the pair with the smallest bike index). We repeat this process until there are no available workers.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">The Manhattan distance between two points&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">p1</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">p2</code>&nbsp;is&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return a vector&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">ans</code>&nbsp;of length&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">N</code>, where&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">ans[i]</code>&nbsp;is the index (0-indexed) of the bike that the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">i</code>-th worker is assigned to.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/06/1261_example_1_v2.png" style="border-style: none; max-width: 100%; height: 264px; width: 264px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>workers = <span id="example-input-1-1">[[0,0],[2,1]]</span>, bikes = <span id="example-input-1-2">[[1,2],[3,3]]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">[1,0]</span><br><span style="font-weight: bolder;">Explanation: </span><br>Worker 1 grabs Bike 0 as they are closest (without ties), and Worker 0 is assigned Bike 1. So the output is [1, 0].<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/06/1261_example_2_v2.png" style="border-style: none; max-width: 100%; height: 264px; width: 264px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>workers = <span id="example-input-2-1">[[0,0],[1,1],[2,0]]</span>, bikes = <span id="example-input-2-2">[[1,0],[2,2],[2,1]]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">[0,2,1]</span><br><span style="font-weight: bolder;">Explanation: </span><br>Worker 0 grabs Bike 0 at first. Worker 1 and Worker 2 share the same distance to Bike 2, thus Worker 1 is assigned to Bike 2, and Worker 2 will take Bike 1. So the output is [0,2,1].</pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0 &lt;= workers[i][j], bikes[i][j] &lt; 1000</code></li><li>All worker and bike locations are distinct.</li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= workers.length &lt;= bikes.length &lt;= 1000</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题首先可以肯定是要遍历每一对可能的<code>worker</code>和<code>bike</code>，计算其距离<br>如果用priority queue，在pop出来的时候时间复杂度是<code>MNlog(MN)</code>的，这里由于距离最大是<code>2000</code>，<br>所以可以考虑用一个数组<code>buckets</code>来存储每一个距离对应的worker bike组合<br>即：<code>buckets[i]</code>对应所有距离为<code>i</code>的<code>WorkerBikePair</code>。<br>遍历一遍<code>workers</code>和<code>bikes</code>，更新<code>buckets</code>。<br>然后：</p>
<ol>
<li>用一个数组<code>bike_used</code>记录对应的<code>bike</code>是否被访问过。</li>
<li>将需要返回的数组记为<code>results</code>,初始化为<code>-1</code>，这样<code>results</code>本身可以用来记录对应的<code>worker</code>是否访问过（<code>-1</code>则未被访问过）</li>
<li>按顺序遍历<code>buckets</code>数组，并更新<code>results</code>和<code>bike_used</code>数组即可。</li>
</ol>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">WorkerBikePair</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> worker;</span><br><span class="line">        <span class="keyword">int</span> bike;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">assignBikes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; workers, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bikes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// vector&lt;WorkerBikePair&gt; in buckets[i] means all worker bike pairs with distance i.</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;WorkerBikePair&gt;&gt; <span class="title">buckets</span><span class="params">(<span class="number">2001</span>, <span class="built_in">vector</span>&lt;WorkerBikePair&gt;())</span></span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workers.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bikes.size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> distance = <span class="built_in">abs</span>(workers[i][<span class="number">0</span>] - bikes[j][<span class="number">0</span>]) + <span class="built_in">abs</span>(workers[i][<span class="number">1</span>] - bikes[j][<span class="number">1</span>]);</span><br><span class="line">                buckets[distance].push_back(WorkerBikePair&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">results</span><span class="params">(workers.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">bike_used</span><span class="params">(bikes.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; worker_bike_pair : bucket) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!bike_used[worker_bike_pair.bike] &amp;&amp; results[worker_bike_pair.worker] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    bike_used[worker_bike_pair.bike] = <span class="literal">true</span>;</span><br><span class="line">                    results[worker_bike_pair.worker] = worker_bike_pair.bike;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] assignBikes(<span class="keyword">int</span>[][] workers, <span class="keyword">int</span>[][] bikes) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = workers.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// order by Distance ASC, WorkerIndex ASC, BikeIndex ASC</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> PriorityQueue&lt;<span class="keyword">int</span>[]&gt;((a, b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> comp = Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (comp == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[<span class="number">1</span>] == b[<span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(a[<span class="number">2</span>], b[<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> Integer.compare(a[<span class="number">1</span>], b[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> comp;</span><br><span class="line">        &#125;);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// loop through every possible pairs of bikes and people,</span></span><br><span class="line">        <span class="comment">// calculate their distance, and then throw it to the pq.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span>[] worker = workers[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; bikes.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[] bike = bikes[j];</span><br><span class="line">                <span class="keyword">int</span> dist = Math.abs(bike[<span class="number">0</span>] - worker[<span class="number">0</span>]) + Math.abs(bike[<span class="number">1</span>] - worker[<span class="number">1</span>]);</span><br><span class="line">                q.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;dist, i, j&#125;); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// init the result array with state of 'unvisited'.</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// assign the bikes.</span></span><br><span class="line">        Set&lt;Integer&gt; bikeAssigned = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (bikeAssigned.size() &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] workerAndBikePair = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (res[workerAndBikePair[<span class="number">1</span>]] == -<span class="number">1</span> </span><br><span class="line">                &amp;&amp; !bikeAssigned.contains(workerAndBikePair[<span class="number">2</span>])) &#123;   </span><br><span class="line">                </span><br><span class="line">                res[workerAndBikePair[<span class="number">1</span>]] = workerAndBikePair[<span class="number">2</span>];</span><br><span class="line">                bikeAssigned.add(workerAndBikePair[<span class="number">2</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">assignBikes</span><span class="params">(self, workers: List[List[int]], bikes: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        distances = []     <span class="comment"># distances[worker] is tuple of (distance, worker, bike) for each bike </span></span><br><span class="line">        <span class="keyword">for</span> i, (x, y) <span class="keyword">in</span> enumerate(workers):</span><br><span class="line">            distances.append([])</span><br><span class="line">            <span class="keyword">for</span> j, (x_b, y_b) <span class="keyword">in</span> enumerate(bikes):</span><br><span class="line">                distance = abs(x - x_b) + abs(y - y_b)</span><br><span class="line">                distances[<span class="number">-1</span>].append((distance, i, j))</span><br><span class="line">            distances[<span class="number">-1</span>].sort(reverse = <span class="literal">True</span>)  <span class="comment"># reverse so we can pop the smallest distance</span></span><br><span class="line">        </span><br><span class="line">        result = [<span class="literal">None</span>] * len(workers)</span><br><span class="line">        used_bikes = set()</span><br><span class="line">        queue = [distances[i].pop() <span class="keyword">for</span> i <span class="keyword">in</span> range(len(workers))]   <span class="comment"># smallest distance for each worker</span></span><br><span class="line">        heapq.heapify(queue)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> len(used_bikes) &lt; len(workers):</span><br><span class="line">            _, worker, bike = heapq.heappop(queue)</span><br><span class="line">            <span class="keyword">if</span> bike <span class="keyword">not</span> <span class="keyword">in</span> used_bikes:</span><br><span class="line">                result[worker] = bike</span><br><span class="line">                used_bikes.add(bike)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(queue, distances[worker].pop())  <span class="comment"># bike used, add next closest bike</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(MN)</code> 如果用priority_queue则为<code>O(MNlog(MN))</code><br>空间复杂度: <code>O(MN)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/21HYbNz15oc" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Facebook</tag>
        <tag>Greedy</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1058] Minimize Rounding Error to Meet Target</title>
    <url>/Leetcode-1058-Minimize-Rounding-Error-to-Meet-Target/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given an array of prices&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">[p<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">1</span>,p<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">2</span>…,p<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">n</span>]</code>&nbsp;and a&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">target</code>, round each price&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">p<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">i</span></code>&nbsp;to&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Round<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">i</span>(p<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">i</span>)</code>&nbsp;so that the rounded array&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">[Round<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">1</span>(p<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">1</span>),Round<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">2</span>(p<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">2</span>)…,Round<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">n</span>(p<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">n</span>)]</code>&nbsp;sums to the given&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">target</code>. Each operation&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Round<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">i</span>(p<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">i</span>)</code>&nbsp;could be either&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Floor(p<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">i</span>)</code>&nbsp;or&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Ceil(p<span style="font-size: 9.75px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">i</span>)</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return the string&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">“-1”</code>&nbsp;if the rounded array is impossible to sum to&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">target</code>. Otherwise, return the smallest rounding error, which is defined as Σ |Round<span style="font-size: 10.5px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">i</span>(p<span style="font-size: 10.5px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">i</span>) - (p<span style="font-size: 10.5px; line-height: 0; position: relative; vertical-align: baseline; bottom: -0.25em;">i</span>)| for&nbsp;<italic>i</italic>&nbsp;from 1 to&nbsp;<italic>n</italic>, as a string with three places after the decimal.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>prices = <span id="example-input-1-1">[“0.700”,”2.800”,”4.900”]</span>, target = <span id="example-input-1-2">8</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">“1.000”</span><br><span style="font-weight: bolder;">Explanation: </span><br>Use Floor, Ceil and Ceil operations to get (0.7 - 0) + (3 - 2.8) + (5 - 4.9) = 0.7 + 0.2 + 0.1 = 1.0 .<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>prices = <span id="example-input-2-1">[“1.500”,”2.500”,”3.500”]</span>, target = <span id="example-input-2-2">10</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">“-1”</span><br><span style="font-weight: bolder;">Explanation: </span><br>It is impossible to meet the target.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= prices.length &lt;= 500</code>.</li><li>Each string of prices&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">prices[i]</code>&nbsp;represents a real number which is between 0 and 1000 and has exactly 3 decimal places.</li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">target</code>&nbsp;is between 0 and 1000000.</li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>如果一个数字是一个整数， 那么我们只能取<code>floor</code>，不能取<code>ceil</code>。这相当于一个无法调整的数字，否则就是一个可调整的数字。我们把所有可调整的数字的小数部分放入一个<code>priority queue</code>中，把<code>priority queue</code>的<code>size</code>记为<code>pqsize</code>。 </p>
<p>然后我们先判断什么情况下无法得到target：</p>
<ol>
<li>如果取最小的可能的和，那么所有数字都要取floor。如果这个和仍然比target大，或者比<code>target-pqsize</code>小，那么就说明无论如何也不可能得到<code>target</code>。这样我们就返回 <code>“-1”</code></li>
<li>若满足上述条件，我们一定可以取到满足题目条件的和。我们需要知道调整多少个数字，即把floor操作变成ceil操作。需要调整的数字个数等于<code>target-pqsize</code>。</li>
<li>为了的达到最小的<code>rounding error</code>，对于每个调整的操作，我们希望它们小数尽可能大，这可以由之前的<code>priority queue</code>得到。取那个数字的<code>ceil</code>。最后把所有不需要调整的小数也加上，就是最小的<code>rounding error</code>了。</li>
</ol>
<p>注意最后返回字符串是，需要做些特殊处理，只保留最后3位小数即可。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">minimizeError</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; prices, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">double</span>&gt; pq;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> price : prices) &#123;</span><br><span class="line">            sum += <span class="built_in">floor</span>(stod(price));</span><br><span class="line">            <span class="keyword">double</span> diffPrice = stod(price) - <span class="built_in">floor</span>(stod(price));</span><br><span class="line">            <span class="keyword">if</span> (diffPrice != <span class="number">0</span>) &#123;</span><br><span class="line">                pq.push(diffPrice);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; target || sum &lt; target - pq.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> diff = target - sum;</span><br><span class="line">        <span class="keyword">double</span> error = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">            <span class="keyword">double</span> fl = pq.top();</span><br><span class="line">            pq.pop();</span><br><span class="line">            error += diff &gt; <span class="number">0</span> ? <span class="number">1</span> - fl : fl;</span><br><span class="line">            diff--;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">string</span> ans = to_string(error);</span><br><span class="line">        <span class="keyword">return</span> ans.substr(<span class="number">0</span>, ans.find(<span class="string">'.'</span>) + <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minimizeError</span><span class="params">(String[] prices, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> res = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Double&gt; diffHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (String s : prices) &#123;</span><br><span class="line">            <span class="keyword">float</span> f = Float.valueOf(s);</span><br><span class="line">            <span class="keyword">double</span> low = Math.floor(f);</span><br><span class="line">            <span class="keyword">double</span> high = Math.ceil(f);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (low != high)</span><br><span class="line">                diffHeap.offer((high-f)-(f-low));</span><br><span class="line">            </span><br><span class="line">            res += f-low;</span><br><span class="line">            target -= low;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span> || target &gt; diffHeap.size())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-1"</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (target-- &gt; <span class="number">0</span>)</span><br><span class="line">            res += diffHeap.poll();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">"%.3f"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimizeError</span><span class="params">(self, prices: List[str], target: int)</span> -&gt; str:</span></span><br><span class="line">        diff = []</span><br><span class="line">        low, high = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, p <span class="keyword">in</span> enumerate(map(float, prices)):</span><br><span class="line">            f, c = math.floor(p), math.ceil(p)</span><br><span class="line">            low, high = low + f, high + c</span><br><span class="line">            fDiff, cDiff = p - f, c - p</span><br><span class="line">            diff.append((fDiff - cDiff, fDiff, cDiff))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> low &lt;= target &lt;= high:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"-1"</span></span><br><span class="line">        ceilN = target - low</span><br><span class="line">        diff = sorted(diff, reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&#123;:.3f&#125;"</span>.format(sum([d[<span class="number">2</span>] <span class="keyword">for</span> d <span class="keyword">in</span> diff[:ceilN]]) + sum([d[<span class="number">1</span>] <span class="keyword">for</span> d <span class="keyword">in</span> diff[ceilN:]]))</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(NlogN)<br>空间复杂度: O(N)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/d35MHk_Krgc" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Airbnb</tag>
        <tag>Greedy</tag>
        <tag>Math</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1059] All Paths from Source Lead to Destination</title>
    <url>/Leetcode-1059-All-Paths-from-Source-Lead-to-Destination/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">edges</code>&nbsp;of a directed graph, and two nodes&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">source</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">destination</code>&nbsp;of this graph, determine whether or not all paths starting from&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">source</code>&nbsp;eventually end at&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">destination</code>, that is:</p><ul style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li>At least one path exists from the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">source</code>&nbsp;node to the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">destination</code>&nbsp;node</li><li>If a path exists from the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">source</code>&nbsp;node to a node with no outgoing edges, then that node is equal to&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">destination</code>.</li><li>The number of possible paths from&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">source</code>&nbsp;to&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">destination</code>&nbsp;is a finite number.</li></ul><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">true</code>&nbsp;if and only if all roads from&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">source</code>&nbsp;lead to&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">destination</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/16/485_example_1.png" style="border-style: none; max-width: 100%; height: 208px; width: 200px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>n = 3, edges = <span id="example-input-1-2">[[0,1],[0,2]]</span>, source = <span id="example-input-1-3">0</span>, destination = 2<br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">false</span><br><span style="font-weight: bolder;">Explanation: </span>It is possible to reach and get stuck on both node 1 and node 2.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/16/485_example_2.png" style="border-style: none; max-width: 100%; height: 230px; width: 200px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>n = <span id="example-input-2-1">4</span>, edges = <span id="example-input-2-2">[[0,1],[0,3],[1,2],[2,1]]</span>, source = <span id="example-input-2-3">0</span>, destination = <span id="example-input-2-4">3</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">false</span><br><span style="font-weight: bolder;">Explanation: </span>We have two possibilities: to end at node 3, or to loop over node 1 and node 2 indefinitely.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 3:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/16/485_example_3.png" style="border-style: none; max-width: 100%; height: 183px; width: 200px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>n = <span id="example-input-3-1">4</span>, edges = <span id="example-input-3-2">[[0,1],[0,2],[1,3],[2,3]]</span>, source = <span id="example-input-3-3">0</span>, destination = <span id="example-input-3-4">3</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">true</span><br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 4:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/16/485_example_4.png" style="border-style: none; max-width: 100%; height: 183px; width: 200px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>n = <span id="example-input-4-1">3</span>, edges = <span id="example-input-4-2">[[0,1],[1,1],[1,2]]</span>, source = <span id="example-input-4-3">0</span>, destination = <span id="example-input-4-4">2</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-4">false</span><br><span style="font-weight: bolder;">Explanation: </span>All paths from the source node end at the destination node, but there are an infinite number of paths, such as 0-1-2, 0-1-1-2, 0-1-1-1-2, 0-1-1-1-1-2, and so on.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 5:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/16/485_example_5.png" style="border-style: none; max-width: 100%; height: 131px; width: 150px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>n = <span id="example-input-5-1">2</span>, edges = <span id="example-input-5-2">[[0,1],[1,1]]</span>, source = <span id="example-input-5-3">0</span>, destination = <span id="example-input-5-4">1</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-5">false</span><br><span style="font-weight: bolder;">Explanation: </span>There is infinite self-loop at destination node.</pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><italic>The given graph may have self loops and parallel edges.</italic></li><li>The number of nodes&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">n</code>&nbsp;in the graph is between&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">10000</code></li><li>The number of edges in the graph is between&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">10000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0 &lt;= edges.length &lt;= 10000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">edges[i].length == 2</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0 &lt;= source &lt;= n - 1</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0 &lt;= destination &lt;= n - 1</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>使用DFS，用一个数组<code>visited</code>来记录以每一个节点为<code>source</code>，到<code>destination</code>应当返回的值(not visited, true, or false)。<br>然后要明确边界条件：</p>
<ol>
<li>当遇到一个没有出度的节点，则需要判断是否该点为<code>destination</code>，是的话返回<code>true</code>，不然则为<code>false</code>。</li>
<li>判断当前节点是否被访问过，如果访问过，则返回visited对应的值。</li>
</ol>
<p>在DFS中，要首先将<code>visited[source]</code>记录为<code>isFalse</code>, 然后再开始递归，这样遇到cycle，则会返回<code>false</code>，不然就会返回<code>true</code>，那就不对了。<br>DFS要求<code>source</code>的每一个child到<code>destination</code>都为<code>true</code>，这样<code>source</code>到<code>destination</code>也为<code>true</code>，反之则为<code>false</code>。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> State &#123;notVisited, isTrue, isFalse&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mapping, <span class="keyword">int</span> source, <span class="keyword">int</span> destination, <span class="built_in">vector</span>&lt;State&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mapping[source].empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (source == destination) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visited[source] != notVisited) &#123;</span><br><span class="line">            <span class="keyword">return</span> visited[source] == isTrue;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[source] = isFalse;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> child : mapping[source]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(mapping, child, destination, visited)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[source] = isTrue;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">leadsToDestination</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> source, <span class="keyword">int</span> destination)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">mapping</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; edge : edges) &#123;</span><br><span class="line">            mapping[edge[<span class="number">0</span>]].push_back(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;State&gt; <span class="title">visited</span><span class="params">(n, notVisited)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(mapping, source, destination, visited);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> State &#123; PROCESSING, PROCESSED &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">leadsToDestination</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges, <span class="keyword">int</span> src, <span class="keyword">int</span> dest)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph = buildDigraph(n, edges);</span><br><span class="line">        <span class="keyword">return</span> leadsToDest(graph, src, dest, <span class="keyword">new</span> State[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">leadsToDest</span><span class="params">(List&lt;Integer&gt;[] graph, <span class="keyword">int</span> node, <span class="keyword">int</span> dest, State[] states)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (states[node] != <span class="keyword">null</span>) <span class="keyword">return</span> states[node] == State.PROCESSED;</span><br><span class="line">        <span class="keyword">if</span> (graph[node].isEmpty()) <span class="keyword">return</span> node == dest;</span><br><span class="line">        states[node] = State.PROCESSING;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[node]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!leadsToDest(graph, next, dest, states)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        states[node] = State.PROCESSED;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt;[] buildDigraph(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        List&lt;Integer&gt;[] graph = <span class="keyword">new</span> List[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            graph[edge[<span class="number">0</span>]].add(edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> graph;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leadsToDestination</span><span class="params">(self, n: int, edges: List[List[int]], source: int, destination: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i)</span>:</span></span><br><span class="line">            seen.add(i)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> graph[i]:</span><br><span class="line">                <span class="keyword">if</span> j == i <span class="keyword">or</span> j <span class="keyword">in</span> seen <span class="keyword">or</span> <span class="keyword">not</span> dfs(j):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            seen.discard(i)</span><br><span class="line">            <span class="keyword">return</span> len(graph[i]) != <span class="number">0</span> <span class="keyword">or</span> i == destination</span><br><span class="line">        graph, seen = collections.defaultdict(set), set()</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> edges:</span><br><span class="line">            graph[a].add(b)</span><br><span class="line">        <span class="keyword">return</span> dfs(source)</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N)</code><br>空间复杂度: <code>O(N)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/FzRFfyyCMP0" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Depth-first Search</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 106] Construct Binary Tree from Inorder and Postorder Traversal</title>
    <url>/Leetcode-106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given inorder and postorder traversal of a tree, construct the binary tree.</p>
<p><em>Note</em>:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given</p>
<pre><code>inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]
</code></pre><p>Return the following binary tree:</p>
<pre><code>    3
   / \
  9   20
 /     \
15      7
</code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目给出二叉树的中序遍历与后序遍历，要求重新构建原二叉树，返回根节点。</p>
<p>首先我们需要明确：</p>
<ul>
<li>中序遍历的顺序：左、中、右</li>
<li>后序遍历的顺序：左、右、中</li>
</ul>
<p>因此，我们知道后序遍历的最后一个元素是原二叉树的根节点，而此根节点将中序遍历分为了左子树的中序遍历与右子树的中序遍历。</p>
<p>根据以上思路，我们可以继续对左右子树的分别进行递归，直到序列为空，重构整个二叉树。</p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder, postorder)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :type postorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dicinorder = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(inorder):</span><br><span class="line">            dicinorder[val] = i</span><br><span class="line">        start, end = <span class="number">0</span>, len(inorder)</span><br><span class="line">        <span class="keyword">return</span> self.helper(start, end, postorder, dicinorder)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, start, end, postorder, dicinorder)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root = TreeNode(postorder.pop())</span><br><span class="line">        inorderIndex = dicinorder[root.val]</span><br><span class="line">        root.right = self.helper(inorderIndex+<span class="number">1</span>, end, postorder, dicinorder)</span><br><span class="line">        root.left = self.helper(start, inorderIndex, postorder, dicinorder)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>我们使用一个字典记录<code>inorder</code>数组中value与对应index的关系，这样能快速查找每个value的index，每次查找时间复杂度为O(1)。<br>每个节点重构会被访问一次，一共n个节点。同时字典需要空间<code>O(n)</code>。所以复杂度分析为</p>
<ul>
<li>时间复杂度: <code>O(n)</code></li>
<li>空间复杂度: <code>O(n)</code></li>
</ul>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>此题要求重构二叉树，因此需要理解清楚中序遍历与后序遍历的定义。合理使用递归方法即可完成解题。</p>
<p>大家可以结合利用中序遍历与前序遍历构建二叉树这题，更好的理解问题：</p>
<p><a href="/Leetcode-105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal">[LeetCode 105] Construct Binary Tree from Preorder and Inorder Traversal</a></p>
<p>大家可以在 <a href="/tags/Tree">Tree Tag</a> 中找到更多和树有关的内容。种香蕉树去了^_^</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1060] Missing Element in Sorted Array</title>
    <url>/Leetcode-1060-Missing-Element-in-Sorted-Array/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given a sorted array&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A</code>&nbsp;of&nbsp;<span style="font-weight: bolder;">unique</span>&nbsp;numbers, find the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;"><em>K</em>-th</code>&nbsp;missing number starting from the leftmost number of the array.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>A = <span id="example-input-1-1">[4,7,9,10]</span>, K = 1<br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">5</span><br><span style="font-weight: bolder;">Explanation: </span><br>The first missing number is 5.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>A = <span id="example-input-2-1">[4,7,9,10]</span>, K = 3<br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">8</span><br><span style="font-weight: bolder;">Explanation: </span><br>The missing numbers are [5,6,8,…], hence the third missing number is 8.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>A = <span id="example-input-3-1">[1,2,4]</span>, K = 3<br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">6</span><br><span style="font-weight: bolder;">Explanation: </span><br>The missing numbers are [3,5,6,7,…], hence the third missing number is 6.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= A.length &lt;= 50000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= A[i] &lt;= 1e7</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= K &lt;= 1e8</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>显然暴力破解不是我们想要的方法。既然暴力破解的时间复杂度是O(N），那我们需要比这更优的解，一般只有<code>O(logN)</code>了。这样我们自然想到用<code>binary search</code>。<br>我们可以进行<code>binary search</code>。具体到这道题，我们按每个<code>index</code>对应的对应的<code>missing elements</code>的数量进行二分。如果大于<code>K</code>，则我们要求的第<code>K</code>个<code>element</code>一定在这个<code>index</code>的左边，小于<code>K</code>则一定在右边。找到这个转换点的<code>index</code>，就能通过计算得出想要的第<code>k</code>个<code>missing element</code>。 </p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missingElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = N;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> missingcount = missing(nums, mid);</span><br><span class="line">            <span class="keyword">if</span> (missingcount &lt; k) &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> missing(nums, right) &lt; k ? nums[right] + k - missing(nums, right) : nums[left] + k - missing(nums, left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">missing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nums[index] - nums[<span class="number">0</span>] - index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">missingElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> missingNum = nums[n - <span class="number">1</span>] - nums[<span class="number">0</span>] + <span class="number">1</span> - n;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (missingNum &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[n - <span class="number">1</span>] + k - missingNum;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l &lt; h - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> missing = nums[m] - nums[l] - (m - l);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (missing &gt;= k) &#123;</span><br><span class="line">			    <span class="comment">// when the number is larger than k, then the index won't be located in (m, h]</span></span><br><span class="line">                h = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			    <span class="comment">// when the number is smaller than k, then the index won't be located in [l, m), update k -= missing</span></span><br><span class="line">                k -= missing;</span><br><span class="line">                l = m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[l] + k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingElement</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        diff = nums[<span class="number">-1</span>] - nums[<span class="number">0</span>] + <span class="number">1</span> <span class="comment"># complete length</span></span><br><span class="line">        missing = diff - len(nums) <span class="comment"># complete length - real length</span></span><br><span class="line">        <span class="keyword">if</span> k &gt; missing: <span class="comment"># if k is larger than the number of mssing words in sequence</span></span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">-1</span>] + k - missing</span><br><span class="line">        </span><br><span class="line">        left, right = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left + <span class="number">1</span> &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            missing = nums[mid] - nums[left] - (mid - left)</span><br><span class="line">            <span class="keyword">if</span> missing &lt; k:</span><br><span class="line">                left = mid</span><br><span class="line">                k -= missing <span class="comment"># KEY: move left forward, we need to minus the missing words of this range</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> nums[left] + k <span class="comment"># k should be between left and right index in the end</span></span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(logN)<br>空间复杂度: O(1)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/Tm03BJedJQU" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Bloomberg</tag>
        <tag>Apple</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1061] Lexicographically Smallest Equivalent String</title>
    <url>/Leetcode-1061-Lexicographically-Smallest-Equivalent-String/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given strings&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">B</code>&nbsp;of the same length, we say A[i] and B[i] are equivalent characters. For example, if&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A = “abc”</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">B = “cde”</code>, then we have&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">‘a’ == ‘c’, ‘b’ == ‘d’, ‘c’ == ‘e’</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Equivalent characters follow the usual rules of any equivalence relation:</p><ul style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li>Reflexivity: ‘a’ == ‘a’</li><li>Symmetry: ‘a’ == ‘b’ implies ‘b’ == ‘a’</li><li>Transitivity: ‘a’ == ‘b’ and ‘b’ == ‘c’ implies ‘a’ == ‘c’</li></ul><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">For example, given the equivalency information from&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">B</code>&nbsp;above,&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S = “eed”</code>,&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">“acd”</code>, and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">“aab”</code>&nbsp;are equivalent strings, and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">“aab”</code>&nbsp;is the lexicographically smallest equivalent string of&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return the lexicographically smallest equivalent string of&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>&nbsp;by using the equivalency information from&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">B</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>A = <span id="example-input-1-1">“parker”</span>, B = <span id="example-input-1-2">“morris”</span>, S = <span id="example-input-1-3">“parser”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">“makkek”</span><br><span style="font-weight: bolder;">Explanation:</span> Based on the equivalency information in <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">A</code> and <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">B</code>, we can group their characters as <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">[m,p]</code>, <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">[a,o]</code>, <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">[k,r,s]</code>, <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">[e,i]</code>. The characters in each group are equivalent and sorted in lexicographical order. So the answer is <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">“makkek”</code>.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>A = <span id="example-input-2-1">“hello”</span>, B = <span id="example-input-2-2">“world”</span>, S = <span id="example-input-2-3">“hold”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">“hdld”</span><br><span style="font-weight: bolder;">Explanation: </span> Based on the equivalency information in <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">A</code> and <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">B</code>, we can group their characters as <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">[h,w]</code>, <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">[d,e,o]</code>, <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">[l,r]</code>. So only the second letter <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">‘o’</code> in <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">S</code> is changed to <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">‘d’</code>, the answer is <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">“hdld”</code>.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>A = <span id="example-input-3-1">“leetcode”</span>, B = <span id="example-input-3-2">“programs”</span>, S = <span id="example-input-3-3">“sourcecode”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">“aauaaaaada”</span><br><span style="font-weight: bolder;">Explanation: </span> We group the equivalent characters in <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">A</code> and <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">B</code> as <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">[a,o,e,r,s,c]</code>, <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">[l,p]</code>, <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">[g,t]</code> and <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">[d,m]</code>, thus all letters in <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">S</code> except <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">‘u’</code> and <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">‘d’</code> are transformed to <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">‘a’</code>, the answer is <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">“aauaaaaada”</code>.</pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li>String&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A</code>,&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">B</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>&nbsp;consist of only lowercase English letters from&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">‘a’</code>&nbsp;-&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">‘z’</code>.</li><li>The lengths of string&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A</code>,&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">B</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>&nbsp;are between&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1000</code>.</li><li>String&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">B</code>&nbsp;are of the same length.</li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题很多网上解答是用了Union find，实际上并不是最好的方法。<br>Union find比较适合union与find操作交错的情况，比如Number of Islands II.<br>但是这里的话，如果使用Union find，需要先进行一系列union操作，然后进行一系列find操作，时间复杂度是<code>O((M + N)log*(M))</code>，近似于<code>O(M + N)</code>. 但是实际上直接使用DFS或者BFS遍历，也可以达到<code>O(M + N)</code>的时间复杂度：</p>
<ol>
<li>首先遍历<code>A</code>和<code>B</code>，创建一个字母间关联的无向图<code>mapping</code></li>
<li>遍历<code>S</code>，对于<code>S</code>中的每一个字母<code>s</code>，在无向图中进行一次DFS（BFS也可以），找寻关联字母中最小的字母，同时用一个<code>unordered_set visited</code>记录遍历到的点。</li>
<li><code>visited</code>中的点都是与当前字母<code>s</code>关联的，因此对应的最小字母是一样的，用一个<code>unordered_map memo</code>来记录<code>visited</code>中的点与最小字母的对应关系，这样下次遍历到这些点，就不用再做dfs了，直接从<code>memo</code>中查到对应的最小字母即可。</li>
</ol>
<p>假设<code>A</code>和<code>B</code>的长度是<code>M</code>，<code>S</code>的长度是<code>N</code>，由于<code>mapping</code>中每一个字母（节点）和每一条边遍历了一遍，这是一个<code>O(M)</code>的时间复杂度，创建<code>mapping</code>是<code>O(M)</code>的时间复杂度，遍历<code>S</code>的时间复杂度为<code>O(N)</code><br>所以总的时间复杂度是<code>O(2M + N)</code>也是近似于<code>O(M + N)</code></p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">dfs</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; mapping, <span class="keyword">char</span> input, <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited.count(input) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> input;</span><br><span class="line">        &#125;</span><br><span class="line">        visited.insert(input);</span><br><span class="line">        <span class="keyword">char</span> ret = input;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> ch : mapping[input]) &#123;</span><br><span class="line">            ret = min(ret, dfs(mapping, ch, visited));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">smallestEquivalentString</span><span class="params">(<span class="built_in">string</span> A, <span class="built_in">string</span> B, <span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; mapping;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">            mapping[A[i]].push_back(B[i]);</span><br><span class="line">            mapping[B[i]].push_back(A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; memo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> s : S) &#123;</span><br><span class="line">            <span class="keyword">if</span> (memo.count(s) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ret += memo[s];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; visited;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> min_char = dfs(mapping, s, visited);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> ch : visited) &#123;</span><br><span class="line">                memo[ch] = min_char;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += min_char;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Union Find</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">smallestEquivalentString</span><span class="params">(String A, String B, String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] graph = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            graph[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> a = A.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> b = B.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">int</span> end1 = find(graph, b);</span><br><span class="line">            <span class="keyword">int</span> end2 = find(graph, a);</span><br><span class="line">            <span class="keyword">if</span>(end1 &lt; end2) &#123;</span><br><span class="line">                graph[end2] = end1;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                graph[end1] = end2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = S.charAt(i);</span><br><span class="line">            sb.append((<span class="keyword">char</span>)(<span class="string">'a'</span> + find(graph, c - <span class="string">'a'</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] graph, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(graph[idx] != idx) &#123;</span><br><span class="line">            idx = graph[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestEquivalentString</span><span class="params">(self, A: str, B: str, S: str)</span> -&gt; str:</span></span><br><span class="line">        neighbors = collections.defaultdict(set)</span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> zip(A, B):</span><br><span class="line">            neighbors[a].add(b)</span><br><span class="line">            neighbors[b].add(a)</span><br><span class="line"></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(ch)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> ch <span class="keyword">in</span> memo: <span class="keyword">return</span> memo[ch]</span><br><span class="line">            res = ch</span><br><span class="line">            seen = set()</span><br><span class="line">            queue = &#123;ch&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                c = queue.pop()</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> seen: <span class="keyword">continue</span></span><br><span class="line">                seen.add(c)</span><br><span class="line">                res = min(res, c)</span><br><span class="line">                queue |= neighbors[c]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> seen:</span><br><span class="line">                memo[v] = res</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(bfs(c) <span class="keyword">for</span> c  <span class="keyword">in</span> S)</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(M + N)</code>, 假设<code>A</code>和<code>B</code>的长度是<code>M</code>，<code>S</code>的长度是<code>N</code><br>空间复杂度: <code>O(M)</code>, 即<code>mapping</code>占用的空间</p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/if1m4y5ZnVQ" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Depth-first Search</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1062] Longest Repeating Substring</title>
    <url>/Leetcode-1062-Longest-Repeating-Substring/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given a string&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>, find out the length of the longest repeating substring(s). Return&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0</code>&nbsp;if no repeating substring exists.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-1-1">“abcd”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">0</span><br><span style="font-weight: bolder;">Explanation: </span>There is no repeating substring.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-2-1">“abbaba”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">2</span><br><span style="font-weight: bolder;">Explanation: </span>The longest repeating substrings are “ab” and “ba”, each of which occurs twice.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-3-1">“aabcaabdaab”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">3</span><br><span style="font-weight: bolder;">Explanation: </span>The longest repeating substring is “aab”, which occurs <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">3</code> times.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 4:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-4-1">“aaaaa”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-4">4</span><br><span style="font-weight: bolder;">Explanation: </span>The longest repeating substring is “aaaa”, which occurs twice.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Constraints:</span></p><ul style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li>The string&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>&nbsp;consists of only lowercase English letters from&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">‘a’</code>&nbsp;-&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">‘z’</code>.</li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= S.length &lt;= 1500</code></li></ul><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这题我们采用动态规划的方法。<br>我们先定义<code>dp[i][j]</code>为分别以第<code>i</code>个字符和第<code>j</code>个字符结尾的<code>substring</code>有相同共同后缀的最大长度。因此，我们也要求<code>i&gt;j</code>。<br>我们注意到，当<code>S[i] != S[j]</code>, 那么<code>dp[i][j] = 0</code>， 否则<code>dp[i][j] = dp[i-1][j-1] + 1</code>。这就是我们的状态转移方程。</p>
<p><code>dp[i][j] = dp[i-1][j-1] + 1 -----------  S[i] == S[j]</code><br><code>dp[i][j] = 0                -----------  S[i] != S[j]</code> </p>
<p>我们更新<code>dp[i][j]</code>的最大值，就可以得到最后的答案。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestRepeatingSubstring</span><span class="params">(<span class="built_in">string</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(S.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(S.size() + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">1</span>; i &lt;= S.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S[i<span class="number">-1</span>] == S[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans = max(ans, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestRepeatingSubstring</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = S.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">		   <span class="comment">// Need start from i - 1 to use values from last iteration</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (S.charAt(i - <span class="number">1</span>) == S.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                    dp[j] = dp[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                res = Math.max(res, dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestRepeatingSubstring</span><span class="params">(self, S: str)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(S)):</span><br><span class="line">            <span class="keyword">if</span> ans &gt;= len(S)-i: </span><br><span class="line">                <span class="keyword">break</span> </span><br><span class="line">                </span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(S[i:],S[:-i]):</span><br><span class="line">                <span class="keyword">if</span> x == y:</span><br><span class="line">                    tmp += <span class="number">1</span> </span><br><span class="line">                    ans = max(ans, tmp)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tmp = <span class="number">0</span> </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><code>N</code>是字符串的长度。<br>时间复杂度: O(N^2)<br>空间复杂度: O(N^2)</p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/iA6TDMV5g2M" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Google</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1063] Number of Valid Subarrays</title>
    <url>/Leetcode-1063-Number-of-Valid-Subarrays/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given an array&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A</code>&nbsp;of integers, return the number of&nbsp;<span style="font-weight: bolder;">non-empty continuous subarrays</span>&nbsp;that satisfy the following condition:</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">The leftmost element of the subarray is not larger than other elements in the subarray.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-1-1">[1,4,2,5,3]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">11</span><br><span style="font-weight: bolder;">Explanation: </span>There are 11 valid subarrays: [1],[4],[2],[5],[3],[1,4],[2,5],[1,4,2],[2,5,3],[1,4,2,5],[1,4,2,5,3].<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-2-1">[3,2,1]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">3</span><br><span style="font-weight: bolder;">Explanation: </span>The 3 valid subarrays are: [3],[2],[1].<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-3-1">[2,2,2]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">6</span><br><span style="font-weight: bolder;">Explanation: </span>There are 6 valid subarrays: [2],[2],[2],[2,2],[2,2],[2,2,2].</pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= A.length &lt;= 50000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0 &lt;= A[i] &lt;= 100000</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>建立一个从顶往下递减的栈<code>stk</code>，遍历<code>nums</code>中每个元素<code>num</code>，比较<code>num</code>与栈顶元素大小。<br>如果<code>num</code>较大，则不断<code>pop</code>栈顶元素，直到栈空或者栈顶元素小于等于<code>num</code>，然后将<code>num</code>插入栈顶。<br>此时，我们可以以<code>stk</code>中任意元素为开头，以<code>num</code>为结尾组成符合题目条件的subarray，因此<br>以<code>num</code>为结尾的subarray个数为<code>stk</code>的<code>size</code>。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">validSubarrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; num &lt; stk.top()) &#123;</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(num);</span><br><span class="line">            count += stk.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">validSubarrays</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        stack.push(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> num = nums[i];</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; num &lt; stack.peek()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res += stack.size();</span><br><span class="line">            stack.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validSubarrays</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        nextSmaller = [len(nums)] * len(nums)</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>][<span class="number">1</span>] &gt; v:</span><br><span class="line">                nextSmaller[stack.pop()[<span class="number">0</span>]] = i</span><br><span class="line">            stack.append([i, v])</span><br><span class="line">        <span class="keyword">return</span> sum([v - i <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(nextSmaller)])</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N)</code><br>空间复杂度: <code>O(N)</code></p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/tVU8DhZbXCw" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Hulu</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1064] Fixed Point</title>
    <url>/Leetcode-1064-Fixed-Point/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given an array&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A</code>&nbsp;of distinct integers sorted in ascending order, return the smallest index&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">i</code>&nbsp;that satisfies&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">A[i] == i</code>.&nbsp; Return&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">-1</code>&nbsp;if no such&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">i</code>&nbsp;exists.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-1-1">[-10,-5,0,3,7]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">3</span><br><span style="font-weight: bolder;">Explanation: </span><br>For the given array, <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">A[0] = -10, A[1] = -5, A[2] = 0, A[3] = 3</code>, thus the output is 3.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-2-1">[0,2,5,8,17]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">0</span><br><span style="font-weight: bolder;">Explanation: </span><br><code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">A[0] = 0</code>, thus the output is 0.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-3-1">[-10,-5,3,4,7,9]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">-1</span><br><span style="font-weight: bolder;">Explanation: </span><br>There is no such <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">i</code> that <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">A[i] = i</code>, thus the output is -1.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= A.length &lt; 10^4</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">-10^9 &lt;= A[i] &lt;= 10^9</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>因为给出的是一个排序的<code>array</code>，而<code>index</code>也是自然从<code>0</code>到<code>n-1</code>的排序数组，因此本题采用二分法来查找<code>A[i] == i</code>的<code>index</code>。<br>当 <code>i &lt; A[i]</code>, 我们往左边查找，当 <code>i &gt;= A[i]</code>时， 我们往右边查找。<br>需要注意的因为要求最小的index，我们更新右端点时，需要 <code>i &gt;= A[i]</code>。如果是最大的<code>index</code>， 则应该是 <code>i &gt; A[i]</code>。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fixedPoint</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = A.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left + <span class="number">1</span> &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[mid] &gt;= mid) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == A[left]) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right == A[right]) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fixedPoint</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = A.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (A[m] - m &lt; <span class="number">0</span>)</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A[l] == l ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fixedPoint</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l + r) / <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[m] - m &lt; <span class="number">0</span>:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m</span><br><span class="line">        <span class="keyword">return</span> l <span class="keyword">if</span> A[l] == l <span class="keyword">else</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(logN)<br>空间复杂度: O(1)</p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/U7ARrpEsaVU" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Uber</tag>
        <tag>Array</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1065] Index Pairs of a String</title>
    <url>/Leetcode-1065-Index-Pairs-of-a-String/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given a&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">text</code>&nbsp;string and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">words</code>&nbsp;(a list of strings), return all index pairs&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">[i, j]</code>&nbsp;so that the substring&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">text[i]…text[j]</code>&nbsp;is in the list of&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">words</code>.&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>text = <span id="example-input-1-1">“thestoryofleetcodeandme”</span>, words = <span id="example-input-1-2">[“story”,”fleet”,”leetcode”]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">[[3,7],[9,13],[10,17]]</span><br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>text = <span id="example-input-2-1">“ababa”</span>, words = <span id="example-input-2-2">[“aba”,”ab”]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">[[0,1],[0,2],[2,3],[2,4]]</span><br><span style="font-weight: bolder;">Explanation: </span><br>Notice that matches can overlap, see “aba” is found in [0,2] and [2,4].</pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li>All strings contains only lowercase English letters.</li><li>It’s guaranteed that all strings in&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">words</code>&nbsp;are different.</li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= text.length &lt;= 100</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= words.length &lt;= 20</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= words[i].length &lt;= 50</code></li><li>Return the pairs&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">[i,j]</code>&nbsp;in sorted order (i.e. sort them by their first coordinate in case of ties sort them by their second coordinate).</li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题可以直接用string find函数来做，但是需要分析一下时间复杂度。取决于具体的函数实现，比如CPP的find函数<br>没有用KMP实现，所以最坏的情况复杂度是<code>O(M * N)</code>，这样带入本题，时间复杂度是<code>O(M * sum(len(word)))</code>. 其中<code>M</code>是<code>text</code>的长度，<code>sum(len(word))</code>是<code>words</code>中<code>word</code>的长度之和。<br>如果用字典树Trie来实现，则当<code>M &lt; sum(len(word))</code>时，时间复杂度可以优化。<br>首先建立基于<code>words</code>的字典树trie，然后在<code>text</code>中以每一个位置<code>i</code>为起点向后遍历，并判断往后每一个位置<code>j</code>是否在字典树中，若在则加入要返回的结果<code>rets</code>中。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Trie*&gt; children = <span class="built_in">vector</span>&lt;Trie*&gt;(<span class="number">26</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">bool</span> is_find = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function">Trie* <span class="title">constructTrie</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        Trie* trie = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            Trie* cur = trie;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> ch : word) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;children[ch - <span class="string">'a'</span>] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cur-&gt;children[ch - <span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur-&gt;children[ch - <span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur-&gt;is_find = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trie;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">indexPairs</span><span class="params">(<span class="built_in">string</span> text, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> Trie* <span class="keyword">const</span> trie = constructTrie(words);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; rets;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">const</span> Trie* cur = trie;           </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; text.size() &amp;&amp; cur != <span class="literal">nullptr</span>; ++j) &#123;</span><br><span class="line">                cur = cur-&gt;children[text[j] - <span class="string">'a'</span>];</span><br><span class="line">                <span class="keyword">if</span> (cur &amp;&amp; cur-&gt;is_find) &#123;</span><br><span class="line">                    rets.push_back(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] indexPairs(String text, String[] words) &#123;</span><br><span class="line">        <span class="comment">/*initializing tire and put all word from words into Trie.*/</span></span><br><span class="line">        Trie trie=<span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span>(String s:words)&#123;</span><br><span class="line">            Trie cur=trie;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c:s.toCharArray())&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur.children[c-<span class="string">'a'</span>]==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    cur.children[c-<span class="string">'a'</span>]=<span class="keyword">new</span> Trie();</span><br><span class="line">                &#125;</span><br><span class="line">                cur=cur.children[c-<span class="string">'a'</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            cur.end=<span class="keyword">true</span>;       <span class="comment">/*mark there is a word*/</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*if text is "ababa", check "ababa","baba","aba","ba","a" individually.*/</span></span><br><span class="line">        <span class="keyword">int</span> len=text.length();</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            Trie cur=trie;</span><br><span class="line">            <span class="keyword">char</span> cc=text.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> j=i;   <span class="comment">/*j is our moving index*/</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(cur.children[cc-<span class="string">'a'</span>]!=<span class="keyword">null</span>)&#123; </span><br><span class="line">                cur=cur.children[cc-<span class="string">'a'</span>];</span><br><span class="line">                <span class="keyword">if</span>(cur.end)&#123;   <span class="comment">/*there is a word ending here, put into our list*/</span></span><br><span class="line">                    list.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">                <span class="keyword">if</span>(j==len)&#123;  <span class="comment">/*reach the end of the text, we stop*/</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cc=text.charAt(j);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*put all the pairs from list into array*/</span></span><br><span class="line">        <span class="keyword">int</span> size=list.size();</span><br><span class="line">        <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[size][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] r:list)&#123;</span><br><span class="line">            res[i]=r;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span>&#123;</span><br><span class="line">    Trie[] children;</span><br><span class="line">    <span class="keyword">boolean</span> end;   <span class="comment">/*indicate whether there is a word*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span>&#123;</span><br><span class="line">        end=<span class="keyword">false</span>;</span><br><span class="line">        children=<span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">indexPairs</span><span class="params">(self, text: str, words: List[str])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        trie=&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            cur=trie</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> w:</span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> cur.keys():</span><br><span class="line">                    cur[c]=&#123;&#125;</span><br><span class="line">                cur=cur[c]</span><br><span class="line">            cur[<span class="string">'#'</span>]=<span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        res=[]</span><br><span class="line">        lens=len(text)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lens):</span><br><span class="line">            cur=trie</span><br><span class="line">            cc=text[i]</span><br><span class="line">            j=i</span><br><span class="line">            <span class="keyword">while</span> cc <span class="keyword">in</span> cur.keys():</span><br><span class="line">                cur=cur[cc]</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'#'</span> <span class="keyword">in</span> cur.keys():</span><br><span class="line">                    res.append([i,j])</span><br><span class="line">                j+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j==lens:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cc=text[j]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(M^2 + sum(len(word)))</code>, <code>M</code>为<code>text</code>的长度<br>空间复杂度: <code>O(26^max(len(words)))</code></p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/-A34A6dMYEA" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>String</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1066] Campus Bikes II</title>
    <url>/Leetcode-1066-Campus-Bikes-II/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">On a campus represented as a 2D grid, there are&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">N</code>&nbsp;workers and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">M</code>&nbsp;bikes, with&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">N &lt;= M</code>. Each worker and bike is a 2D coordinate on this grid.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">We assign one unique bike to each worker so that the sum of the Manhattan distances between each worker and their assigned bike is minimized.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">The Manhattan distance between two points&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">p1</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">p2</code>&nbsp;is&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Manhattan(p1, p2) = |p1.x - p2.x| + |p1.y - p2.y|</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return the minimum possible sum of Manhattan distances between each worker and their assigned bike.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/06/1261_example_1_v2.png" style="border-style: none; max-width: 100%; height: 264px; width: 264px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>workers = <span id="example-input-1-1">[[0,0],[2,1]]</span>, bikes = <span id="example-input-1-2">[[1,2],[3,3]]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">6</span><br><span style="font-weight: bolder;">Explanation: </span><br>We assign bike 0 to worker 0, bike 1 to worker 1. The Manhattan distance of both assignments is 3, so the output is 6.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 2:</span></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><img alt src="https://assets.leetcode.com/uploads/2019/03/06/1261_example_2_v2.png" style="border-style: none; max-width: 100%; height: 264px; width: 264px;"></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>workers = <span id="example-input-2-1">[[0,0],[1,1],[2,0]]</span>, bikes = <span id="example-input-2-2">[[1,0],[2,2],[2,1]]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">4</span><br><span style="font-weight: bolder;">Explanation: </span><br>We first assign bike 0 to worker 0, then assign bike 1 to worker 1 or worker 2, bike 2 to worker 2 or worker 1. Both assignments lead to sum of the Manhattan distances as 4.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0 &lt;= workers[i][0], workers[i][1], bikes[i][0], bikes[i][1] &lt; 1000</code></li><li>All worker and bike locations are distinct.</li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= workers.length &lt;= bikes.length &lt;= 10</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们先用一个二维矩阵记录每个工人到每辆车的距离，<code>dp[i][j] = distance</code>就表示工人<code>i</code>和车<code>j</code>的距离为<code>distance</code>。</p>
<p>这样我们把问题就转化为：在二维矩阵里每一行取一个数，同时每个数不能有相同的列，要求让所有取出的数之和最小。</p>
<p>如果用简单的暴力破解，用<code>dfs</code>把所有取法都遍历一遍，时间复杂度是<code>O(N!)</code>。这里是不能通过测试的。</p>
<p>因此我们需要用<code>backtracking + memoization</code>的方法做优化。用一个数<code>state</code>表示已经选取了的<code>bike</code>的组合。这样<code>memo[state]</code>就表示在当前选取的自行车组合下，之后能得到的最小和。</p>
<p>这样我们就能从后往前递归，减少重复计算的，大大降低时间复杂度。<br>这是一种<code>bottom up</code>的思想。</p>
<p>这里有一个技巧，我们用二进制的思想构造<code>state</code>。因为自行车的数量不超过<code>10</code>个,那么在第<code>i</code>位上，如果等于<code>1</code>，则说明第<code>i</code>辆自行车被选择了，否则就是没被选择。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dict</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; worker, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bike)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(worker[<span class="number">0</span>] - bike[<span class="number">0</span>]) + <span class="built_in">abs</span>(worker[<span class="number">1</span>] - bike[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">assignBikes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; workers, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; bikes)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(workers.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(bikes.size(), <span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; workers.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; bikes.size(); ++j) &#123;</span><br><span class="line">                dp[i][j] = dict(workers[i], bikes[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(<span class="number">1</span> &lt;&lt; bikes.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> permRes(dp, memo, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">permRes</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memo, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> state, </span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">int</span> idx)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == dp.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo[state] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[state];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tmp = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j = <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((state &amp; (<span class="number">1</span> &lt;&lt; j)) == <span class="number">0</span>) &#123;</span><br><span class="line">                tmp = min(tmp, dp[idx][j] + permRes(dp, memo, state | (<span class="number">1</span>&lt;&lt;j), idx + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[state] = tmp;</span><br><span class="line">        <span class="keyword">return</span> memo[state];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">assignBikes</span><span class="params">(<span class="keyword">int</span>[][] workers, <span class="keyword">int</span>[][] bikes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span> &lt;&lt; bikes.length];</span><br><span class="line">        <span class="keyword">return</span> dfs(workers, bikes, <span class="number">0</span>, <span class="number">0</span>, dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] w, <span class="keyword">int</span>[][] b, <span class="keyword">int</span> idx, <span class="keyword">int</span> used, <span class="keyword">int</span>[] dp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == w.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dp[used] &gt; <span class="number">0</span>) <span class="keyword">return</span> dp[used];</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((used &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            res = Math.min(res, Math.abs(w[idx][<span class="number">0</span>] - b[i][<span class="number">0</span>]) + Math.abs(w[idx][<span class="number">1</span>] - b[i][<span class="number">1</span>])</span><br><span class="line">                       + dfs(w,b,idx + <span class="number">1</span>, used | (<span class="number">1</span>&lt;&lt;i), dp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[used] = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">assignBikes</span><span class="params">(self, workers: List[List[int]], bikes: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(a,b)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> abs(a[<span class="number">0</span>] - b[<span class="number">0</span>]) + abs(a[<span class="number">1</span>] - b[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(p, arr)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> p == len(workers):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (p, tuple(arr)) <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> dic[(p, tuple(arr))]</span><br><span class="line">            temp = float(<span class="string">'inf'</span>)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">                <span class="keyword">if</span> arr[i] == <span class="number">0</span>:</span><br><span class="line">                    temp = min(temp,  helper(bikes[i], workers[p]) + dfs(p + <span class="number">1</span>, arr[:i] + [<span class="number">1</span>] + arr[i + <span class="number">1</span>:]))</span><br><span class="line">            dic[(p, tuple(arr))] = temp</span><br><span class="line">            <span class="keyword">return</span> temp</span><br><span class="line">        </span><br><span class="line">        ans = dfs(<span class="number">0</span>, [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(bikes))])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><code>M</code>为<code>workers</code>数量，<code>N</code>为<code>bikes</code>数量<br>时间复杂度: <code>state</code>一共有<code>2^N</code>,每个<code>state</code>至多被计算一遍，因此这里是O(2^N)<br>空间复杂度: 距离的<code>cache</code>可以忽略不计，主要开销在<code>memo</code>上，因此这里是O(2^N)</p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/OG_ROut6Ou4" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Google</tag>
        <tag>Dynamic Programming</tag>
        <tag>Backingtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1067] Digit Count in Range</title>
    <url>/Leetcode-1067-Digit-Count-in-Range/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given an integer&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">d</code>&nbsp;between&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">9</code>, and two positive integers&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">low</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">high</code>&nbsp;as lower and upper bounds, respectively. Return the number of times that&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">d</code>&nbsp;occurs as a digit in all integers between&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">low</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">high</code>, including the bounds&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">low</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">high</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>d = <span id="example-input-1-1">1</span>, low = <span id="example-input-1-2">1</span>, high = <span id="example-input-1-3">13</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">6</span><br><span style="font-weight: bolder;">Explanation: </span><br>The digit <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">d=1</code> occurs <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">6</code> times in <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">1,10,11,12,13</code>. Note that the digit <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">d=1</code> occurs twice in the number <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">11</code>.<br></pre><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>d = <span id="example-input-2-1">3</span>, low = <span id="example-input-2-2">100</span>, high = <span id="example-input-2-3">250</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">35</span><br><span style="font-weight: bolder;">Explanation: </span><br>The digit <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">d=3</code> occurs <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">35</code> times in <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">103,113,123,130,131,…,238,239,243</code>.</pre><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0 &lt;= d &lt;= 9</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= low &lt;= high &lt;= 2×10^8</code></li></ol></div><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题我们用递归的方式，递归函数为<code>recursiveCount(N, d)</code>, 将<code>N</code>当中出现<code>d</code>的次数分为个位数中出现的次数，加上非个位数出现的次数。<br>个位数出现的次数为<code>N/10</code>, 非个位数中出现的次数为<code>recursiveCount(N / 10, d) * 10</code>, 可以理解为<code>N / 10</code>中每一个数都可以加后缀0 - 9成为<code>N</code>中的一个数字。<br>当然还要考虑最后一位的大小，从而加减一个偏差，详见代码注释。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">recursiveCount</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 退出条件</span></span><br><span class="line">        <span class="keyword">if</span> (N &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> d == <span class="number">0</span> ? <span class="number">0</span> : (d &lt;= N);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 个位数字d出现的次数，不包含最后一次，e.g. N=797，这里只计算1 - 789之间个位数字出现d的次数</span></span><br><span class="line">        ret += (d == <span class="number">0</span> ? (N / <span class="number">10</span> - <span class="number">1</span>) : N / <span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 判断最后一次个位数字是否包含d，e.g. N=797，判断790-797之间个位数字是否出现d</span></span><br><span class="line">        <span class="keyword">if</span> (N % <span class="number">10</span> &gt;= d) &#123;</span><br><span class="line">            ++ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 除了个位数字以外其他位数d出现的个数, e.g. N=797，我们计算了1 - 799之间非个位数字出现d的次数</span></span><br><span class="line">        ret += recursiveCount(N / <span class="number">10</span>, d) * <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 前面默认最后一位到9，因此我们要减去最后一位不到9的情况，e.g. N=797, 我们计算798 - 799两数非个位数字出现d的次数</span></span><br><span class="line">        <span class="built_in">string</span> nstr = to_string(N / <span class="number">10</span>);</span><br><span class="line">        ret -= <span class="built_in">std</span>::count(nstr.begin(), nstr.end(), d + <span class="string">'0'</span>) * (<span class="number">9</span> - N % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">digitsCount</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> recursiveCount(high, d) - recursiveCount(low - <span class="number">1</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitsCount</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> countDigit(high, d) - countDigit(low-<span class="number">1</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countDigit</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">0</span> || n &lt; d) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i*= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> divider = i * <span class="number">10</span>;</span><br><span class="line">            count += (n / divider) * i;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                count += Math.min(Math.max(n % divider - d * i + <span class="number">1</span>, <span class="number">0</span>), i); <span class="comment">// comment1: tailing number need to be large than d *  i to qualify.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(n / divider &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt; <span class="number">1</span>) &#123;  <span class="comment">// comment2: when d == 0, we need avoid to take numbers like 0xxxx into account.</span></span><br><span class="line">                        count -= i;</span><br><span class="line">                        count += Math.min(n % divider + <span class="number">1</span>, i);  </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">digitsCount</span><span class="params">(self, d: int, low: int, high: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(n, k)</span>:</span></span><br><span class="line">            pivot, res = <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n &gt;= pivot:</span><br><span class="line">                res += (n // (<span class="number">10</span> * pivot)) * pivot + min(pivot, max(n % (<span class="number">10</span> * pivot) - k * pivot + <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">                res -= pivot <span class="keyword">if</span> k == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="comment"># no leading zero</span></span><br><span class="line">                pivot *= <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> res + <span class="number">1</span> <span class="comment"># last-digit can be zero</span></span><br><span class="line">        <span class="keyword">return</span> helper(high, d) - helper(low<span class="number">-1</span>, d)</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(log(N))</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/wtiNO6BmTfg" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Dynamic Programming</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1068] Product Sales Analysis I</title>
    <url>/Leetcode-1068-Product-Sales-Analysis-I/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Sales</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————-+——-+<br>| Column Name | Type  |<br>+————-+——-+<br>| sale_id     | int   |<br>| product_id  | int   |<br>| year        | int   |<br>| quantity    | int   |<br>| price       | int   |<br>+————-+——-+<br>(sale_id, year) is the primary key of this table.<br>product_id is a foreign key to <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">Product</code> table.<br>Note that the price is per unit.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Product</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————–+———+<br>| Column Name  | Type    |<br>+————–+———+<br>| product_id   | int     |<br>| product_name | varchar |<br>+————–+———+<br>product_id is the primary key of this table.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Write an SQL query that reports all&nbsp;<span style="font-weight: bolder;">product names</span>&nbsp;of the products in the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Sales</code>&nbsp;table along with their selling&nbsp;<span style="font-weight: bolder;">year</span>&nbsp;and&nbsp;<span style="font-weight: bolder;">price</span>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">For example:</p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">Sales</code> table:<br>+———+————+——+———-+——-+<br>| sale_id | product_id | year | quantity | price |<br>+———+————+——+———-+——-+<br>| 1       | 100        | 2008 | 10       | 5000  |<br>| 2       | 100        | 2009 | 12       | 5000  |<br>| 7       | 200        | 2011 | 15       | 9000  |<br>+———+————+——+———-+——-+<p></p>
<p>Product table:<br>+————+————–+<br>| product_id | product_name |<br>+————+————–+<br>| 100        | Nokia        |<br>| 200        | Apple        |<br>| 300        | Samsung      |<br>+————+————–+</p>
<p>Result table:<br>+————–+——-+——-+<br>| product_name | year  | price |<br>+————–+——-+——-+<br>| Nokia        | 2008  | 5000  |<br>| Nokia        | 2009  | 5000  |<br>| Apple        | 2011  | 9000  |<br>+————–+——-+——-+</p></pre><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这题解法非常直接，两个表用<code>join</code>做外连接即可</p>
<h4 id="示例代码-mysql"><a href="#示例代码-mysql" class="headerlink" title="示例代码 (mysql)"></a>示例代码 (mysql)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.product_name, s.year, s.price</span><br><span class="line"><span class="keyword">FROM</span> Sales <span class="keyword">AS</span> s</span><br><span class="line"><span class="keyword">JOIN</span> Product <span class="keyword">AS</span> p <span class="keyword">ON</span> s.product_id = p.product_id</span><br></pre></td></tr></table></figure>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/mVY4FKKTp4A" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1069] Product Sales Analysis II</title>
    <url>/Leetcode-1069-Product-Sales-Analysis-II/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p><div class="sql-schema-wrapper__3VBi" style="margin-bottom: 15px; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><div class="content__u3I1 question-content__JfgR" style="margin: 1em 0px;"><div class="sql-schema-wrapper__3VBi" style="margin-bottom: 15px;"><a class="sql-schema-link__3cEg" style="color: rgb(96, 125, 139); outline: none; cursor: pointer; transition: border-bottom-color 0.3s ease 0s; touch-action: manipulation; pointer-events: auto; padding-bottom: 1px; border-bottom: 1px solid transparent;">SQL Schema<svg viewbox="0 0 24 24" width="1em" height="1em" class="icon__3Su4"><path fill-rule="evenodd" d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg></a></div><div><p style="font-size: inherit; margin-bottom: 1em;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Sales</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————-+——-+<br>| Column Name | Type  |<br>+————-+——-+<br>| sale_id     | int   |<br>| product_id  | int   |<br>| year        | int   |<br>| quantity    | int   |<br>| price       | int   |<br>+————-+——-+<br>sale_id is the primary key of this table.<br>product_id is a foreign key to <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">Product</code> table.<br>Note that the price is per unit.<br></pre><p style="font-size: inherit; margin-bottom: 1em;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Product</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————–+———+<br>| Column Name  | Type    |<br>+————–+———+<br>| product_id   | int     |<br>| product_name | varchar |<br>+————–+———+<br>product_id is the primary key of this table.<br></pre><p style="font-size: inherit; margin-bottom: 1em;">&nbsp;</p><p style="font-size: inherit; margin-bottom: 1em;">Write an SQL query that reports the total quantity sold for every product id.</p><p style="font-size: inherit; margin-bottom: 1em;">The query result format is in the following example:</p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">Sales</code> table:<br>+———+————+——+———-+——-+<br>| sale_id | product_id | year | quantity | price |<br>+———+————+——+———-+——-+<br>| 1       | 100        | 2008 | 10       | 5000  |<br>| 2       | 100        | 2009 | 12       | 5000  |<br>| 7       | 200        | 2011 | 15       | 9000  |<br>+———+————+——+———-+——-+<br>Product table:<br>+————+————–+<br>| product_id | product_name |<br>+————+————–+<br>| 100        | Nokia        |<br>| 200        | Apple        |<br>| 300        | Samsung      |<br>+————+————–+<br>Result table:<br>+————–+—————-+<br>| product_id   | total_quantity |<br>+————–+—————-+<br>| 100          | 22             |<br>| 200          | 15             |<br>+————–+—————-+</pre></div></div></div><br><a id="more"></a></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>不需要<code>Product</code> table, 直接 <code>group by product_id</code>即可。</p>
<h4 id="示例代码-mysql"><a href="#示例代码-mysql" class="headerlink" title="示例代码 (mysql)"></a>示例代码 (mysql)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> product_id, <span class="keyword">sum</span>(quantity) <span class="keyword">as</span> total_quantity <span class="keyword">from</span> Sales <span class="keyword">group</span> <span class="keyword">by</span> product_id;</span><br></pre></td></tr></table></figure>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/vpL3f4aajqE" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1070] Product Sales Analysis III</title>
    <url>/Leetcode-1070-Product-Sales-Analysis-III/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Sales</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————-+——-+<br>| Column Name | Type  |<br>+————-+——-+<br>| sale_id     | int   |<br>| product_id  | int   |<br>| year        | int   |<br>| quantity    | int   |<br>| price       | int   |<br>+————-+——-+<br>sale_id is the primary key of this table.<br>product_id is a foreign key to <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">Product</code> table.<br>Note that the price is per unit.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Product</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————–+———+<br>| Column Name  | Type    |<br>+————–+———+<br>| product_id   | int     |<br>| product_name | varchar |<br>+————–+———+<br>product_id is the primary key of this table.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; direction: ltr;">Write an SQL query that selects the&nbsp;<span style="font-weight: bolder;">product id</span>,&nbsp;<span style="font-weight: bolder;">year</span>,&nbsp;<span style="font-weight: bolder;">quantity</span>, and&nbsp;<span style="font-weight: bolder;">price</span>&nbsp;for the&nbsp;<span style="font-weight: bolder;">first year</span>&nbsp;of every product sold.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">The query result format is in the following example:</p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">Sales</code> table:<br>+———+————+——+———-+——-+<br>| sale_id | product_id | year | quantity | price |<br>+———+————+——+———-+——-+<br>| 1       | 100        | 2008 | 10       | 5000  |<br>| 2       | 100        | 2009 | 12       | 5000  |<br>| 7       | 200        | 2011 | 15       | 9000  |<br>+———+————+——+———-+——-+<p></p>
<p>Product table:<br>+————+————–+<br>| product_id | product_name |<br>+————+————–+<br>| 100        | Nokia        |<br>| 200        | Apple        |<br>| 300        | Samsung      |<br>+————+————–+</p>
<p>Result table:<br>+————+————+———-+——-+<br>| product_id | first_year | quantity | price |<br>+————+————+———-+——-+<br>| 100        | 2008       | 10       | 5000  |<br>| 200        | 2011       | 15       | 9000  |<br>+————+————+———-+——-+</p></pre><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>我们需要按照年份和产品<code>id</code>分组，找出年份最小的。<br>要找到每个商品第一次销售的年份，我们需要应用<code>MIN</code>函数和<code>group by</code>,产生一个新的表单。 然后用<code>in</code>进行联结即可。</p>
<h4 id="示例代码-mysql"><a href="#示例代码-mysql" class="headerlink" title="示例代码 (mysql)"></a>示例代码 (mysql)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> product_id, S.year <span class="keyword">as</span> <span class="string">`first_year`</span>, quantity, price</span><br><span class="line"><span class="keyword">from</span> Sales <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> (S.product_id, S.year) <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> product_id, <span class="keyword">min</span>(<span class="keyword">year</span>)</span><br><span class="line">    <span class="keyword">from</span> Sales</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> product_id</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/1ErJszsDGJk" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1071] Greatest Common Divisor of Strings</title>
    <url>/Leetcode-1071-Greatest-Common-Divisor-of-Strings/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p><div class="sql-schema-wrapper__3VBi" style="margin-bottom: 15px; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><div class="content__u3I1 question-content__JfgR" style="margin: 1em 0px;"><div class="sql-schema-wrapper__3VBi" style="margin-bottom: 15px;"><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56);">For strings&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">T</code>, we say “<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">T</code>&nbsp;divides&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S</code>“ if and only if&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">S = T + … + T</code>&nbsp; (<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">T</code>&nbsp;concatenated with itself 1 or more times)</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56);">Return the largest string&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">X</code>&nbsp;such that&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">X</code>&nbsp;divides&nbsp;<font face="monospace">str1</font>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">X</code>&nbsp;divides&nbsp;<font face="monospace">str2</font>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56);"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>str1 = <span id="example-input-1-1">“ABCABC”</span>, str2 = <span id="example-input-1-2">“ABC”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">“ABC”</span><br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56);"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>str1 = <span id="example-input-2-1">“ABABAB”</span>, str2 = <span id="example-input-2-2">“ABAB”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">“AB”</span><br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56);"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>str1 = <span id="example-input-3-1">“LEET”</span>, str2 = <span id="example-input-3-2">“CODE”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">“”</span></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56);"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= str1.length &lt;= 1000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= str2.length &lt;= 1000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">str1[i]</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">str2[i]</code>&nbsp;are English uppercase letters.</li></ol></div></div></div><br><a id="more"></a></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题可以用递归来求解，和求两个数的最大公约数类似。<br>首先，<code>str1</code>和<code>str2</code>(假设<code>str1.size() &gt;= str2.size()</code>)有最大公约数的必要条件是<code>str1</code>的前缀等于<code>str2</code>。<br>原因如下，假设最大公约字符串为<code>divisor_str</code>，那么<code>str1 = x * divisor_str</code>，<code>str2 = y * divisor_str</code> (<code>x</code>, <code>y</code>为正整数，且<code>x &gt;= y</code>)，<br>所以<code>str1</code>的前<code>y</code>个<code>divisor_str</code>就等于<code>str2</code>。<br>其次，我们希望求两个字符串的最大公约字符串，就等于求两个字符串之差和其中一个字符串的最大公约字符串。还是用上述例子：<br><code>str1</code>与<code>str2</code>的最大公约数，也是<code>str1 - str2 = (y - x) * divisor_str</code> 与 <code>str2 = y * divisor_str</code>的最大公约数。<br>当<code>y = x</code>时，<code>str2</code>本身即为<code>str1</code>和<code>str2</code>的最大公约数。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">gcdOfStrings</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Puts longer string first</span></span><br><span class="line">        <span class="keyword">if</span> (str1.size() &lt; str2.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> gcdOfStrings(str2, str1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str2.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> str1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If str1 is not starts with str2, they don't have common divisor.</span></span><br><span class="line">        <span class="keyword">if</span> (str1.substr(<span class="number">0</span>, str2.size()) != str2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> gcdOfStrings(str1.substr(str2.size()), str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str1.length() &lt; str2.length()) &#123; <span class="comment">// make sure str1 is not shorter than str2.</span></span><br><span class="line">            <span class="keyword">return</span> gcdOfStrings(str2, str1); </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!str1.startsWith(str2)) &#123; <span class="comment">// shorter string is not common prefix.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>; </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str2.isEmpty()) &#123; <span class="comment">// gcd string found.</span></span><br><span class="line">            <span class="keyword">return</span> str1;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// cut off the common prefix part of str1.</span></span><br><span class="line">            <span class="keyword">return</span> gcdOfStrings(str1.substring(str2.length()), str2); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcdOfStrings</span><span class="params">(self, str1: str, str2: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> str1 <span class="keyword">or</span> <span class="keyword">not</span> str2:</span><br><span class="line">            <span class="keyword">return</span> str1 <span class="keyword">if</span> str1 <span class="keyword">else</span> str2</span><br><span class="line">        <span class="keyword">elif</span> len(str1) &lt; len(str2):</span><br><span class="line">            <span class="keyword">return</span> self.gcdOfStrings(str2, str1)</span><br><span class="line">        <span class="keyword">elif</span> str1[: len(str2)] == str2:</span><br><span class="line">            <span class="keyword">return</span> self.gcdOfStrings(str1[len(str2) :], str2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(M + N)</code>, <code>M</code>和<code>N</code>为<code>str1</code>和<code>str2</code>的长度, 主要是<code>str1.substr(0, str2.size()) != str2</code>这一判断会遍历一遍每一个字符<br>空间复杂度: <code>O(1)</code>, 栈的最大深度为<code>O(max(M, N))</code>, 因为最坏的情况<code>len(str2) = 1</code>，那么递归深度就是<code>len(str1)</code>, 即<code>O(M)</code>.</p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/pUfd6fT2kxk" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Atlassian</tag>
        <tag>Capital One</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1072] Flip Columns For Maximum Number of Equal Rows</title>
    <url>/Leetcode-1072-Flip-Columns-For-Maximum-Number-of-Equal-Rows/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given a&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">matrix</code>&nbsp;consisting of 0s and 1s, we may choose any number of columns in the matrix and flip&nbsp;<span style="font-weight: bolder;">every</span>&nbsp;cell in that column.&nbsp; Flipping a cell changes the value of that cell from 0 to 1 or from 1 to 0.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return the maximum number of rows that have all values equal after some number of flips.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"></ol><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-1-1">[[0,1],[1,1]]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">1</span><br><span style="font-weight: bolder;">Explanation: </span>After flipping no values, 1 row has all values equal.<br></pre><div><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-2-1">[[0,1],[1,0]]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">2</span><br><span style="font-weight: bolder;">Explanation: </span>After flipping values in the first column, both rows have equal values.<br></pre><div><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-3-1">[[0,0,0],[0,0,1],[1,1,0]]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-3">2</span><br><span style="font-weight: bolder;">Explanation: </span>After flipping values in the first two columns, the last two rows have equal values.<br></pre><p style="font-size: inherit; margin-bottom: 1em;">&nbsp;</p><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= matrix.length &lt;= 300</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= matrix[i].length &lt;= 300</code></li><li>All&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">matrix[i].length</code>‘s are equal</li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">matrix[i][j]</code>&nbsp;is&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0</code>&nbsp;or&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1</code></li></ol></div></div></div><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>若是需要暴力枚举解题，我们首先思考这个问题，要如何确定翻转哪些列？因为我们翻转的目的，是保证其中一行全是 <code>0</code>（或者 <code>1</code>）。所以我们可以考虑枚举每一行，使得这一行全部变成 0 （或者 1），然后统计其他行是否有所有值都相等的。</p>
<p>进一步考虑发现，我们没有必要对固定的那一行真正进行翻转。当某两行的值完全相等或 完全相反时，通过翻转列，我们总能把它们同时变为符合条件的行。</p>
<p>我们可以用每一行中每个元素相对第一个元素是否相同来组成一个特征字符串，用于代表这一行的特性。也就是说特征字符串相同的行，一定会同时变成满足条件的行(全是<code>0</code>或者<code>1</code>)。反之，若是不相同，一定不能同时变成满足条件的字符串。</p>
<p>举例说：对行 <code>100</code>，它的特征字符串都是<code>011</code>。对行<code>011</code>，它的特征字符串也是<code>011</code>。因此它们一定能同时变成满足题目要求的行。事实上，我们只要翻转第一列就可以了。</p>
<p>最后，我们用一个哈希表统计每个特征字符串的频率，频率最高的就是我们要的答案。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxEqualRowsAfterFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; row : matrix) &#123;</span><br><span class="line">            <span class="built_in">string</span> ele = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; val : row) &#123;</span><br><span class="line">                ele += val == row[<span class="number">0</span>] ? <span class="string">'0'</span> : <span class="string">'1'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mapping[ele]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [key, val] : mapping) &#123;</span><br><span class="line">            ans = max(ans, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEqualRowsAfterFlips</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span>[] flip = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) flip[j] = <span class="number">1</span> - matrix[i][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt; m; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(Arrays.equals(matrix[k], matrix[i]) || Arrays.equals(matrix[k], flip)) cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxEqualRowsAfterFlips</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cache = collections.defaultdict(int)</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">            vals = []</span><br><span class="line">            trans = []</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> row:</span><br><span class="line">                vals.append(c)</span><br><span class="line">                trans.append(<span class="number">1</span> - c)</span><br><span class="line">            cache[str(vals)] += <span class="number">1</span></span><br><span class="line">            cache[str(trans)] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(cache.values())</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><code>m</code>是<code>matrix</code>的行数，<code>n</code>是<code>matrix</code>的列数<br>时间复杂度: O(mn)<br>空间复杂度: O(m)</p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/C-mof8PvRzw" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1073] Adding Two Negabinary Numbers</title>
    <url>/Leetcode-1073-Adding-Two-Negabinary-Numbers/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given two numbers&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">arr1</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">arr2</code>&nbsp;in base&nbsp;<span style="font-weight: bolder;">-2</span>, return the result of adding them together.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Each number is given in&nbsp;<em>array format</em>:&nbsp; as an array of 0s and 1s, from most significant bit to least significant bit.&nbsp; For example,&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">arr = [1,1,0,1]</code>&nbsp;represents the number&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">(-2)^3&nbsp;+ (-2)^2 + (-2)^0 = -3</code>.&nbsp; A number&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">arr</code>&nbsp;in&nbsp;<em>array format</em>&nbsp;is also guaranteed to have no leading zeros: either&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">arr == [0]</code>&nbsp;or&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">arr[0] == 1</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Return the result of adding&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">arr1</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">arr2</code>&nbsp;in the same format: as an array of 0s and 1s with no leading zeros.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>arr1 = <span id="example-input-1-1">[1,1,1,1,1]</span>, arr2 = <span id="example-input-1-2">[1,0,1]</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">[1,0,0,0,0]<br></span><span style="font-weight: bolder;">Explanation: </span>arr1 represents 11, arr2 represents 5, the output represents 16.</pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= arr1.length &lt;= 1000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= arr2.length &lt;= 1000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">arr1</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">arr2</code>&nbsp;have no leading zeros</li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">arr1[i]</code>&nbsp;is&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0</code>&nbsp;or&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">arr2[i]</code>&nbsp;is&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">0</code>&nbsp;or&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题主要考察bit manipulation，也就是位数的转换。<br>与base 2相比，只需要每次<code>carry</code>变换符号即可，因为相邻位上<code>-2^n</code>与<code>-2^(n+1)</code>的符号相反。<br>但要注意，我们一定要使用<code>current &amp; 1</code> 以及 <code>-(current &gt;&gt; 1)</code> 来计算当前位的值以及<code>carry</code>的值，<br>如果使用<code>%</code>和除法的话，对于负数将得到错误的结果。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">addNegabinary</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rets;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = arr1.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = arr2.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = carry;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                current += arr1[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                current += arr2[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当current = -1时，使用 current % 1将得到-1</span></span><br><span class="line">            rets.push_back(current &amp; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 当current = -1时，使用 -current / 2将得到0</span></span><br><span class="line">            carry = -(current &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            --i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把前缀为0的位数去除，只保留最后一位</span></span><br><span class="line">        <span class="keyword">while</span> (rets.size() &gt; <span class="number">1</span> &amp;&amp; rets.back() == <span class="number">0</span>) &#123;</span><br><span class="line">            rets.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(rets.begin(), rets.end());</span><br><span class="line">        <span class="keyword">return</span> rets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] addNegabinary(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = arr1.length - <span class="number">1</span>, j = arr2.length - <span class="number">1</span>, carry = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = i &gt;= <span class="number">0</span> ? arr1[i--] : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> v2 = j &gt;= <span class="number">0</span> ? arr2[j--] : <span class="number">0</span>;</span><br><span class="line">            carry = v1 + v2 + carry;</span><br><span class="line">            stack.push(carry &amp; <span class="number">1</span>);</span><br><span class="line">            carry = -(carry &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() == <span class="number">0</span>) stack.pop();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            res[index++] = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.length == <span class="number">0</span> ? <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>] : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNegabinary</span><span class="params">(self, arr1: List[int], arr2: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        res = []</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> arr1 <span class="keyword">or</span> arr2 <span class="keyword">or</span> carry:</span><br><span class="line">            carry += (arr1 <span class="keyword">or</span> [<span class="number">0</span>]).pop() + (arr2 <span class="keyword">or</span> [<span class="number">0</span>]).pop()</span><br><span class="line">            res.append(carry &amp; <span class="number">1</span>)</span><br><span class="line">            carry = -(carry &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> len(res) &gt; <span class="number">1</span> <span class="keyword">and</span> res[<span class="number">-1</span>] == <span class="number">0</span>:</span><br><span class="line">            res.pop()</span><br><span class="line">        <span class="keyword">return</span> res[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(M + N)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/I8cGuDVViq8" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
        <tag>Grab</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1074] Number of Submatrices That Sum to Target</title>
    <url>/Leetcode-1074-Number-of-Submatrices-That-Sum-to-Target/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given a&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">matrix</code>, and a&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">target</code>, return the number of non-empty submatrices that sum to&nbsp;<font face="monospace">target</font>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">A submatrix&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x1, y1, x2, y2</code>&nbsp;is the set of all cells&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">matrix[x][y]</code>&nbsp;with&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x1 &lt;= x &lt;= x2</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">y1 &lt;= y &lt;= y2</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Two submatrices&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">(x1, y1, x2, y2)</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">(x1’, y1’, x2’, y2’)</code>&nbsp;are different if they have some coordinate&nbsp;that is different: for example, if&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">x1 != x1’</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>matrix = <span id="example-input-1-1">[[0,1,0],[1,1,1],[0,1,0]]</span>, target = <span id="example-input-1-2">0</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">4</span><br><span style="font-weight: bolder;">Explanation: </span>The four 1x1 submatrices that only contain 0.<br></pre><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>matrix = <span id="example-input-2-1">[[1,-1],[-1,1]]</span>, target = <span id="example-input-2-2">0</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">5</span><br><span style="font-weight: bolder;">Explanation: </span>The two 1x2 submatrices, plus the two 2x1 submatrices, plus the 2x2 submatrix.<br></pre></div><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;"><span style="font-weight: bolder;">Note:</span></span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= matrix.length &lt;= 300</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= matrix[0].length &lt;= 300</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">-1000 &lt;= matrix[i] &lt;= 1000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">-10^8 &lt;= target &lt;= 10^8</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这题是<code>presum</code>思想的变种二维版本。<br>首先我们可以把每一行的<code>presum</code>都先计算出来，用一个二维的<code>vector</code>保存。<br>之后，对任意两个列<code>col1</code>, <code>col2</code>, 计算<code>col1</code>和<code>col2</code>之间的所有数的和， 因为对于每一行，我们已经计算了它们对应的<code>presum</code>, 所以，对于<code>col1</code>,<code>col2</code>之间的数，可以通过<code>presum[row][col2+1]</code> - <code>presum[row][col1]</code> 迅速得到。（注意我们开<code>presum</code>数组时，选择多开一个，这样处理了第一个数的和的问题。详细参考c++代码）<br>我们可以依次得到在列区间<code>col1</code>, <code>col2</code>中，第<code>0</code>行到第<code>row</code>行的所有的数的和。用一个哈希表存下来，边可以查询满足题目要求的<code>Submatrix</code>。相当与又一个<code>presum</code>的思想。可参考<a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">leetcode 560题</a></p>
<p>综上所述，这题通过二维的presum运用的可以得到解答。相关的题目还有<a href="https://leetcode.com/problems/range-sum-query-2d-immutable/" target="_blank" rel="noopener">leetcode 304 Range Sum Query 2D - Immutable</a>。 大家可以练习下</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = A.size(), n = A[<span class="number">0</span>].size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">presum</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                presum[i][j] += presum[i][j - <span class="number">1</span>] + A[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; counter;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col1 = <span class="number">0</span>; col1 &lt; n + <span class="number">1</span>; col1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> col2 = col1 + <span class="number">1</span>; col2 &lt; n + <span class="number">1</span>; col2++) &#123;</span><br><span class="line">                counter = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">                <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; m; row++) &#123;</span><br><span class="line">                    cur += presum[row][col2] - presum[row][col1];</span><br><span class="line">                    res += counter.find(cur - target) != counter.end() ? counter[cur - target] : <span class="number">0</span>;</span><br><span class="line">                    counter[cur]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(<span class="keyword">int</span>[][] A, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = A.length, n = A[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                A[i][j] += A[i][j - <span class="number">1</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; counter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                counter.clear();</span><br><span class="line">                counter.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;</span><br><span class="line">                    cur += A[k][j] - (i &gt; <span class="number">0</span> ? A[k][i - <span class="number">1</span>] : <span class="number">0</span>);</span><br><span class="line">                    res += counter.getOrDefault(cur - target, <span class="number">0</span>);</span><br><span class="line">                    counter.put(cur, counter.getOrDefault(cur, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numSubmatrixSumTarget</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> matrix:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n - <span class="number">1</span>):</span><br><span class="line">                row[i + <span class="number">1</span>] += row[i]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> xrange(i, n):</span><br><span class="line">                c = collections.defaultdict(int)</span><br><span class="line">                cur, c[<span class="number">0</span>] = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> xrange(m):</span><br><span class="line">                    cur += matrix[k][j] - (matrix[k][i - <span class="number">1</span>] <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">                    res += c[cur - target]</span><br><span class="line">                    c[cur] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p><code>m</code>为行数，<code>n</code>为列数。<br>时间复杂度: O(mn^2)<br>空间复杂度: O(mn)</p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/svOoUutTOdo" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1075] Project Employees I</title>
    <url>/Leetcode-1075-Project-Employees-I/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p><div class="sql-schema-wrapper__3VBi" style="margin-bottom: 15px; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><a class="sql-schema-link__3cEg" style="color: rgb(96, 125, 139); outline: none; cursor: pointer; transition: border-bottom-color 0.3s ease 0s; touch-action: manipulation; pointer-events: auto; padding-bottom: 1px; border-bottom: 1px solid transparent;">SQL Schema<svg viewbox="0 0 24 24" width="1em" height="1em" class="icon__3Su4"><path fill-rule="evenodd" d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg></a></div><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Project</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| project_id  | int     |<br>| employee_id | int     |<br>+————-+———+<br>(project_id, employee_id) is the primary key of this table.<br>employee_id is a foreign key to <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">Employee</code> table.<br></pre><p style="font-size: inherit; margin-bottom: 1em;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Employee</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+——————+———+<br>| Column Name      | Type    |<br>+——————+———+<br>| employee_id      | int     |<br>| name             | varchar |<br>| experience_years | int     |<br>+——————+———+<br>employee_id is the primary key of this table.<br></pre><p style="font-size: inherit; margin-bottom: 1em;">&nbsp;</p><p style="font-size: inherit; margin-bottom: 1em;">Write an SQL query that reports the&nbsp;<span style="font-weight: bolder;">average</span>&nbsp;experience years of all the employees for each project,&nbsp;<span style="font-weight: bolder;">rounded to 2 digits</span>.</p><p style="font-size: inherit; margin-bottom: 1em;">The query result format is in the following example:</p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">Project table:<br>+————-+————-+<br>| project_id  | employee_id |<br>+————-+————-+<br>| 1           | 1           |<br>| 1           | 2           |<br>| 1           | 3           |<br>| 2           | 1           |<br>| 2           | 4           |<br>+————-+————-+<br>Employee table:<br>+————-+——–+——————+<br>| employee_id | name   | experience_years |<br>+————-+——–+——————+<br>| 1           | Khaled | 3                |<br>| 2           | Ali    | 2                |<br>| 3           | John   | 1                |<br>| 4           | Doe    | 2                |<br>+————-+——–+——————+<br>Result table:<br>+————-+—————+<br>| project_id  | average_years |<br>+————-+—————+<br>| 1           | 2.00          |<br>| 2           | 2.50          |<br>+————-+—————+<br>The average experience years for the first project is (3 + 2 + 1) / 3 = 2.00 and for the second project is (3 + 2) / 2 = 2.50</pre></div><br><a id="more"></a></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先将<code>Project</code>和<code>Employee</code> table通过<code>employee_id</code> join起来，然后group by <code>project_id</code>即可。</p>
<h4 id="示例代码-mysql"><a href="#示例代码-mysql" class="headerlink" title="示例代码 (mysql)"></a>示例代码 (mysql)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">SELECT</span> project_id, <span class="keyword">ROUND</span>(<span class="keyword">AVG</span>(experience_years), <span class="number">2</span>) average_years</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">Project</span> <span class="keyword">AS</span> p </span><br><span class="line"><span class="keyword">JOIN</span> Employee <span class="keyword">AS</span> e</span><br><span class="line"><span class="keyword">ON</span> p.employee_id = e.employee_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> project_id;</span><br></pre></td></tr></table></figure>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/bp0kuuE3fH0" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1076] Project Employees II</title>
    <url>/Leetcode-1076-Project-Employees-II/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Project</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| project_id  | int     |<br>| employee_id | int     |<br>+————-+———+<br>(project_id, employee_id) is the primary key of this table.<br>employee_id is a foreign key to <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">Employee</code> table.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Employee</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+——————+———+<br>| Column Name      | Type    |<br>+——————+———+<br>| employee_id      | int     |<br>| name             | varchar |<br>| experience_years | int     |<br>+——————+———+<br>employee_id is the primary key of this table.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Write an SQL query that reports all the&nbsp;<span style="font-weight: bolder;">projects</span>&nbsp;that have the most employees.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">The query result format is in the following example:</p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">Project table:<br>+————-+————-+<br>| project_id  | employee_id |<br>+————-+————-+<br>| 1           | 1           |<br>| 1           | 2           |<br>| 1           | 3           |<br>| 2           | 1           |<br>| 2           | 4           |<br>+————-+————-+<p></p>
<p>Employee table:<br>+————-+——–+——————+<br>| employee_id | name   | experience_years |<br>+————-+——–+——————+<br>| 1           | Khaled | 3                |<br>| 2           | Ali    | 2                |<br>| 3           | John   | 1                |<br>| 4           | Doe    | 2                |<br>+————-+——–+——————+</p>
<p>Result table:<br>+————-+<br>| project_id  |<br>+————-+<br>| 1           |<br>+————-+<br>The first project has 3 employees while the second one has 2.</p></pre><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题要查询所有项目(project)中拥有最多雇员的项目。需注意以下两点：</p>
<ol>
<li>为了要找出每个project_id中的雇员数量，需要对 project_id 使用 GROUP BY。</li>
<li>然后对每个项目的雇员进行加和。因project表的主键是(project_id, employee_id)，所以不会存在重复条目。</li>
</ol>
<p>另外一点是，需要先计算出最大雇员数，然后再查询雇员数与最大雇员数相等的项目即可。</p>
<h4 id="示例代码-mysql"><a href="#示例代码-mysql" class="headerlink" title="示例代码 (mysql)"></a>示例代码 (mysql)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> project_id </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">Project</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> project_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) = (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(employee_id) <span class="keyword">AS</span> cnt </span><br><span class="line">    <span class="keyword">FROM</span> <span class="keyword">Project</span> </span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> project_id </span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> cnt <span class="keyword">DESC</span> </span><br><span class="line">    <span class="keyword">LIMIT</span> <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/Po1RPxIWA9g" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>[Leetcode 1077] Project Employees III</title>
    <url>/Leetcode-1077-Project-Employees-III/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p><div class="sql-schema-wrapper__3VBi" style="margin-bottom: 15px; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><a class="sql-schema-link__3cEg" style="color: rgb(96, 125, 139); outline: none; cursor: pointer; transition: border-bottom-color 0.3s ease 0s; touch-action: manipulation; pointer-events: auto; padding-bottom: 1px; border-bottom: 1px solid transparent;">SQL Schema<svg viewbox="0 0 24 24" width="1em" height="1em" class="icon__3Su4"><path fill-rule="evenodd" d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg></a></div><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Project</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| project_id  | int     |<br>| employee_id | int     |<br>+————-+———+<br>(project_id, employee_id) is the primary key of this table.<br>employee_id is a foreign key to <code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">Employee</code> table.<br></pre><p style="font-size: inherit; margin-bottom: 1em;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Employee</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+——————+———+<br>| Column Name      | Type    |<br>+——————+———+<br>| employee_id      | int     |<br>| name             | varchar |<br>| experience_years | int     |<br>+——————+———+<br>employee_id is the primary key of this table.<br></pre><p style="font-size: inherit; margin-bottom: 1em;">&nbsp;</p><p style="font-size: inherit; margin-bottom: 1em;">Write an SQL query that reports the&nbsp;<span style="font-weight: bolder;">most experienced</span>&nbsp;employees in each project. In case of a tie, report all employees with the maximum number of experience years.</p><p style="font-size: inherit; margin-bottom: 1em;">The query result format is in the following example:</p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">Project table:<br>+————-+————-+<br>| project_id  | employee_id |<br>+————-+————-+<br>| 1           | 1           |<br>| 1           | 2           |<br>| 1           | 3           |<br>| 2           | 1           |<br>| 2           | 4           |<br>+————-+————-+<br>Employee table:<br>+————-+——–+——————+<br>| employee_id | name   | experience_years |<br>+————-+——–+——————+<br>| 1           | Khaled | 3                |<br>| 2           | Ali    | 2                |<br>| 3           | John   | 3                |<br>| 4           | Doe    | 2                |<br>+————-+——–+——————+<br>Result table:<br>+————-+—————+<br>| project_id  | employee_id   |<br>+————-+—————+<br>| 1           | 1             |<br>| 1           | 3             |<br>| 2           | 1             |<br>+————-+—————+<br>Both employees with id 1 and 3 have the most experience among the employees of the first project. For the second project, the employee with id 1 has the most experience.</pre></div><br><a id="more"></a></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题可以先列出所有的<code>project_id</code>和对应的<code>max(experience_years)</code>, 然后以<code>(project_id, max(experience_years))</code>为条件作filter即可。</p>
<h4 id="示例代码-mysql"><a href="#示例代码-mysql" class="headerlink" title="示例代码 (mysql)"></a>示例代码 (mysql)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> project_id, employee_id </span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">Project</span></span><br><span class="line"><span class="keyword">JOIN</span> Employee</span><br><span class="line"><span class="keyword">USING</span> (employee_id)</span><br><span class="line"><span class="keyword">WHERE</span> (project_id, experience_years) <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> project_id, <span class="keyword">MAX</span>(experience_years)</span><br><span class="line">    <span class="keyword">FROM</span> <span class="keyword">Project</span></span><br><span class="line">    <span class="keyword">JOIN</span> Employee</span><br><span class="line">    <span class="keyword">USING</span> (employee_id)</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> project_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/3Fnj1LLqSNo" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1078] Occurrences After Bigram</title>
    <url>/Leetcode-1078-Occurrences-After-Bigram/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given words&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">first</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">second</code>, consider occurrences in some&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">text</code>&nbsp;of the form “<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">first second third</code>“, where&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">second</code>&nbsp;comes immediately after&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">first</code>, and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">third</code>&nbsp;comes immediately after&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">second</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">For each such occurrence, add “<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">third</code>“ to the answer, and return the answer.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>text = <span id="example-input-1-1">“alice is a good girl she is a good student”</span>, first = <span id="example-input-1-2">“a”</span>, second = <span id="example-input-1-3">“good”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">[“girl”,”student”]</span><br></pre><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span>text = <span id="example-input-2-1">“we will we will rock you”</span>, first = <span id="example-input-2-2">“we”</span>, second = <span id="example-input-2-3">“will”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">[“we”,”rock”]</span><br></pre><p style="font-size: inherit; margin-bottom: 1em;">&nbsp;</p><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= text.length &lt;= 1000</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">text</code>&nbsp;consists of space separated words, where each word consists of lowercase English letters.</li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= first.length, second.length &lt;= 10</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">first</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">second</code>&nbsp;consist of lowercase English letters.</li></ol></div><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目的要求很简单，找出在<code>first</code>、<code>second</code>出现后紧跟着的第三个单词，而整句话是由空格和单词组成的。我们直接利用<code>istringstream</code>这个类处理串流，切分整句话，如果数组的当前元素的上一个元素等于<code>second</code>，且当前元素的上上一个元素等于<code>first</code>，就将当前元素添加进答案<code>vector</code>，最后返回记录答案的<code>vector</code>即可。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">findOcurrences</span><span class="params">(<span class="built_in">string</span> text, <span class="built_in">string</span> first, <span class="built_in">string</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(text)</span></span>;</span><br><span class="line">        <span class="built_in">string</span> firstStr = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> secondStr = <span class="string">""</span>;</span><br><span class="line">        <span class="built_in">string</span> cur;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ans;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstStr == first &amp;&amp; secondStr == second) &#123;</span><br><span class="line">                ans.emplace_back(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            firstStr = secondStr;</span><br><span class="line">            secondStr = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String[] findOcurrences(String text, String first, String second) &#123;</span><br><span class="line">        String a[]=text.split(<span class="string">" "</span>);</span><br><span class="line">       List&lt;String&gt; res=<span class="keyword">new</span> ArrayList();<span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">2</span>;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i].equals(first) &amp;&amp; a[i+<span class="number">1</span>].equals(second))</span><br><span class="line">            &#123;</span><br><span class="line">                res.add(a[i+<span class="number">2</span>]);</span><br><span class="line">               i=i+<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                i++;</span><br><span class="line">        &#125;</span><br><span class="line">        String temp[]=<span class="keyword">new</span> String[res.size()];</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String t: res)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[i]=t;i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOcurrences</span><span class="params">(self, text: str, first: str, second: str)</span> -&gt; List[str]:</span></span><br><span class="line">        third = []</span><br><span class="line">        sen = list(text.split())</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(sen)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> sen[i<span class="number">-1</span>] == first <span class="keyword">and</span> sen[i] == second:</span><br><span class="line">                third.append(sen[i+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> third</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(n)<br>空间复杂度: O(n)</p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/Ehu5LK_7Nu0" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1079] Letter Tile Possibilities</title>
    <url>/Leetcode-1079-Letter-Tile-Possibilities/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p><div class="sql-schema-wrapper__3VBi" style="margin-bottom: 15px; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56);">You have a set of&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">tiles</code>, where each tile has one letter&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">tiles[i]</code>&nbsp;printed on it.&nbsp; Return the number of possible non-empty sequences of letters you can make.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56);">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56);"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-1-1">“AAB”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-1">8</span><br><span style="font-weight: bolder;">Explanation: </span>The possible sequences are “A”, “B”, “AA”, “AB”, “BA”, “AAB”, “ABA”, “BAA”.<br></pre><div><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;">Input: </span><span id="example-input-2-1">“AAABBC”</span><br><span style="font-weight: bolder;">Output: </span><span id="example-output-2">188</span></pre></div><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56);"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em;"><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1 &lt;= tiles.length &lt;= 7</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">tiles</code>&nbsp;consists of uppercase English letters.</li></ol></div><br><a id="more"></a></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>采用递归的方式。用一个长度为26的<code>vector&lt;int&gt; ch_count</code>来记录当前剩余的每一个字母及对应的个数。<br>在递归函数<code>dfsCount</code>中，用<code>int count</code>表示当前<code>ch_count</code>能够组成的序列数，<br>遍历<code>ch_count</code>，每一个对应个数不为零的字母可以加入组合中，<code>count++</code>，对应的字母个数减一，然后调用递归函数。<br>调用完毕后，不要忘记backtracing，对应字母的个数应当恢复原样（加一）。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfsCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ch_count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ch_count.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch_count[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            ch_count[i]--;</span><br><span class="line">            count += dfsCount(ch_count);</span><br><span class="line">            ch_count[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numTilePossibilities</span><span class="params">(<span class="built_in">string</span> tiles)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ch_count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> tile : tiles) &#123;</span><br><span class="line">            ch_count[tile - <span class="string">'A'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfsCount(ch_count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTilePossibilities</span><span class="params">(String tiles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : tiles.toCharArray()) count[c - <span class="string">'A'</span>]++;</span><br><span class="line">        <span class="keyword">return</span> dfs(count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            sum++;</span><br><span class="line">            arr[i]--;</span><br><span class="line">            sum += dfs(arr);</span><br><span class="line">            arr[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTilePossibilities</span><span class="params">(self, tiles: str)</span> -&gt; int:</span></span><br><span class="line">        freq = collections.Counter(tiles)</span><br><span class="line">        prod = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> freq.values():</span><br><span class="line">            prod *= f + <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, prod):</span><br><span class="line">            digits = []</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> freq.values():</span><br><span class="line">                digits.append(i % (f + <span class="number">1</span>))</span><br><span class="line">                i = i // (f + <span class="number">1</span>)</span><br><span class="line">            tmp = math.factorial(sum(digits))</span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> digits:</span><br><span class="line">                tmp //= math.factorial(d)</span><br><span class="line">            res += tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(26^N)</code>, <code>N</code>为<code>tiles</code>的长度<br>空间复杂度: <code>O(1)</code>, 栈的深度为<code>O(N)</code></p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/My9FkIGAPos" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1080] Insufficient Nodes in Root to Leaf Paths</title>
    <url>/Leetcode-1080-Insufficient-Nodes-in-Root-to-Leaf-Paths/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Given the&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">root</code>&nbsp;of a binary tree, consider all&nbsp;<em>root to leaf paths</em>: paths from the root&nbsp;to any leaf.&nbsp; (A leaf is a node with no children.)</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">A&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">node</code>&nbsp;is&nbsp;<em>insufficient</em>&nbsp;if&nbsp;<span style="font-weight: bolder;">every</span>&nbsp;such root to leaf path intersecting this&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">node</code>&nbsp;has sum strictly less than&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">limit</code>.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Delete all insufficient nodes simultaneously, and return the root of the resulting&nbsp;binary tree.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Example 1:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;"><img alt src="https://assets.leetcode.com/uploads/2019/06/05/insufficient-11.png" style="border-style: none; max-width: 100%; height: 200px; width: 482px;"><br>Input: </span>root = <span id="example-input-1-1">[1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14]</span>, limit = <span id="example-input-1-2">1</span><br><span style="font-weight: bolder;"><img alt src="https://assets.leetcode.com/uploads/2019/06/05/insufficient-2.png" style="border-style: none; max-width: 100%; height: 200px; width: 258px;"><br>Output: </span><span id="example-output-1">[1,2,3,4,null,null,7,8,9,null,14]</span><br></pre><div style="color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 2:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;"><img alt src="https://assets.leetcode.com/uploads/2019/06/05/insufficient-3.png" style="border-style: none; max-width: 100%; height: 200px; width: 292px;"><br>Input: </span>root = <span id="example-input-2-1">[5,4,8,11,null,17,4,7,1,null,null,5,3]</span>, limit = <span id="example-input-2-2">22</span><br><span style="font-weight: bolder;"><img alt src="https://assets.leetcode.com/uploads/2019/06/05/insufficient-4.png" style="border-style: none; max-width: 100%; height: 200px; width: 264px;"><br>Output: </span><span id="example-output-2">[5,4,8,11,null,17,4,7,null,null,null,5]</span></pre><p style="font-size: inherit; margin-bottom: 1em;">&nbsp;</p><p style="font-size: inherit; margin-bottom: 1em;"><span style="font-weight: bolder;">Example 3:</span></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;"><span style="font-weight: bolder;"><img alt src="https://assets.leetcode.com/uploads/2019/06/11/screen-shot-2019-06-11-at-83301-pm.png" style="border-style: none; max-width: 100%; height: 150px; width: 188px;"><br>Input: </span>root = [1,2,-3,-5,null,4,null], limit = -1<br><img alt src="https://assets.leetcode.com/uploads/2019/06/11/screen-shot-2019-06-11-at-83517-pm.png" style="border-style: none; max-width: 100%; height: 150px; width: 122px;"><span style="font-weight: bolder;"><br>Output: </span>[1,null,-3,4]</pre></div><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><span style="font-weight: bolder;">Note:</span></p><ol style="margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;"><li>The given tree will have between&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">1</code>&nbsp;and&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">5000</code>&nbsp;nodes.</li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">-10^5&nbsp;&lt;= node.val &lt;= 10^5</code></li><li><code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">-10^9 &lt;= limit&nbsp;&lt;= 10^9</code></li></ol><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要去除所有不充分的点。这里对一个点是否充分的定义是：每一条从根节点开始，通过该点到达任意叶子节点的路径的和，都严格小于题目给出的值<code>Limit</code>。把所有不充分的点同时删除后，返回剩下的二叉树的根。<br>用<code>dfs</code>的方法解题，</p>
<ol>
<li>当一个节点是叶子节点时，直接判断它是否是充分的，如果不是，返回<code>nullptr</code>，否则返回该节点的指针。</li>
<li>当一个节点不是叶子节点时，判断它的子节点是不是都是不充分的。如果都是不充分的，那么返回<code>nullptr</code>，也就是说它也是不充分的。否则返回该节点的指针。</li>
</ol>
<p>工程上，<code>C++</code>可以选用<code>smart pointer</code>,从而不用考虑内存泄露的问题。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sufficientSubset</span><span class="params">(TreeNode* root, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, limit);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* node, <span class="keyword">int</span> limit, <span class="keyword">int</span> cur = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur += node-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt; limit) &#123;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;left = helper(node-&gt;left, limit, cur);</span><br><span class="line">        node-&gt;right = helper(node-&gt;right, limit, cur);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-java"><a href="#示例代码-java" class="headerlink" title="示例代码 (java)"></a>示例代码 (java)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sufficientSubset</span><span class="params">(TreeNode root, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root.val &lt; limit ? <span class="keyword">null</span> : root;</span><br><span class="line">        root.left = sufficientSubset(root.left, limit - root.val);</span><br><span class="line">        root.right = sufficientSubset(root.right, limit - root.val);</span><br><span class="line">        <span class="keyword">return</span> root.left == root.right ? <span class="keyword">null</span> : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sufficientSubset</span><span class="params">(self, root, limit)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type limit: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root.left == root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span> <span class="keyword">if</span> root.val &lt; limit <span class="keyword">else</span> root</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            root.left = self.sufficientSubset(root.left, limit - root.val)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            root.right = self.sufficientSubset(root.right, limit - root.val)</span><br><span class="line">        <span class="keyword">return</span> root <span class="keyword">if</span> root.left <span class="keyword">or</span> root.right <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: O(n)<br>空间复杂度: O(1)</p>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/tm6atdrcmkI" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 1082] Sales Analysis I</title>
    <url>/Leetcode-1082-Sales-Analysis-I/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Product</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————–+———+<br>| Column Name  | Type    |<br>+————–+———+<br>| product_id   | int     |<br>| product_name | varchar |<br>| unit_price   | int     |<br>+————–+———+<br>product_id is the primary key of this table.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Sales</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| seller_id   | int     |<br>| product_id  | int     |<br>| buyer_id    | int     |<br>| sale_date   | date    |<br>| quantity    | int     |<br>| price       | int     |<br>+—— ——+———+<br>This table has no primary key, it can have repeated rows.<br>product_id is a foreign key to Product table.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Write an SQL query that reports the best&nbsp;<span style="font-weight: bolder;">seller</span>&nbsp;by total sales price, If there is a tie, report them all.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">The query result format is in the following example:</p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">Product table:<br>+————+————–+————+<br>| product_id | product_name | unit_price |<br>+————+————–+————+<br>| 1          | S8           | 1000       |<br>| 2          | G4           | 800        |<br>| 3          | iPhone       | 1400       |<br>+————+————–+————+<p></p>
<p><code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">Sales </code>table:<br>+———–+————+———-+————+———-+——-+<br>| seller_id | product_id | buyer_id | sale_date  | quantity | price |<br>+———–+————+———-+————+———-+——-+<br>| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |<br>| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |<br>| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |<br>| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |<br>+———–+————+———-+————+———-+——-+</p>
<p>Result table:<br>+————-+<br>| seller_id   |<br>+————-+<br>| 1           |<br>| 3           |<br>+————-+<br>Both sellers with id 1 and 3 sold products with the most total price of 2800.</p></pre><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求找出最好的<code>seller</code>，如果有一样，那就把他们都找出来。我们需要注意两点：</p>
<ol>
<li><code>Sales</code>表中的<code>price</code>是<code>unit_price</code>与<code>quantity</code>的乘积，所以直接将表中对应<code>seller</code>每行的<code>price</code>加和即为销售额。所以，这就需要对<code>seller_id</code>使用<code>GROUP BY</code>后再<code>SUM(price)</code>。</li>
<li>得到每个<code>seller</code>的总销售额以后，按总销售额降序排列，用<code>LIMIT 1</code>取第一个。但这带来的问题是，如果有平手，则无法全部取出。解决方法是，先使用一个子查询得到最好的<code>seller</code>的销售额，然后再查询销售额等于这个的<code>seller</code>即可。</li>
</ol>
<h4 id="示例代码-mysql"><a href="#示例代码-mysql" class="headerlink" title="示例代码 (mysql)"></a>示例代码 (mysql)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> seller_id</span><br><span class="line"><span class="keyword">FROM</span> Sales</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> seller_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">SUM</span>(price) = (<span class="keyword">SELECT</span> <span class="keyword">SUM</span>(price) <span class="keyword">as</span> pr</span><br><span class="line">					 <span class="keyword">FROM</span> Sales</span><br><span class="line">                     <span class="keyword">GROUP</span> <span class="keyword">BY</span> seller_id</span><br><span class="line">                     <span class="keyword">ORDER</span> <span class="keyword">BY</span> pr <span class="keyword">DESC</span></span><br><span class="line">                     <span class="keyword">LIMIT</span> <span class="number">1</span> )</span><br></pre></td></tr></table></figure>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/nA0FdLBZwEs" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>[Leetcode 1084] Sales Analysis III</title>
    <url>/Leetcode-1084-Sales-Analysis-III/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p></p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Product</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————–+———+<br>| Column Name  | Type    |<br>+————–+———+<br>| product_id   | int     |<br>| product_name | varchar |<br>| unit_price   | int     |<br>+————–+———+<br>product_id is the primary key of this table.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Table:&nbsp;<code style="font-family: monospace; font-size: 13px; color: rgb(84, 110, 122); background-color: rgb(247, 249, 250); border-radius: 3px;">Sales</code></p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">+————-+———+<br>| Column Name | Type    |<br>+————-+———+<br>| seller_id   | int     |<br>| product_id  | int     |<br>| buyer_id    | int     |<br>| sale_date   | date    |<br>| quantity    | int     |<br>| price       | int     |<br>+—— ——+———+<br>This table has no primary key, it can have repeated rows.<br>product_id is a foreign key to Product table.<br></pre><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">&nbsp;</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">Write an SQL query that reports the&nbsp;<span style="font-weight: bolder;">products</span>&nbsp;that were&nbsp;<span style="font-weight: bolder;">only</span>&nbsp;sold in spring 2019. That is, between&nbsp;<span style="font-weight: bolder;">2019-01-01</span>&nbsp;and&nbsp;<span style="font-weight: bolder;">2019-03-31</span>&nbsp;inclusive.</p><p style="font-size: 14px; margin-bottom: 1em; color: rgb(38, 50, 56); font-family: -apple-system, system-ui, &quot;Segoe UI&quot;, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;;">The query result format is in the following example:</p><pre style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; margin-bottom: 1em; background: rgb(247, 249, 250); padding: 10px 15px; color: rgb(38, 50, 56); line-height: 1.6; border-radius: 3px; white-space: pre-wrap;">Product table:<br>+————+————–+————+<br>| product_id | product_name | unit_price |<br>+————+————–+————+<br>| 1          | S8           | 1000       |<br>| 2          | G4           | 800        |<br>| 3          | iPhone       | 1400       |<br>+————+————–+————+<p></p>
<p><code style="font-family: SFMono-Regular, Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13px; border-radius: 3px; tab-size: 4;">Sales </code>table:<br>+———–+————+———-+————+———-+——-+<br>| seller_id | product_id | buyer_id | sale_date  | quantity | price |<br>+———–+————+———-+————+———-+——-+<br>| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |<br>| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |<br>| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |<br>| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |<br>+———–+————+———-+————+———-+——-+</p>
<p>Result table:<br>+————-+————–+<br>| product_id  | product_name |<br>+————-+————–+<br>| 1           | S8           |<br>+————-+————–+<br>The product with id 1 was only sold in spring 2019 while the other two were sold after.</p></pre><br><a id="more"></a><p></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求找出只在<code>2019</code>年销售的<code>product</code>。</p>
<p>对<code>salse</code>表中的<code>product_id</code>进行<code>group by</code>操作，并与<code>product</code>表的<code>product_id</code>进行<code>join</code>就可以了。</p>
<h4 id="示例代码-mysql"><a href="#示例代码-mysql" class="headerlink" title="示例代码 (mysql)"></a>示例代码 (mysql)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.product_id, p.product_name</span><br><span class="line"><span class="keyword">FROM</span> Sales <span class="keyword">as</span> s</span><br><span class="line"><span class="keyword">JOIN</span> Product <span class="keyword">as</span> p</span><br><span class="line"><span class="keyword">ON</span> s.product_id = p.product_id</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> s.product_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MIN</span>(s.sale_date) &gt;= <span class="string">'2019-01-01'</span> <span class="keyword">AND</span></span><br><span class="line">       <span class="keyword">MAX</span>(s.sale_date) &lt;= <span class="string">'2019-03-31'</span></span><br></pre></td></tr></table></figure>
<h4 id="视频讲解"><a href="#视频讲解" class="headerlink" title="视频讲解"></a>视频讲解</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/_mxDFpTGa_M" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title>[Leetcode 112] Path Sum</title>
    <url>/Leetcode-112-Path-Sum/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.</p>
<p>For example:<br>Given the below binary tree and sum = 22,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
</code></pre><p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题给出一个数<code>sum</code>，要求判断二叉树中是否存在一条从根到叶<code>root-to-leaf</code>的路径，使得路径上数值的和等于<code>sum</code>。</p>
<p>事实上，如果存在这样一条路径，那么对于根节点的两个可能的子节点<code>left</code>和<code>right</code>, 两个中至少存在一条路径，使得从子节点<code>left</code>或者<code>right</code>到叶的路径的数值的和等于<code>sum - root.val</code>。以此类推，子节点的子节点亦是如此。</p>
<p>因此，我们自然想到利用递归，深度搜索的方法来解决此题。当搜索到叶节点时，如果叶节点的值<code>val</code>等于当时的<code>sum</code>,则找到了这样一条路径。</p>
<h4 id="示例代码-（python）"><a href="#示例代码-（python）" class="headerlink" title="示例代码 （python）"></a>示例代码 （python）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root, sum)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type sum: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right: <span class="comment">#当搜索到叶节点时</span></span><br><span class="line">            <span class="keyword">return</span> root.val == sum</span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, sum-root.val) <span class="keyword">or</span> self.hasPathSum(root.right, sum-root.val)</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>使用深度搜索<code>DFS</code>,每个节点被访问一次。并且递归过程中，栈的最大深度为O(n)。考虑到本题并非平衡二叉树，最差将退化成链表，而大O代表复杂度的上阈值，因此为O(n)。<br> 所以复杂度分析为：</p>
<ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>空间复杂度：<code>O(1)</code>, &#160; 递归栈深度<code>O(n)</code> </li>
</ul>
<h4 id="总结归纳："><a href="#总结归纳：" class="headerlink" title="总结归纳："></a>总结归纳：</h4><p>这是一道典型的用递归方法解决的树的问题，采用深度搜索<code>DFS</code>的方法也是比较基础。</p>
<p>大家可以在 <a href="/tags/Tree">Tree Tag</a> 中找到更多和树有关的内容，也可以在 <a href="/tags/Depth-first-Search">Depth-first Search tag</a> 中查找与深度搜索有关的题目。</p>
<p>不说了，忙着种香蕉树去了：） </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Tree</tag>
        <tag>Depth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 116] Populating Next Right Pointers in Each Node</title>
    <url>/Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary tree</p>
<pre><code>struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
</code></pre><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>
<p>Initially, all next pointers are set to <code>NULL</code>.</p>
<p><em>Note</em>:</p>
<p>You may only use constant extra space.</p>
<p>You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).</p>
<p>For example,</p>
<p>Given the following perfect binary tree,</p>
<pre><code>     1
   /  \
  2    3
 / \  / \
4  5  6  7
</code></pre><p>After calling your function, the tree should look like:</p>
<pre><code>     1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \  / \
4-&gt;5-&gt;6-&gt;7 -&gt; NULL
</code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题要去给一个完美二叉树加上next节点，如果没有类似节点则标记为<code>NULL</code>。结合给出的例子，还是题意还是比较清晰的。</p>
<p>最简单的思路，可以结合我们之前层序遍历二叉树的一题 <a href="/Leetcode-102-Binary-Tree-Level-Order-Traversal">[LeetCode 102] Binary Tree Level Order Traversal 二叉树层序遍历</a>，把每一层的节点按顺序加上next节点即可。然而，这样的空间复杂度会是O(n),并不符合要求。</p>
<p>为了优化空间复杂度，我们需要记录每层的信息，保存前一个节点，遍历到下一个节点之后，让前一个结点的next到当前节点（如果前面没有节点或者当前节点是最后一个，就另行处理）</p>
<p>具体而言，我们用<code>cur</code>记录当前层第一个节点。在每个层间，用<code>pre</code>记录当前节点的前一个节点。如果<code>pre</code>非空，那么把<code>pre.next</code>连接到当前节点<code>root.left</code>,再更新<code>pre</code>。当一层遍历完，就更新到下一层。 具体参看代码实例。结合题中给的树的例子和给出的示例代码，能更清晰的理解其中逻辑。</p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"># class TreeLinkNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param root, a tree link node</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">while</span> root.left:</span><br><span class="line">            cur = root.left</span><br><span class="line">            prev = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                <span class="keyword">if</span> prev:</span><br><span class="line">                    prev.next = root.left</span><br><span class="line">                root.left.next = root.right</span><br><span class="line">                prev = root.right</span><br><span class="line">                root = root.next</span><br><span class="line">            root = cur</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode *leftMost = <span class="literal">NULL</span>, *prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(root) &#123;</span><br><span class="line">            leftMost = root;</span><br><span class="line">            <span class="keyword">while</span>(root) &#123;</span><br><span class="line">                <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">                        prev-&gt;next = root-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">                    prev = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = <span class="literal">NULL</span>;</span><br><span class="line">            root = leftMost-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>广度搜索<code>BFS</code>遍历二叉树，每个节点被遍历一次，时间复杂度为O(n）。同时我们使用了<code>cur</code>，<code>pre</code>两个变量，空间复杂度为O(1)。因此复杂度分析为：</p>
<ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>空间复杂度：<code>O(1）</code></li>
</ul>
<h4 id="总结归纳："><a href="#总结归纳：" class="headerlink" title="总结归纳："></a>总结归纳：</h4><p>这题题意清晰。为了优化空间复杂度，需要我们对层序遍历做更细致的操作。</p>
<p>以后我们会再介绍本题的进阶版，对非完美二叉树改如何实现同样的操作。基本思路与这题相同，只是需要做更进一步的判断实现next的链接。有兴趣的朋友可以参看</p>
<p><a href="/Leetcode-117-Populating-Next-Right-Pointers-in-Each-Node-II">[LeetCode 117] Populating Next Right Pointers in Each Node II</a></p>
<p>种香蕉树去了^_^</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 117] Populating Next Right Pointers in Each Node II</title>
    <url>/Leetcode-117-Populating-Next-Right-Pointers-in-Each-Node-II/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Follow up for problem <em>“Populating Next Right Pointers in Each Node”</em>.</p>
<p>What if the given tree could be any binary tree? Would your previous solution still work?</p>
<p>Note:</p>
<ul>
<li>You may only use constant extra space.</li>
</ul>
<p>For example,</p>
<p>Given the following binary tree,</p>
<pre><code>     1
   /  \
  2    3
 / \    \
4   5    7
</code></pre><p>After calling your function, the tree should look like:</p>
<pre><code>     1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \    \
4-&gt; 5 -&gt; 7 -&gt; NULL
</code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这题是<a href="/Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node">[LeetCode 116] Populating Next Right Pointers in Each Node</a>的进阶题。从完美二叉树变成任意的二叉树。仍然要求空间复杂度为<code>O(n)</code>。</p>
<p>总体的思路不变，需要记录每层的信息，保存前一个节点，遍历到下一个节点之后，让前一个结点的<code>next</code>链接到当前节点。由于不能保证上一层的父节点都有子节点，因此我们需要对上一层父节点是否存在子节点做出额外的判断，然后遍历当前层的非空节点。这点与之前完美二叉树是不同的。</p>
<p>在示例代码中，<code>prev</code>可以看做一个存放当前遍历节点的前一个节点。而<code>leftMost</code>则指向当前层的第一个节点，遍历完整层后，利用<code>leftMost</code>更新下一层。如果对代码的逻辑理解不够清晰，建议用题目给出的二叉树做简单的验算，能有直观认识。</p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"># class TreeLinkNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param root, a tree link node</span></span><br><span class="line">    <span class="comment"># @return nothing</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            prev, leftMost = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    <span class="keyword">if</span> prev:</span><br><span class="line">                        prev.next = node.left</span><br><span class="line">                    prev = node.left</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> leftMost:</span><br><span class="line">                        leftMost = node.left</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    <span class="keyword">if</span> prev:</span><br><span class="line">                        prev.next = node.right</span><br><span class="line">                    prev = node.right</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> leftMost:</span><br><span class="line">                        leftMost = node.right</span><br><span class="line">                node = node.next</span><br><span class="line">            node = leftMost</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        TreeLinkNode *node = root;</span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            TreeLinkNode *prev = <span class="literal">NULL</span>, *leftMost = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">while</span> (node) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">                        prev-&gt;next = node-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = node-&gt;left;</span><br><span class="line">                    <span class="keyword">if</span> (!leftMost) &#123;</span><br><span class="line">                        leftMost = node-&gt;left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">                        prev-&gt;next = node-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    prev = node-&gt;right;</span><br><span class="line">                    <span class="keyword">if</span> (!leftMost) &#123;</span><br><span class="line">                        leftMost = node-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = leftMost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>广度搜索<code>BFS</code>遍历二叉树，每个节点被遍历一次，时间复杂度为O(n）。同时我们使用了<code>cur</code>，<code>pre</code>两个变量，空间复杂度为O(1)。因此复杂度分析为：</p>
<ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>空间复杂度： <code>O(1）</code></li>
</ul>
<h4 id="总结归纳："><a href="#总结归纳：" class="headerlink" title="总结归纳："></a>总结归纳：</h4><p>这题是对<a href="/Leetcode-116-Populating-Next-Right-Pointers-in-Each-Node">[LeetCode 116] Populating Next Right Pointers in Each Node</a>的进阶，要求更高。但总体解题的逻辑不变。因此此题的解法也完全适用于<code>Leetcode 166</code>。</p>
<p>种香蕉树去了^_^</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Tree</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 14] Longest Common Prefix</title>
    <url>/Leetcode-14-Longest-Common-Prefix/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Write a function to find the longest common prefix string amongst an array of strings.</p>
<p>If there is no common prefix, return an empty string <code>&quot;&quot;</code>.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> [“flower”,”flow”,”flight”]<br><strong>Output:</strong> “fl”</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> [“dog”,”racecar”,”car”]<br><strong>Output:</strong> “”</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<p>All given inputs are in lowercase letters <code>a-z</code>.</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题解法大致分为两步. 第一步获取输入中字符串的最小长度, 用来防止之后访问时的内存越界. 第二步, 依次判断字符串第i位的字符是否一样.<br>需要特别注意一些边界条件, 如输入空列表时直接返回空字符创.</p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(strs) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        ret = <span class="string">''</span></span><br><span class="line">        min_len = len(strs[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(strs)):</span><br><span class="line">            <span class="keyword">if</span> len(strs[i]) &lt; min_len:</span><br><span class="line">                min_len = len(strs[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(min_len):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, len(strs)):</span><br><span class="line">                <span class="keyword">if</span> strs[j][i] != strs[<span class="number">0</span>][i]:</span><br><span class="line">                    <span class="keyword">return</span> ret</span><br><span class="line">            ret += strs[<span class="number">0</span>][i]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(NK)</code>. N为列表长度, K为字符串长度<br>空间复杂度: <code>O(K)</code>. K为字符串长度</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>本题比较简单, 但是仍需注意边界条件, 不要大意出错.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 144] Binary Tree Preorder Traversal </title>
    <url>/Leetcode-144-Binary-Tree-Preorder-Traversal/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<p>For example:</p>
<p>Given binary tree [1,null,2,3],</p>
<pre><code>1   
 \
  2
 /
3
</code></pre><p>return [1,2,3].</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>深度遍历二叉树（<code>DFS</code>），可以分为</p>
<ul>
<li>前序遍历（<code>preorder</code>）</li>
<li>中序遍历（<code>inorder</code>）</li>
<li>后序遍历（<code>postorder</code>）</li>
</ul>
<p>这题要求使用前序遍历。前序遍历简单是说总是按照根节点（<code>root</code>），左子节点（<code>left</code>），右子节点（<code>right</code>）的顺序深度遍历二叉树。</p>
<p>我们可以使用递归与非递归两种方法来实现前序遍历。递归的方便比较简单，参看相关代码就能明白。这里主要讲一下非递归的方法：</p>
<p>使用栈（<code>stack</code>），每次visit当前节点<code>node</code>，同时如果当前节点的右子节点非空，将此右子节点存入栈中，再将当前节点<code>node</code>更新为当前节点的左子节点。直到遍历完整棵二叉树。具体步骤为：</p>
<ol>
<li>建立一个空栈<code>stack</code></li>
<li>如果当前节点<code>node</code>非空或者栈<code>stack</code>非空：<ul>
<li>2.1 如果当前节点<code>node</code>非空：<ul>
<li>访问当前节点<code>node</code></li>
<li>如果当前节点的右子节点非空，压入栈</li>
<li>更新当前节点<code>node</code>为它的左子节点，回到步骤2.1 </li>
</ul>
</li>
<li>2.2 如果栈非空，将当前节点更新为栈顶元素，并且退栈，回到步骤2</li>
</ul>
</li>
</ol>
<h4 id="示例代码-（递归-python版）"><a href="#示例代码-（递归-python版）" class="headerlink" title="示例代码 （递归 python版）"></a>示例代码 （递归 python版）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.preorderHelper(root, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderHelper</span><span class="params">(self, root, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">            self.preorderHelper(root.left, ans)</span><br><span class="line">            self.preorderHelper(root.right, ans)</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-（非递归-python版）"><a href="#示例代码-（非递归-python版）" class="headerlink" title="示例代码 （非递归 python版）"></a>示例代码 （非递归 python版）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root :</span><br><span class="line">                ans.append(root.val)</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    stack.append(root.right)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                root = stack.pop()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>对递归方法，每个节点都被访问一次，考虑到本题并非平衡二叉树，最差将退化成链表，递归栈最大深度为<code>O(n)</code>。所以复杂度分析为：</p>
<ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>空间复杂度：<code>O(1)</code>, &#160; 递归栈深度<code>O(n)</code></li>
</ul>
<p>对非递归方法，同样每个节点都被访问一次，考虑到本题并非平衡二叉树，最差将退化成链表，栈最大深度为<code>O(n)</code>。所以复杂度分析为：</p>
<ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>空间复杂度：<code>O(n)</code></li>
</ul>
<h4 id="总结归纳："><a href="#总结归纳：" class="headerlink" title="总结归纳："></a>总结归纳：</h4><p>树的遍历是对树的基本操作之一。今天我们讲了前序遍历。<br>相关的练习还有：</p>
<p><a href="/Leetcode-94-Binary-Tree-Inorder-Traversal">[LeetCode 94] Binary Tree Inorder Traversal 二叉树中序遍历</a></p>
<p><a href="/leetcode-145-Binary-Tree-Postorder-Traversal">[LeetCode 145] Binary Tree Postorder Traversal 二叉树后序遍历</a></p>
<p><a href="/Leetcode-102-Binary-Tree-Level-Order-Traversal">[LeetCode 102] Binary Tree Level Order Traversal 二叉树层序遍历</a></p>
<p>之后我们会继续讨论更多Tree相关的内容,并更新在 <a href="/tags/Tree">Tree Tag</a>，尽请期待，种香蕉树去了：）</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 162] Find Peak Element</title>
    <url>/Leetcode-162-Find-Peak-Element/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>A peak element is an element that is greater than its neighbors.</p>
<p>Given an input array where <code>num[i]</code> ≠ <code>num[i+1]</code>, find a peak element and return its index.</p>
<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>
<p>You may imagine that <code>num[-1]</code> = <code>num[n]</code> = <code>-∞</code>.</p>
<p>For example, in array <code>[1, 2, 3, 1]</code>, <code>3</code>is a peak element and your function should return the index number <code>2</code>.</p>
<p>Note:</p>
<p>Your solution should be in logarithmic complexity.</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求给出一个数列中峰值的位置。注意的是数列中可能存在若干个峰值，我们只要给出其中任意一个的位置即可。举个例子：数列 <code>[0,0,0,4,0,0,5,0,0]</code>， 它的峰值分别是<code>4</code>,<code>5</code>，因此答案应该是<code>3</code>或者<code>6</code>。</p>
<p>最直接的想法用暴力搜索，直接遍历一遍数组，给出最大值得位置即可。这样时间复杂度是 <code>O(n)</code>。</p>
<p>如果我们想要降低时间复杂度到<code>O(log n)</code>，直觉上可以用二分搜索（<code>Binary Search</code>）。若是只有一个峰值，设最左边位置为<code>low</code>，最右边位置为high，这样中间位置为 <code>mid = (high + low) / 2</code>。判断准则为，若是 <code>num[mid] &lt; num[mid+1]</code>, 我们就让<code>low = mid</code>，反之<code>high = mid</code>， 直到 <code>low + 1</code>等于<code>high</code>,终止二分。</p>
<p>有趣的是，如果存在若干个峰值，我们也不需要对以上算法进行改动。因为进过若干次的二分，在位置<code>low</code>和<code>high</code>之间终归会存在一个且仅有一个峰值。</p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low, high = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = int(low + (high - low) / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                high = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-c"><a href="#示例代码-c" class="headerlink" title="示例代码 (c++)"></a>示例代码 (c++)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low + <span class="number">1</span> &lt; high) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[mid + <span class="number">1</span>]) </span><br><span class="line">                low = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low] &gt; nums[high] ? low : high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>典型的二分法算法，并且只需要 <code>low</code>, <code>high</code>, <code>mid</code> 3个变量，所以时间和空间复杂度分别为：</p>
<ul>
<li>时间复杂度：O(log n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="总结归纳："><a href="#总结归纳：" class="headerlink" title="总结归纳："></a>总结归纳：</h4><p>这是一道经典的二分算法题（<code>Binary Search</code>），一般如果要求在对数时间复杂度下完成，我们可以考虑使用二分搜索。今天的解题就到这里了，种香蕉树去了：）</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Array</tag>
        <tag>Google</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 2] Add Two Numbers</title>
    <url>/Leetcode-2-Add-Two-Numbers/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p><strong>Example</strong>:<br><blockquote><p>Input: <code>(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</code><br>Output: <code>7 -&gt; 0 -&gt; 8</code><br>Explanation: <code>342 + 465 = 807</code>.</p>
</blockquote></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题考察对链表的熟练使用, 以及对边界条件的处理能力. 实际上Leetcode上有很多类似的题目, 同学们可以总结一套自己的模板, 这样面试中比较容易和面试官说清楚思路, 也可以避免出错. </p>
<p>本文的模板(c++)主要有以下几个需要注意的地方:</p>
<ul>
<li>用一个<code>dummy node</code>来指向返回节点</li>
<li>用一个变量<code>carry</code>来记住进位</li>
<li><code>while</code>循环有三个, 第一个是两个链表都没有走完的情况, 另两个是其中一个没有走完的情况</li>
<li>最后要记得判断一下<code>carry</code>不为零的情况, 这样还要再加一个节点</li>
</ul>
<p>该模板思路清晰, 但代码量稍多. 在python版中, 提供了另一种解法. 这种解法以<code>l1 || l2 || carry</code> 为终止条件, 写法上更为简洁.</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        ListNode* node = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = l1-&gt;val + l2-&gt;val + carry;</span><br><span class="line">            <span class="keyword">int</span> val = tmp % <span class="number">10</span>;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            node-&gt;next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l1) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = l1-&gt;val + carry;</span><br><span class="line">            <span class="keyword">int</span> val = tmp % <span class="number">10</span>;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            node-&gt;next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l2) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = l2-&gt;val + carry;</span><br><span class="line">            <span class="keyword">int</span> val = tmp % <span class="number">10</span>;</span><br><span class="line">            carry = tmp / <span class="number">10</span>;</span><br><span class="line">            node-&gt;next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            node-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        curr = dummy</span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> l2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">or</span> carry):</span><br><span class="line">            curr_val = <span class="number">0</span></span><br><span class="line">            curr_val += l1.val <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            curr_val += l2.val <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            l1 = l1.next <span class="keyword">if</span> l1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            l2 = l2.next <span class="keyword">if</span> l2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">            curr_val += carry</span><br><span class="line">            carry = curr_val &gt; <span class="number">9</span></span><br><span class="line">            curr.next = ListNode(curr_val - carry * <span class="number">10</span>)</span><br><span class="line">            curr = curr.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(max(m, n))</code>, <code>m</code>和<code>n</code>分别是链表<code>l1</code>和<code>l2</code>的长度<br>空间复杂度: <code>O(max(m, n))</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>面试中遇到这道题, 写完一定要用特殊例子检查一下. 因为本题思路很直接, 但是边界条件较多, 如果有边界条件没有考虑到会减分.</p>
<p>本文提供了两个模板, 同学们选择比较顺手的作为模板即可, 没有必要来回切换.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Microsoft</tag>
        <tag>Bloomberg</tag>
        <tag>Airbnb</tag>
        <tag>Adobe</tag>
        <tag>Math</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 236] Lowest Common Ancestor of a Binary Tree</title>
    <url>/Leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>
<p>According to the <a href="https://en.wikipedia.org/wiki/Lowest_common_ancestor" target="_blank" rel="noopener">definition of LCA on Wikipedia</a>: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we <strong>allow a node to be a descendant of itself</strong>).”</p>
<pre><code>      _______3______
     /              \
  ___5__          ___1__
 /      \        /      \
6       _2       0       8
        /  \
       7   4
</code></pre><p>For example, the lowest common ancestor (LCA) of nodes <code>5</code> and <code>1</code> is <code>3</code>. Another example is LCA of nodes <code>5</code> and <code>4</code> is <code>5</code>, since a node can be a descendant of itself according to the LCA definition.</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题要求找出两个节点的最近的共同祖先。</p>
<p>一个简单的思路是我们可以遍历整棵树，然后用一个<code>map</code>记录每个节点的父节点。这样可以找出节点<code>p</code>和<code>q</code>到根节点的<code>path</code>,然后就能方便的找出最近的共同祖先。但是这样要求我们用额外的<code>map</code>来记录每个节点的信息，空间复杂度为O(n)。</p>
<p>换一个思路，我们发现：假设对于一个节点，如果它的右子树里只找到了其中一个目标节点，而在它的左子树中没有找到另一个目标节点；或者它的左子树里只有一个目标节点，而它的右子树里没有另外一个目标界节点，那么当前节点就不是两个目标节点的最近公共祖先了。除此之外的情况，当前节点就是两个目标节点的公共祖先了。 我们可以从叶子节点向上，标记子树中出现目标节点的情况。若一个节点的左右子树都有标记，则当前节点就是共同祖先。</p>
<p>我们用递归的方法实现代码，会非常简洁。</p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">else</span> right</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode *left, *right;</span><br><span class="line">        <span class="keyword">if</span> (!root || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">        right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left &amp;&amp; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>最坏情况每个节点visit一次，因此时间复杂度为<code>O(n）</code>。<br>时间复杂度: <code>O(n)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>思考清楚共同祖先的定义，我们用递归的方法实现代码。同时我们可以看出，这题本质上还是对 <a href="/tags/Tree">Tree</a> 遍历的变种。</p>
<p>好了，这几天就和大家讨论到这里，种香蕉树去了。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 239] Sliding Window Maximum</title>
    <url>/Leetcode-239-Sliding-Window-Maximum/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an array <code>nums</code>, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p>
<p><strong>Example</strong>:<br><strong>Input</strong>: <code>nums = [1,3,-1,-3,5,3,6,7]</code>, and <code>k = 3</code><br><strong>Output</strong>: <code>[3,3,5,5,6,7]</code><br><strong>Explanation</strong>:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure></p>
<p><strong>Note</strong>:<br>You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array.</p>
<p><strong>Follow up</strong>:<br>Could you solve it in linear time?</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道比较好的面试题, 因为用priority queue的方法是容易想到的, 但是在实现的过程中也需要考虑一些边界条件, 比如刚开始扫的时候队列中少于<code>k</code>个数怎么处理, 什么时候结束等等. 这样方便面试官考察基本的coding能力.</p>
<p>对于followup, 相对来说要难一些, 用了双向队列(<code>deque</code>)结构来存储当前sliding window, 类似的问题有<a href="/Leetcode-316-Remove-Duplicate-Letters">[LeetCode 316] Remove Duplicate Letters 移除重复字母</a><br>, <a href="/Leetcode-739-Daily-Temperatures">[Leetcode 739] Daily Temperatures</a>. 如果面试中能够想到的话, 就很接近Strong Hire了.</p>
<p>为了方便更新sliding window以及取出当前最大元素, 我们用的数据结构是<code>deque</code>. <code>deque</code>存储的是<code>nums</code>中对应元素的<code>index</code>. 主要思路是使得<code>deque</code>中的元素由老到新, 由大到小排列, 并且只存储之后可能会成为最大值的元素. 具体的方法是: 首先将超出窗口范围的老元素从队列头移出, 每次新扫到的元素与队列尾元素比较, 如果新的元素大, 则<code>pop</code>当前队尾元素(因为被<code>pop</code>的元素在窗口内必然小于新元素, 所以之后任意一步都不会成为最大值), 不然则直接插入新元素. 这样每走一步, 当前的<code>deque</code>头元素即为窗口中的最大值.</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rets;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dq.front() == i - k) &#123;</span><br><span class="line">                    dq.pop_front();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (!dq.empty() &amp;&amp; nums[i] &gt; nums[dq.back()]) &#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.push_back(i);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) &#123;</span><br><span class="line">                rets.push_back(nums[dq.front()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span>         </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = []</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">while</span>(len(queue) <span class="keyword">and</span> (queue[<span class="number">0</span>] &lt;= i - k)):</span><br><span class="line">                queue.popleft()</span><br><span class="line">            <span class="keyword">while</span>(len(queue) <span class="keyword">and</span> (nums[queue[<span class="number">-1</span>]] &lt; nums[i])):</span><br><span class="line">                queue.pop()</span><br><span class="line">            queue.append(i)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k - <span class="number">1</span>:</span><br><span class="line">                ret.append(nums[queue[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code> 其中<code>n</code>为<code>nums</code>长度<br>空间复杂度: <code>O(k)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>同学们可以将解题思路中总结的类似题目一起做一遍, 这样对于处理这类问题会有更好的理解.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Google</tag>
        <tag>Heap</tag>
        <tag>Zenefits</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 250] Count Univalue Subtrees</title>
    <url>/Leetcode-250-Count-Univalue-Subtrees/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary tree, count the number of uni-value subtrees.</p>
<p>A Uni-value subtree means all nodes of the subtree have the same value.</p>
<p>For example:<br>Given binary tree,</p>
<pre><code>    5
   / \
  1   5
 / \   \
5   5   5
</code></pre><p>return 4.</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这题要求求出所有二叉树子树中，元素都相同的子树的个数。给出的例子中，以5为值得子树个数是4个，以1为值得子树个数是0，所以答案是4。</p>
<p>如果一个子树是满足条件的元素相同的子树，那以它的子节点为根的子树也一定是满足条件的元素相同的子树。因此，我们可以从叶子节点从下往上（<code>bottom-up</code>）判断。</p>
<p>如果两个以叶子节点为根的子树都是元素相同的子树，并且它们的值与父节点的值相同，则以父节点为根的子树也是满足条件的子树。但是节点没有父节点，无法往上判断，所以可以采用递归的方法从上往下调用判断。</p>
<p>在代码的实现过程中，这里我们用计数器<code>self.count</code>记录满足条件的子树个数，用一个辅助函数checkUni帮助我们从下往上查找<code>UnivalSubTree</code></p>
<h4 id="示例代码-（python）"><a href="#示例代码-（python）" class="headerlink" title="示例代码 （python）"></a>示例代码 （python）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countUnivalSubtrees</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.checkUni(root)</span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"></span><br><span class="line"><span class="comment"># If both children are "True" and root.val is equal to both children's values that exist, </span></span><br><span class="line"><span class="comment"># then root node is uniValue subtree node. </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkUni</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        l, r = self.checkUni(root.left), self.checkUni(root.right)</span><br><span class="line">        <span class="keyword">if</span> l <span class="keyword">and</span> r <span class="keyword">and</span> (<span class="keyword">not</span> root.left <span class="keyword">or</span> root.left.val == root.val) <span class="keyword">and</span> \</span><br><span class="line">        (<span class="keyword">not</span> root.right <span class="keyword">or</span> root.right.val == root.val):</span><br><span class="line">            self.count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>使用深度搜索<code>DFS</code>,每个节点被访问一次。并且递归过程中，递归栈的最大深度为O(n)。所以复杂度分析为:</p>
<ul>
<li>时间复杂度 O(n)</li>
<li>空间复杂度：<code>O(1)</code>, &#160; 递归栈深度<code>O(n)</code></li>
</ul>
<h4 id="归纳总结："><a href="#归纳总结：" class="headerlink" title="归纳总结："></a>归纳总结：</h4><p>递归方法解决树的问题。关键在于想明白父节点与子节点之间的关系。这里一个小点值得提醒，我们把空的节点判断为<code>True</code>, 这样方便于之后的计算。</p>
<p>大家可以在 <a href="/tags/Tree">Tree Tag</a> 中找到更多和树有关的内容，在 <a href="/tags/Depth-first-Search">Depth-first Search Tag</a> 中找到更多和深度搜索相关的问题。</p>
<p>要种香蕉树去了：）</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 297] Serialize and Deserialize Binary Tree</title>
    <url>/Leetcode-297-Serialize-and-Deserialize-Binary-Tree/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>
<p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<p>For example, you may serialize the following tree</p>
<pre><code>  1
 / \
2   3
   / \
  4   5
</code></pre><p>as <code>&quot;[1,2,3,null,null,4,5]&quot;</code>, just the same as <a href="https://leetcode.com/faq/#binary-tree" target="_blank" rel="noopener">how LeetCode OJ serializes a binary tree</a>. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p>
<p><strong>Note</strong>: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题要求设计两个函数，系列化和反序列化（重构）二叉树。</p>
<p>序列化函数：我们可以用层序遍历的方法将二叉树储存，可以参考<a href="/Leetcode-102-Binary-Tree-Level-Order-Traversal">[LeetCode 102] Binary Tree Level Order Traversal 二叉树层序遍历</a>， 需要注意的一点，遍历过程中，若是当前节点的子节点是空的，我们依然需要储存，这样才能在反序列函数中重构二叉树。</p>
<p>反序列化函数：用队列的数据结构，按层序读取序列，每次读取两个元素，对应当前节点的左右子节点。当序列元素非空时，将其设为当前节点对应的左节点或右节点，并加入队列内。直到读取完所有序列内元素，完成二叉树的重构。</p>
<p>另一种思路是用前序遍历。因为递归的实现比较trivial，这里用递推实现。同样，为了正确重构，我们仍然需要储存空节点。这里我们加入<code>writeAndReturnNode</code>这个辅助函数，让我们可以最大程度的复用原始的递推代码。需要额外注意不要使同一个节点被写一次以上。在解码时，由于在原代码push时不知道右子节点的情况，因此改为push本节点，并在pop时获取正确右子节点状态后，将<code>curr</code>改为右子节点。</p>
<h4 id="示例代码-思路一-python"><a href="#示例代码-思路一-python" class="headerlink" title="示例代码 思路一 (python)"></a>示例代码 思路一 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"None"</span></span><br><span class="line">        queue, ans = collections.deque(), collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            tmpNode = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> tmpNode == <span class="literal">None</span>:</span><br><span class="line">                ans.append(tmpNode)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(tmpNode.val)</span><br><span class="line">                queue.extend([tmpNode.left,tmpNode.right])</span><br><span class="line">        <span class="keyword">return</span> str(list(ans)) <span class="comment">#序列返回的结构和题目例子中给出的是一致的</span></span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="string">"""Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        data = data[<span class="number">1</span>:<span class="number">-1</span>].split(<span class="string">","</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.represents_int(data[<span class="number">0</span>]) <span class="keyword">or</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = TreeNode(int(data[<span class="number">0</span>]))</span><br><span class="line">        idx = <span class="number">1</span></span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> idx != len(data):</span><br><span class="line">            tmpNode = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> self.represents_int(data[idx]):</span><br><span class="line">                tmpNode.left = TreeNode(int(data[idx]))</span><br><span class="line">                queue.append(tmpNode.left)</span><br><span class="line">            <span class="keyword">if</span> self.represents_int(data[idx+<span class="number">1</span>]):</span><br><span class="line">                tmpNode.right = TreeNode(int(data[idx+<span class="number">1</span>]))</span><br><span class="line">                queue.append(tmpNode.right)</span><br><span class="line">            idx += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">represents_int</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>: </span><br><span class="line">            int(num)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># codec = Codec()</span></span><br><span class="line"><span class="comment"># codec.deserialize(codec.serialize(root))</span></span><br></pre></td></tr></table></figure>
<h4 id="示例代码-思路二-cpp"><a href="#示例代码-思路二-cpp" class="headerlink" title="示例代码 思路二 (cpp)"></a>示例代码 思路二 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">writeAndReturnNode</span><span class="params">(TreeNode* node, <span class="built_in">ostringstream</span>&amp; ret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            ret &lt;&lt; node-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ret &lt;&lt; <span class="string">"X "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> ret;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">        <span class="keyword">while</span> (writeAndReturnNode(root, ret) || !nodeStack.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root) &#123;</span><br><span class="line">                nodeStack.push(root-&gt;right);</span><br><span class="line">                root = writeAndReturnNode(root-&gt;left, ret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!nodeStack.empty()) &#123;</span><br><span class="line">                root = nodeStack.top();</span><br><span class="line">                nodeStack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">readAndReturnNode</span><span class="params">(<span class="built_in">istringstream</span>&amp; inStream)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> nextVal;</span><br><span class="line">        inStream &gt;&gt; nextVal;</span><br><span class="line">        <span class="keyword">if</span> (nextVal == <span class="string">"X"</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(stoi(nextVal));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        TreeNode *root, *curr, *next;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">inStream</span><span class="params">(data)</span></span>;</span><br><span class="line">        root = readAndReturnNode(inStream);</span><br><span class="line">        curr = root;</span><br><span class="line">        <span class="keyword">while</span> (curr || !nodeStack.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(curr) &#123;</span><br><span class="line">                curr-&gt;left = readAndReturnNode(inStream);</span><br><span class="line">                nodeStack.push(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!nodeStack.empty()) &#123;</span><br><span class="line">                curr = nodeStack.top();</span><br><span class="line">                nodeStack.pop();</span><br><span class="line">                curr-&gt;right = readAndReturnNode(inStream);</span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>每个节点被访问一次，同时我们用额外空间（队列/栈）来储存中间过程或答案，所以复杂度分析为<br>时间复杂度: <code>O(n)</code><br>空间复杂度: <code>O(n)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这是一道设计题，对二叉树的序列化和反序列还可以有其它灵活的处理方法。有兴趣的朋友可以再多做一些尝试。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Facebook</tag>
        <tag>Microsoft</tag>
        <tag>Bloomberg</tag>
        <tag>Uber</tag>
        <tag>Yahoo</tag>
        <tag>Google</tag>
        <tag>Tree</tag>
        <tag>LinkedIn</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 3] Longest Substring Without Repeating Characters</title>
    <url>/Leetcode-3-Longest-Substring-Without-Repeating-Characters/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p><strong>Examples</strong>:<br><blockquote><p>Given <code>&quot;abcabcbb&quot;</code>, the answer is <code>&quot;abc&quot;</code>, which the length is 3.</p>
<p>Given <code>&quot;bbbbb&quot;</code>, the answer is <code>&quot;b&quot;</code>, with the length of 1.</p>
<p>Given <code>&quot;pwwkew&quot;</code>, the answer is <code>&quot;wke&quot;</code>, with the length of 3. </p>
</blockquote><strong>Note</strong><br>The answer must be a substring, <code>&quot;pwke&quot;</code> is a subsequence and not a substring.</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题需要用一个<code>Hash Table</code>来记录当前字符上一次出现的<code>index</code>, 用一个变量<code>left</code>记录以当前字符结尾的符合题目条件的<code>substring</code>的左侧<code>index</code>. 注意<code>left</code>初始值为<code>-1</code>, 表示以当前字符结尾的符合题目条件的<code>substring</code>的起始位置等于<code>s</code>的起始位置 (<code>index</code>为<code>0</code>).</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapping.count(s[i])) &#123;</span><br><span class="line">                left = max(left, mapping[s[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">            mapping[s[i]] = i;</span><br><span class="line">            ret = max(ret, i - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        iLeft = <span class="number">-1</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        charDict = dict()</span><br><span class="line">        <span class="keyword">for</span> iRight <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[iRight] <span class="keyword">in</span> charDict <span class="keyword">and</span> charDict[s[iRight]] &gt;= iLeft:</span><br><span class="line">                iLeft = charDict[s[iRight]]</span><br><span class="line">            charDict[s[iRight]] = iRight</span><br><span class="line">            <span class="keyword">if</span> iRight - iLeft &gt; ret:</span><br><span class="line">                    ret = iRight - iLeft</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code> 其中<code>n</code>为<code>s</code>的长度<br>空间复杂度: <code>O(1)</code> 因为不同字符的数量有限(一般来说为256), 所以<code>mapping</code>的大小是恒定的</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这道题中的<code>mapping</code>可以用<code>vector&lt;int&gt;</code>代替<code>unordered_map</code>, 但是作者倾向于使用后者, 因为更有普遍性, 不容易与面试官产生分歧(比如面试官默认<code>s</code>只有26个字母, 那么<code>hard code</code>字符数为<code>256</code>就容易产生分歧), 即使一定要<code>hard code</code>字符数, 也需要和面试官说明.</p>
<p>这道题的思路产生过程并不直接, 面试中如果一下子想不清楚, 建议可以带一个例子, 一步步手动推导结果, 从中或许能够找到一些灵感, 至少也可以让面试官看到思考过程.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Bloomberg</tag>
        <tag>Yelp</tag>
        <tag>Adobe</tag>
        <tag>Hash Table</tag>
        <tag>String</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 31] Next Permutation</title>
    <url>/Leetcode-31-Next-Permutation/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Implement <strong>next permutation</strong>, which rearranges numbers into the lexicographically next greater permutation of numbers.</p>
<p>If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</p>
<p>The replacement must be in-place and use only constant extra memory.</p>
<p>Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p>
<blockquote><p>1,2,3 → 1,3,2<br>3,2,1 → 1,2,3<br>1,1,5 → 1,5,1</p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>不熟悉排列数的，可以看一下<a href="https://en.wikipedia.org/wiki/Permutation" target="_blank" rel="noopener">permutation</a>的基本定义。同时，我们要清楚字典顺序的定义<a href="https://en.wikipedia.org/wiki/Lexicographical_order" target="_blank" rel="noopener">Lexicographical order</a>。</p>
<p>最直接的想法是把所有的全排列找出，但是这显然不是最优解，并且不符合题目要求的<code>constant extra memory</code>。</p>
<p>我们这里用一个例子来说明如何找出下一个字典顺序的排列数。<br>假定我们有下面这组排列是</p>
<blockquote><p>6 5 4 8 7 5 1</p>
</blockquote>
<ul>
<li>我们从后往前看，找到第一个非递减的数，这里是 4 .</li>
<li>我们可以发现，以 <code>6 5 4</code>开头的排列数，<code>8 7 5 1</code> 已经是最后一个排列数，因此需要把 4 做替换</li>
<li>在 <code>8 7 5 1</code> 中，比 4 大的最小的数是 5，因此把 5 和 4 做交换，我们得到 <code>6 5 5 8 7 4 1</code></li>
<li>显然 <code>6 5 5 8 7 4 1</code> 并不是我们要求的，但只要把最后 4 位 <code>8 7 4 1</code> 做从小到大的排序，变成 <code>1 4 7 8</code>, 我们就得到了想要的字典顺序的排列数 <code>6 5 5 1 4 7 8</code>。</li>
</ul>
<p>按照这个思路，我们给出相对应的代码。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size(), left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i<span class="number">-1</span>] &lt; nums[i]) &#123;</span><br><span class="line">                left = i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; i &gt; left; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt; nums[i]) &#123;</span><br><span class="line">                    swap(nums[left], nums[i]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums.begin() + left + <span class="number">1</span>, nums.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>搜索第一个非递减的数，复杂度为 <code>O(n)</code>，reverse数组，复杂度为 <code>O(n)</code>, 所以总的时间复杂度是 <code>O(n)</code> 。<br>没用额外空间，复杂度是 <code>O(1)</code>。</p>
<ul>
<li>时间复杂度: <code>O(n)</code> </li>
<li>空间复杂度: <code>O(1)</code></li>
</ul>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这题主要需要先明白 <code>permutation</code> 和 <code>lexicographical order</code>, 然后才能找出 <code>next permutation</code>的规律。借助一些具体的例子，能帮助提供一些思路。比单纯抽象的思考可能更好。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 316] Remove Duplicate Letters</title>
    <url>/Leetcode-316-Remove-Duplicate-Letters/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a string which contains only lowercase letters, remove duplicate letters so that every letter appear once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.</p>
<p>Example:<br>Given <code>&quot;bcabc&quot;</code><br>Return <code>&quot;abc&quot;</code></p>
<p>Given <code>&quot;cbacdcbc&quot;</code><br>Return <code>&quot;acdb&quot;</code></p>
<h4 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h4><ol>
<li>建立哈希表（或者数组)<code>mapping</code>来统计字符串中每一个字母出现的频率</li>
<li>建立哈希表（或者数组)<code>visited</code>来记录已经插入<code>ret</code> (<strong>ret</strong>urn string) 的字母</li>
<li>将 <code>ret</code> 当作 <strong>stack</strong>，用 <strong>Greedy</strong> (贪心法）遍历字符串  <code>s</code>  ：<ul>
<li>若当前字符已经在 <code>visited</code> 中了，直接 continue</li>
<li>当前字符 <code>ch</code>  与  <code>ret</code>  字符串的末尾元素（栈顶）比较，若  <code>ch</code> 靠前，并且 <code>mapping</code> 中栈顶元素大于0 (即之后遍历中还会出现栈顶元素)，则 pop <code>ret</code>末尾元素，如此反复，直到  <code>ret</code>  末尾元素靠前，或者 <code>ret</code> 为空</li>
<li>在  <code>ret</code>  中插入当前字符 <code>ch</code></li>
<li>插入与 pop 过程都不要忘记更新 <code>visited</code></li>
</ul>
</li>
</ol>
<h4 id="示例代码-CPP"><a href="#示例代码-CPP" class="headerlink" title="示例代码(CPP)"></a>示例代码(CPP)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; visited;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            mapping[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; ch : s) &#123;</span><br><span class="line">            mapping[ch]--;</span><br><span class="line">            <span class="keyword">if</span> (visited.count(ch)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (ret.size() &amp;&amp; ret.back() &gt; ch &amp;&amp; mapping[ret.back()] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                visited.erase(ret.back());</span><br><span class="line">                ret.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            ret += ch;</span><br><span class="line">            visited.insert(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-PYTHON"><a href="#示例代码-PYTHON" class="headerlink" title="示例代码(PYTHON)"></a>示例代码(PYTHON)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicateLetters</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        map = Counter()</span><br><span class="line">        stack = list()</span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            map[c] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            map[c] -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>: visited.add(c)</span><br><span class="line">            <span class="keyword">while</span>(len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> c &lt; stack[<span class="number">-1</span>] <span class="keyword">and</span> map[stack[<span class="number">-1</span>]] &gt; <span class="number">0</span>):</span><br><span class="line">                visited.remove(stack[<span class="number">-1</span>])</span><br><span class="line">                stack.pop()</span><br><span class="line">            stack.append(c)</span><br><span class="line">            visited.add(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(stack)</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>因为每个字符插入和pop出ret都是最多一次，所以：</p>
<ul>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(n)</li>
</ul>
<h4 id="总结归纳："><a href="#总结归纳：" class="headerlink" title="总结归纳："></a>总结归纳：</h4><p>运用Stack加贪心法的题目有很多，这类问题的做法是遍历输入数组，当前元素与栈顶元素比较，如果当前元素更优（不同题目条件不同，比如本题对应当前元素较小）则pop栈顶元素，直到栈顶元素更优为止，而后插入当前元素。</p>
<p>最近会着重介绍这类题目，之后会将链接贴在这里，尽请期待，吃香蕉去了：）</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Stack</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 36] Valid Sudoku</title>
    <url>/Leetcode-36-Valid-Sudoku/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</p>
<ol>
<li>Each row must contain the digits 1-9 without repetition.</li>
<li>Each column must contain the digits 1-9 without repetition.</li>
<li>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</li>
</ol>
<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>&#39;.&#39;</code>.</p>
<img src="/Leetcode-36-Valid-Sudoku/lc36.png" width="400">
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong><br>[<br>      [“5” , “3” , “ . “ , “ . “ , “7” , “ . “ , “ . “ , “ . “ , “ . “],<br>      [“6” , “ . “ , “ . “ , “1” , “9” , “5” , “ . “ , “ . “ , “ . “],<br>      [“ . “ , “9” , “8” , “ . “ , “ . “ , “ . “ , “ . “ , “6” , “ . “],<br>      [“8” , “ . “ , “ . “ , “ . “ , “6” , “ . “ , “ . “ , “ . “ , “3”],<br>      [“4” , “ . “ , “ . “ , “8” , “ . “ , “3” , “ . “ , “ . “ , “1”],<br>      [“7” , “ . “ , “ . “ , “ . “ , “2” , “ . “ , “ . “ , “ . “ , “6”],<br>      [“ . “ , “6” , “ . “ , “ . “ , “ . “ , “ . “ , “2” , “8” , “ . “],<br>      [“ . “ , “ . “ , “ . “  , “4” , “1” , “9” , “ . “ , “ . “ , “5”],<br>      [“ . “ , “ . “ , “ . “ , “ . “ , “8” , “ . “ , “ . “ , “7” , “9”]<br>]<br><strong>Output:</strong> true</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong><br>[<br>      [“8” , “3” , “ . “ , “ . “ , “7” , “ . “ , “ . “ , “ . “ , “ . “],<br>      [“6” , “ . “ , “ . “ , “1” , “9” , “5” , “ . “ , “ . “ , “ . “],<br>      [“ . “ , “9” , “8” , “ . “ , “ . “ , “ . “ , “ . “ , “6” , “ . “],<br>      [“8” , “ . “ , “ . “ , “ . “ , “6” , “ . “ , “ . “ , “ . “ , “3”],<br>      [“4” , “ . “ , “ . “ , “8” , “ . “ , “3” , “ . “ , “ . “ , “1”],<br>      [“7” , “6” , “ . “ , “ . “ , “ . “ , “ . “ , “2” , “8” , “ . “],<br>      [“ . “ , “ . “ , “ . “ , “4” , “1” , “9” , “ . “ , “ . “ , “5”],<br>      [“ . “ , “ . “ , “ . “ , “ . “ , “8” , “ . “ , “ . “ , “7” , “9”]<br>]<br><strong>Output:</strong> false<br><strong>Explanation:</strong> Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8’s in the top left 3x3 sub-box, it is invalid.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ul>
<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
<li>Only the filled cells need to be validated according to the mentioned rules.</li>
<li>The given board contain only digits 1-9 and the character ‘.’.</li>
<li>The given board size is always 9x9.</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题要求确定一个 9 x 9 的数独是否valid。题目说明并不要求数独是可解的，因此难度不是很高。</p>
<p>根据数独的规则，需要对每一行，每一列，以及规定的 9 个 3 x 3 的矩阵做检查。因为每次检查需要对9个数进行查重，我们另外写一个函数 <code>isValidSec</code> ，用一个map记录下遍历过的值，遇到有相同的数字是返回<code>false</code>, 否则最终返回<code>true</code>。<br>然后分别按行、列、矩阵块遍历即可。 </p>
<p>具体代码如下：</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSudoku</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; nineNum;</span><br><span class="line">        <span class="comment">// 检查行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isValidSec(board[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board[<span class="number">0</span>].size(); i++) &#123;</span><br><span class="line">            nineNum.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board.size(); j++) &#123;</span><br><span class="line">                nineNum.push_back(board[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isValidSec(nineNum)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查矩阵块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.size(); i = i + <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].size(); j = j + <span class="number">3</span>) &#123;</span><br><span class="line">                nineNum.clear();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = i; l &lt; i+<span class="number">3</span>; l++)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> m = j; m &lt; j+<span class="number">3</span>; m++)&#123;</span><br><span class="line">                        nineNum.push_back(board[l][m]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!isValidSec(nineNum)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidSec</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&amp; nineNum)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; table;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; nineNum.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nineNum[i] != <span class="string">'.'</span> &amp;&amp; table.count(nineNum[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                table[nineNum[i]] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>我们遍历了3遍整个数独，因此时间复杂度为<code>O(n)</code>, 同时空间复杂度为<code>O(n^0.5)</code>.</p>
<ul>
<li>时间复杂度: <code>O(n)</code></li>
<li>空间复杂度: <code>O(n^0.5)</code></li>
</ul>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这题的难度不高，按照数独的规则一次做检查即可。代码虽然显得较长，但可读性会显得比较好。之后我们会再介绍这题的进阶版，<a href="/Leetcode-37-Sudoku-Solver">[LeetCode 37] Sudoku Solver</a>。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Uber</tag>
        <tag>Apple</tag>
        <tag>Hash Table</tag>
        <tag>Snapchat</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 4] Median of Two Sorted Arrays</title>
    <url>/Leetcode-4-Median-of-Two-Sorted-Arrays/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>There are two sorted arrays <code>nums1</code> and <code>nums2</code> of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be <code>O(log (m+n))</code>.</p>
<p><strong>Example 1</strong>:<br><blockquote><p><code>nums1 = [1, 3]</code><br><code>nums2 = [2]</code><br>The median is <code>2.0</code></p>
</blockquote><strong>Example 2</strong>:</p>
<blockquote><p><code>nums1 = [1, 2]</code><br><code>nums2 = [3, 4]</code><br>The median is <code>(2 + 3)/2 = 2.5</code></p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题的最优解比较难想到. 想到之后, 也要注意处理边界条件.</p>
<p>这里我们使用<code>Divide and Conquer</code>的方法: 首先抽象出一个函数, 用于寻找两个数组(由小到大)合并之后的第<code>k</code>个元素. 由于两个数组都是排好序的, 只需要比较他们的第<code>k / 2</code>个元素, 较小的那个元素至多排在合并后的第<code>k - 1</code>个位置, 因此该元素以及其左边的元素不可能为合并后的第<code>k</code>个元素, 均可以排除. 由此我们可以反复调用函数得到最终结果. 边界条件的处理请见代码.</p>
<p>这道题还可以使用二分搜索的办法, 但实际上掌握一种就足以应付面试了, 这里介绍的方法思路相对比较清晰. 读者如果对另一种方法感兴趣, 可以<a href="https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2471/very-concise-ologminmn-iterative-solution-with-detailed-explanation" target="_blank" rel="noopener">参考这里</a>.</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums2, nums1, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!m) &#123;  <span class="comment">// 较短的数组为空, 则直接返回另一个数组的第k个元素</span></span><br><span class="line">            <span class="keyword">return</span> nums2[k - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(nums1[<span class="number">0</span>], nums2[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = min(m, k / <span class="number">2</span>), j = min(n, k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &lt; nums2[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums1.begin() + i, nums1.end()), nums2, k - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums2.begin() + j, nums2.end()), k - j);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1, nums2, (m + n + <span class="number">1</span>) / <span class="number">2</span>) + findKth(nums1, nums2, (m + n + <span class="number">2</span>) / <span class="number">2</span>)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKth</span><span class="params">(self, nums1, nums2, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums1) &gt; len(nums2):</span><br><span class="line">            nums1, nums2 = nums2, nums1</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> len(nums1) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums2[k - <span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> min(nums1[<span class="number">0</span>], nums2[<span class="number">0</span>])</span><br><span class="line">        </span><br><span class="line">        k1 = min(len(nums1), k / <span class="number">2</span>)</span><br><span class="line">        k2 = min(len(nums2), k / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> nums1[k1 - <span class="number">1</span>] &lt; nums2[k1 - <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> self.findKth(nums1[k1:], nums2, k - k1)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.findKth(nums1, nums2[k2:], k - k2)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1, nums2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> (self.findKth(nums1, nums2, (len(nums1) + len(nums2) + <span class="number">1</span>) / <span class="number">2</span>) \</span><br><span class="line">                + self.findKth(nums1, nums2, (len(nums1) + len(nums2) + <span class="number">2</span>) / <span class="number">2</span>)) / <span class="number">2.</span></span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(log(m+n))</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这道题没有见过的话不太容易一下子想到. 面试中遇到不要太高兴直接写答案, 要分析思路. 如果类似难度的题目没有遇到过也不要紧张, 面试官很可能会给出提示, 比如面试官如果提示目标复杂度是<code>log</code>量级的, 那么就应该想到可能是二分搜索或者<code>Divide and Conquer</code>的解法.  </p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Apple</tag>
        <tag>Yahoo</tag>
        <tag>Adobe</tag>
        <tag>Dropbox</tag>
        <tag>Array</tag>
        <tag>Google</tag>
        <tag>Binary Search</tag>
        <tag>Zenefits</tag>
        <tag>Divide and Conquer</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 410] Split Array Largest Sum</title>
    <url>/Leetcode-410-Split-Array-Largest-Sum/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.</p>
<p><strong>Note</strong>:</p>
<p>If n is the length of array, assume the following constraints are satisfied:</p>
<ul>
<li>1 ≤ n ≤ 1000</li>
<li>1 ≤ m ≤ min(50, n)</li>
</ul>
<p><strong>Examples</strong>:</p>
<pre><code>Input:    
nums = [7,2,5,10,8]
m = 2

Output:
18

Explanation:
There are four ways to split nums into two subarrays. 
The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.
</code></pre><h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>本题给出一个数组<code>nums</code>和一个整数<code>m</code>,要求把数组<code>nums</code>分成连续的<code>m</code>份，找到所有分类中，子数组最大和的最小值。</p>
<p>显然，最简单的方法是可以使用<code>DFS</code>做暴力搜索，但是这样时间复杂度相当于从<code>n-1</code>个元素中抽取<code>m-1</code>个元素，为<code>O(n^m)</code>，会 TLE。</p>
<p>因为子数组本身是连续的，我们可以想到用动态规划 <a href="\tags\Dynamic-Programming">Dyanmic Programming</a> 来设计解法。定义<code>f[i][j]</code>为把数组 <code>nums[0,1,..,i]</code>分成<code>j</code>份后最大子数组和的最小值。显然，我们会有以下公式:<br><code>f[i][j] = max(f[k][j-1],nums[k+1]+...+nums[i) for all valid k</code><br>用动态规划，从<code>f[0][0]</code>出发，最后返回<code>f[n][m]</code> 即可。时间复杂度为<code>O(n^2*m)</code>，并且空间复杂度为<code>O(n*m)</code>。</p>
<p>这里，介绍一种更好的算法，运用 <a href="\tags\Binary-Search">Binary Search</a> 。考虑到数组元素都是非负整数，所以答案也一定是整数。同时，答案一定存在于 0 到 数组元素和<code>sum of array</code>之间。因此，我们只需能够判断，对于任意一个整数<code>mid</code>，是否存在一个分类使得<code>nums</code>能分成<code>m</code>份，并且最大子数组的和不超过<code>mid</code>。如果能，我们下调<code>Binary Search</code>，如果不能，我们上调<code>Binary Search</code>。</p>
<p>判断的算法也很简单，我们用贪心算法<code>Greedy</code>。用<code>tmpsum</code>记录当前子数组的和，用<code>count</code>记录当前的分类数。如果当前元素<code>num</code>加上<code>tmpsum</code>不超过<code>mid</code>，更新<code>tmpsum = tmpsum + num</code>；如果超过<code>mid</code>，更新<code>tmpsum = 0</code>并更新<code>count = count + 1</code>。遍历完数组<code>nums</code>， 当<code>count &lt;= m</code>，返回 <code>True</code>，反之返回<code>False</code>。</p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArray</span><span class="params">(self, nums, m)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low, high = <span class="number">0</span>, sum(nums)</span><br><span class="line">        <span class="keyword">while</span> low + <span class="number">1</span> &lt; high:</span><br><span class="line">            mid = int(low + (high - low) /<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> self.determinTrue(mid, nums, m):</span><br><span class="line">                high = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid</span><br><span class="line">        <span class="keyword">return</span> i <span class="keyword">if</span> self.determinTrue(low, nums, m) <span class="keyword">else</span> high</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">determinTrue</span><span class="params">(self, target, nums, m)</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        tmpsum, count = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &gt; target:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> tmpsum + num &lt;= target:</span><br><span class="line">                tmpsum += num</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmpsum = num</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count &lt;= m</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>每次贪心算法时间复杂度为<code>O(n)</code>，同时<code>Binary Search</code>需要的时间复杂度是<code>O(log(sum of array))</code>。因此总的时间复杂度为<code>O(n*(log(sum of array)))</code>。而空间复杂度为<code>O(n)</code>。</p>
<ul>
<li>时间复杂度: <code>O(n*(log(sum of array)))</code></li>
<li>空间复杂度: <code>O(n)</code></li>
</ul>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>当数组的和不过分大时，一般情况下，<a href="\tags\Binary-Search">Binary Search</a> 的时间复杂度都会优于<a href="\tags\Dynamic-Programming">Dyanmic Programming</a>。当然，这里能使用 <code>Binary Search</code>的前提是数组元素都是非负整数而<code>Dynamic Programming</code>则没有这个限制 。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Dynamic Programming</tag>
        <tag>Binary Search</tag>
        <tag>Baidu</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 5] Longest Palindromic Substring</title>
    <url>/Leetcode-5-Longest-Palindromic-Substring/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a string <code>s</code>, find the longest palindromic substring in <code>s</code>. You may assume that the maximum length of <code>s</code> is 1000.</p>
<p><strong>Example 1</strong>:<br><blockquote><p>Input: <code>&quot;babad&quot;</code><br>Output: <code>&quot;bab&quot;</code><br>Note: <code>&quot;aba&quot;</code> is also a valid answer.</p>
</blockquote><strong>Example 2</strong>:</p>
<blockquote><p>Input: <code>&quot;cbbd&quot;</code><br>Output: <code>&quot;bb&quot;</code></p>
</blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>很多<code>palindrome</code>相关的问题都可以用动态规划去解决. 做动态规划的问题, 要想清楚以下几件事情:</p>
<ul>
<li>动归数组代表了什么</li>
<li>递推公式是什么, 从而可以决定从什么方向开始递推. 例如<code>dp[i] = func(dp[i-1])</code>那就从左向右递推, 反之如果<code>dp[i] = func(dp[i+1])</code>那么就要从右向左递推</li>
<li>处理边界条件</li>
</ul>
<p>回到这道题, 我们用一个二维布尔数组<code>dp[j][i]</code>代表从<code>j</code>开始到<code>i</code>结束的子字符串是否为回文字符串. 初始条件为对于任意下标<code>i</code>, <code>dp[i][i]</code>为<code>true</code>, 这一初始条件可以在递推过程中更新. 递推公式和递推方向请见具体代码.</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> ret;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>))</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; <span class="comment">// i自左向右更新</span></span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123; <span class="comment">// j自右向左更新</span></span><br><span class="line">                dp[j][i] = (s[i] == s[j] &amp;&amp; (i - j &lt; <span class="number">2</span> || dp[j + <span class="number">1</span>][i - <span class="number">1</span>]));</span><br><span class="line">                <span class="comment">// 上面这行就是递推公式</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j][i]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (maxLen &lt; i - j + <span class="number">1</span>) &#123;</span><br><span class="line">                        maxLen = i - j + <span class="number">1</span>;</span><br><span class="line">                        left = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(left, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        maxlen = <span class="number">0</span></span><br><span class="line">        ret = <span class="literal">None</span></span><br><span class="line">        dp = [[<span class="literal">None</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s))] <span class="keyword">for</span> j <span class="keyword">in</span> range(len(s))]</span><br><span class="line">        <span class="keyword">for</span> right <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">for</span> left <span class="keyword">in</span> range(right, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                dp[left][right] = s[left] == s[right] <span class="keyword">and</span> (right - left &lt; <span class="number">3</span> <span class="keyword">or</span> dp[left + <span class="number">1</span>][right - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> dp[left][right] <span class="keyword">and</span> (right - left + <span class="number">1</span> &gt; maxlen):</span><br><span class="line">                    maxlen = right - left + <span class="number">1</span></span><br><span class="line">                    ret = s[left:right + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n^2)</code>, 其中<code>n</code>为<code>s</code>的长度<br>空间复杂度: <code>O(n^2)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>动态规划的题一般思路比较难想清楚, 但是有了思路之后代码实现比较容易. 因此面试中不要慌张, 记住本文归纳的三个要点, 先讨论清楚了再开始写代码.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Microsoft</tag>
        <tag>Bloomberg</tag>
        <tag>String</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 6] ZigZag Conversion</title>
    <url>/Leetcode-6-ZigZag-Conversion/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>The string <code>&quot;PAYPALISHIRING&quot;</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G  </span><br><span class="line">Y   I   R</span><br></pre></td></tr></table></figure></p>
<p>And then read line by line: <code>&quot;PAHNAPLSIIGYIR&quot;</code></p>
<p>Write the code that will take a string and make this conversion given a number of rows:<br><blockquote><p>string convert(string s, int numRows);</p>
</blockquote></p>
<p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3</span><br><span class="line">Output: &quot;PAHNAPLSIIGYIR&quot;</span><br></pre></td></tr></table></figure></p>
<p><strong>Example 2:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4</span><br><span class="line">Output: &quot;PINALSIGYAHRPI&quot;</span><br><span class="line">Explanation:</span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题需要把一个字符串变成ZigZag的排列后按行输出。所以我们只需要依次判断每个字符应该出现在ZigZag排列中的哪一行就可以了。<br>对于一个<code>N</code>行的ZigZag排列，我们可以把它看作一个周期为<code>2N - 2</code>的循环。在这个周期内，如果一个字符位于周期的前<code>N</code>位，<br>那么它的位数就是行号。如果在<code>N</code>位置后，那么它的行号就是超出部分的倒序，如<code>N + 1</code>那么，行号就是<code>N - 1</code>. (以上行号，从1开始计)</p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s, numRows)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type numRows: int</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        rows = [<span class="string">''</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(numRows)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            r = i % (<span class="number">2</span> * numRows - <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> r &gt;= numRows:</span><br><span class="line">                r = <span class="number">2</span> * numRows - r - <span class="number">2</span></span><br><span class="line">            rows[r] += s[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(rows)</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code> 其中<code>n</code>为<code>s</code>的长度<br>空间复杂度: <code>O(n)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这道题难度不高, 只需要考虑清楚字符串转换前后的对应关系即可。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 7] Reverse Integer</title>
    <url>/Leetcode-7-Reverse-Integer/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a 32-bit signed integer, reverse digits of an integer.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> 123<br><strong>Output:</strong> 321</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> -123<br><strong>Output:</strong> -321</p>
</blockquote></p>
<p><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> 120<br><strong>Output:</strong> 21</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1].<br>For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>解法比较简单, 按位取余即可. 难点在于如何处理溢出的问题. 在python中, 会自动处理溢出问题, 只需要直接判断是否在<code>INT_32</code>的范围内即可.<br>但是python的取余在负数上的行为与预期不同, 因此需要记下符号, 并转换成非负数. 其他语言中, 需要在结果乘<code>10</code>之前与<code>INT_MAX</code>作比较，观察是否会溢出.</p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sign = <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        x = x <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> -x</span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x != <span class="number">0</span>:</span><br><span class="line">            ret *= <span class="number">10</span></span><br><span class="line">            ret += x % <span class="number">10</span></span><br><span class="line">            x /= <span class="number">10</span></span><br><span class="line">        ret *= sign</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">-2</span>**<span class="number">31</span>) <span class="keyword">or</span> (ret &gt; <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(log n)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>在解题时需要考虑清楚何时会溢出, 或者转换成长整型后再作判断.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 719] Find K-th Smallest Pair Distance</title>
    <url>/Leetcode-719-Find-K-th-Smallest-Pair-Distance/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.</p>
<pre><code>**Example 1**:
Input:
nums = [1,3,1]
k = 1
Output: 0 
Explanation:
Here are all the pairs:
(1,3) -&gt; 2
(1,1) -&gt; 0
(3,1) -&gt; 2
Then the 1st smallest distance pair is (1,1), and its distance is 0.
</code></pre><p><strong>Note</strong>:</p>
<ol>
<li><code>2 &lt;= len(nums) &lt;= 10000.</code></li>
<li><code>0 &lt;= nums[i] &lt; 1000000.</code></li>
<li><code>1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2.</code></li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求求出第 k 个最小 pair 的距离。对于长度为n的数组，一共有 <code>n*(n-1)</code>个pair。如果我们求出所有 pair 的距离，然后排序找出第k个最小的pair的距离，时间复杂度会是 <code>O(n^2log(n))</code>，同时空间复杂度会是 <code>O(n^2)</code>， 这显然不是最优解。</p>
<p>可以对以上解法稍作优化，使用优先队列进行排序，这样时间复杂度会是<code>O(n^2log(k))</code>，空间复杂度会降低到 <code>O(k)</code>。</p>
<p>这题更好的一个解法是使用 <a href="\tags\Binary-Search">Binary Search</a>。对数组先进行排序，我们可以得到 pair 的最大距离<code>end</code>。因为题目讨论的都是整数，所以答案一定是在<code>0</code>到<code>end</code>的范围内的整数。我们在这个范围内使用 <code>Binary Search</code>，对于每一个搜索的值 <code>mid</code>，我们用一个函数<code>count</code>判断比<code>mid</code>小的 pair 的距离的个数。如果小于k，则让 start == mid ；反之，则让 end == mid。</p>
<p>因为我们对数组事先进行了排序，所以每一次调用count函数，用<code>window sliding</code>的方法，只需要遍历一边数组就可以。</p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallestDistancePair</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        start, end = <span class="number">0</span>, nums[<span class="number">-1</span>] - nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = int(start + (end - start)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> self.count(nums, mid) &lt; k:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">return</span> start <span class="keyword">if</span> self.count(nums,start) &gt;= k <span class="keyword">else</span> end</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(self, nums, mid)</span>:</span> <span class="comment">#比mid小的pair数</span></span><br><span class="line">        left, right, ans = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right != len(nums):</span><br><span class="line">            <span class="keyword">while</span> nums[right] - nums[left] &gt; mid:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            ans += right - left</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countPairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(high &lt; nums.size()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[high] - nums[low] &gt; mid) &#123;</span><br><span class="line">                low++;</span><br><span class="line">            &#125;</span><br><span class="line">            res += high - low;</span><br><span class="line">            high++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> low = nums[<span class="number">1</span>] - nums[<span class="number">0</span>], high = nums[nums.size()<span class="number">-1</span>] - nums[<span class="number">0</span>], mid;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i + <span class="number">1</span>] - nums[i] &lt; low) &#123;</span><br><span class="line">                low  = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (countPairs(nums, mid) &lt; k) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>排序数组的时间复杂度为<code>O(n log(n))</code>， <code>Binary Search</code>的遍历次数为<code>O(log(n))</code>，每次遍历调用 count 函数，需要遍历一边数组，时间复杂度为<code>O(n)</code>， 所以总的时间复杂度是<code>O(n log(n))</code>。用 in-place 的方法排序，不需要额外的空间，总的空间复杂度为 <code>O(1)</code></p>
<ul>
<li>时间复杂度: <code>O(n log(n))</code> </li>
<li>空间复杂度: <code>O(1)</code></li>
</ul>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>在有有效精度或者整数等条件给出的前提下，用 <a href="\tags\Binary-Search">Binary Search</a> 往往能有效的优化一些算法。之后我们会再多讨论这类题型。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Google</tag>
        <tag>Binary Search</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 739] Daily Temperatures</title>
    <url>/Leetcode-739-Daily-Temperatures/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a list of daily <code>temperatures</code>, produce a list that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.</p>
<p>For example, given the list <code>temperatures = [73, 74, 75, 71, 69, 72, 76, 73]</code>, your output should be <code>[1, 1, 4, 2, 1, 1, 0, 0]</code>.</p>
<p>Note: The length of <code>temperatures</code> will be in the range <code>[1, 30000]</code>. Each temperature will be an integer in the range <code>[30, 100]</code>.</p>
<h4 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h4><p>这又是一道可以用<a href="/tags/Stack">Stack</a>来解决的问题。</p>
<ol>
<li>建立降序栈<code>stk</code>,存<code>temperatures</code>数组对应的 index</li>
<li>建立返回数组<code>rets</code>并且初始化为0</li>
<li>遍历<code>temperatures</code>数组：<ul>
<li>每一个元素<code>temp</code>和<code>stk</code>的栈顶元素对应值比较，如果<code>temp</code>较大，说明遇到了 warmer temperature，所以在<code>rets</code>中更新栈顶元素对应的值，并且 pop 栈顶元素</li>
<li>重复上述过程，直到<code>stk</code>为空或者<code>temp</code>比栈顶值小，将当前<code>index</code> 进栈</li>
</ul>
</li>
</ol>
<h4 id="示例代码-CPP"><a href="#示例代码-CPP" class="headerlink" title="示例代码(CPP)"></a>示例代码(CPP)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = temperatures.size();</span><br><span class="line">        <span class="comment">// 注意需要初始化为0</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">rets</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.empty() &amp;&amp; temperatures[i] &gt; temperatures[stk.top()]) &#123;</span><br><span class="line">                rets[stk.top()] = i - stk.top();</span><br><span class="line">                stk.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注意push的是index，不是值</span></span><br><span class="line">            stk.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-PYTHON"><a href="#示例代码-PYTHON" class="headerlink" title="示例代码(PYTHON)"></a>示例代码(PYTHON)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dailyTemperatures</span><span class="params">(self, temperatures)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type temperatures: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 使用List代替stack</span></span><br><span class="line">        stack = list()</span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span>  i <span class="keyword">in</span> range(len(temperatures))]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(temperatures)):</span><br><span class="line">            <span class="keyword">while</span>(len(stack) &gt; <span class="number">0</span> <span class="keyword">and</span> temperatures[i] &gt; temperatures[stack[<span class="number">-1</span>]]):</span><br><span class="line">                res[stack[<span class="number">-1</span>]] = i - stack[<span class="number">-1</span>];</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="comment"># append等效为stack中的push</span></span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>因为每个字符<code>push</code>和<code>pop</code>都是最多一次，所以：</p>
<ul>
<li>时间复杂度：<code>O(n)</code></li>
<li>空间复杂度：<code>O(n)</code></li>
</ul>
<h4 id="总结归纳："><a href="#总结归纳：" class="headerlink" title="总结归纳："></a>总结归纳：</h4><p>运用<a href="/tags/Stack">Stack</a>的题目很多，这类问题的做法是遍历输入数组，当前元素与栈顶元素比较，如果当前元素更优（不同题目条件不同，比如本题对应当前元素较大）则pop栈顶元素，直到栈顶元素更优为止，而后插入当前元素。</p>
<p>类似的题目还有：<br><a href="/Leetcode-316-Remove-Duplicate-Letters">[LeetCode 316] Remove Duplicate Letters 移除重复字母</a></p>
<p>最近会总结更多这类题目更新在<a href="/tags/Stack">Stack Tag</a>中，尽请期待，吃香蕉去了：）</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 777] Swap Adjacent in LR String</title>
    <url>/Leetcode-777-Swap-Adjacent-in-LR-String/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>In a string composed of <code>&#39;L&#39;</code>, <code>&#39;R&#39;</code>, and <code>&#39;X&#39;</code> characters, like “RXXLRXRXL”, a move consists of either replacing one occurrence of <code>&quot;XL&quot;</code> with <code>&quot;LX&quot;</code>, or replacing one occurrence of <code>&quot;RX&quot;</code> with <code>&quot;XR&quot;</code>. Given the starting string start and the ending string end, return True if and only if there exists a sequence of moves to transform one string to the other.</p>
<pre><code>Example:
Input: start = &quot;RXXLRXRXL&quot;, end = &quot;XRLXXRRLX&quot;
Output: True
Explanation:
We can transform start to end following these steps:
RXXLRXRXL -&gt;
XRXLRXRXL -&gt;
XRLXRXRXL -&gt;
XRLXXRRXL -&gt;
XRLXXRRLX
</code></pre><p><strong>Note</strong>:</p>
<ol>
<li>1 &lt;= len(start) = len(end) &lt;= 10000.</li>
<li>Both start and end will only consist of characters in <code>{&#39;L&#39;, &#39;R&#39;, &#39;X&#39;}</code>.</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目要求根据给定的规则，判断能否从 start string 变换到 end string 。</p>
<p>给出了两种变换的规则，从“XL”到“LX”和从“RX”到“XR”。所以我们可以给出两条规律：</p>
<ul>
<li>如果start能变换到end，那么除去两个字符串中的<code>&quot;X&quot;</code>，剩余的字符串一定相同。因为任意<code>&quot;R&quot;</code>和<code>&quot;L&quot;</code>的相对顺序都不会发生变化，我们定义出去<code>&quot;X&quot;</code>的字符串为有效字符串</li>
<li>根据变换的规则，<code>&quot;L&quot;</code>不能向右移，<code>“R”</code>不能向左移，所以 start 中<code>“L”</code>对应的 index <code>&quot;i&quot;</code> 一定不小于 end 中 <code>“L”</code>对应的index <code>&quot;j&quot;</code>；start 中<code>“R”</code>对应的 index <code>&quot;i&quot;</code> 一定不大于 end 中 <code>“R”</code>对应的index <code>&quot;j&quot;</code>；<ol>
<li>i &gt;= j, 如果 start[i]==end[j]==”L”</li>
<li>i &lt;= j, 如果 start[i]==end[j]==”R”</li>
</ol>
</li>
</ul>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canTransform</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type start: str</span></span><br><span class="line"><span class="string">        :type end: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 第一条规律</span></span><br><span class="line">        startRemove = <span class="string">""</span>.join(start.split(<span class="string">"X"</span>))</span><br><span class="line">        endRemove = <span class="string">""</span>.join(end.split(<span class="string">"X"</span>))</span><br><span class="line">        <span class="keyword">if</span> startRemove != endRemove:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="comment"># 第二条规律</span></span><br><span class="line">        i, j, n = <span class="number">0</span>, <span class="number">0</span>, len(start)</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n <span class="keyword">and</span> i &lt; n):</span><br><span class="line">            <span class="keyword">while</span>(j &lt; n <span class="keyword">and</span> end[j] == <span class="string">'X'</span>):</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; n <span class="keyword">and</span> start[i] == <span class="string">'X'</span>):</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span>(i == n <span class="keyword">and</span> j == n): </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span>(start[i] == <span class="string">'R'</span> <span class="keyword">and</span> i &gt; j) <span class="keyword">or</span> (start[i] == <span class="string">'L'</span> <span class="keyword">and</span> i &lt; j):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>每个字符串遍历一边，时间复杂度为<code>O(n)</code>。没有用额外空间，时间复杂度为<code>O(1)</code><br>时间复杂度: <code>O(n)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>本题需要对变换的规律做出总结，找出不变量，从而做出进一步判断。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Brainteaser</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 802] Find Eventual Safe States</title>
    <url>/Leetcode-802-Find-Eventual-Safe-States/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>In a directed graph, we start at some node and every turn, walk along a directed edge of the graph.  If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.</p>
<p>Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node.  More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than <code>K</code> steps.</p>
<p>Which nodes are eventually safe?  Return them as an array in sorted order.</p>
<p>The directed graph has <code>N</code> nodes with labels <code>0, 1, ..., N-1</code>, where <code>N</code> is the length of graph.  The graph is given in the following form: <code>graph[i]</code> is a list of labels <code>j</code> such that <code>(i, j)</code> is a directed edge of the graph.</p>
<blockquote><p><strong>Example:</strong><br><strong>Input:</strong> graph = <code>[[1,2],[2,3],[5],[0],[5],[],[]]</code><br><strong>Output:</strong> <code>[2,4,5,6]</code></p>
</blockquote>
<img src="/Leetcode-802-Find-Eventual-Safe-States/graph_illustration.png" width="400" title="illustration of graph">
<p><strong>Note:</strong></p>
<ul>
<li><code>graph</code> will have length at most <code>10000</code>.</li>
<li>The number of edges in the graph will not exceed <code>32000</code>.</li>
<li>Each <code>graph[i]</code> will be a sorted list of different integers, chosen within the range <code>[0, graph.length - 1]</code>.</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>首先需要理解题意, 所谓<code>safe node</code>是指<strong>所有</strong>经过该node的路径都最后结束于<code>terminal node</code>, 也就是说不会形成环.<br>所以我们可以给每个node三个状态,分别为:<br><blockquote><p>0: unvisited<br>1: unsafe<br>2: safe</p>
</blockquote>利用dfs遍历每一个node (返回值为当前路径是否<code>safe</code>):</p>
<ul>
<li>如果node的状态为<code>unvisited</code>, 那么我们初始化该node转态为<code>unsafe</code>, 并用dfs遍历其所有路径,如果其中有任意一条范围为<code>unsafe</code>, 那么直接<code>break</code>. 如果所有路径返回均为<code>safe</code>,那么设该node状态为<code>safe</code>并返回.</li>
<li>如果node状态为<code>unsafe</code>, 那么有两种情况, 要么是之前dfs遍历时访问过, 确定为<code>unsafe</code>状态; 要么是当前访问路径下之前经过了该点, 说明当前路径形成了环. 不管是哪一种情况, 当前node的<code>unsafe</code>状态都不会改变, 直接返回<code>false</code>.</li>
<li>如果node状态为<code>safe</code>, 那么肯定是之前dfs遍历过, 确定为<code>safe</code>状态, 直接返回即可.</li>
</ul>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; states, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (states[cur] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (states[cur] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        states[cur] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; nei : graph[cur]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(graph, states, nei)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        states[cur] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">eventualSafeNodes</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">states</span><span class="params">(graph.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.size(); ++i) &#123;</span><br><span class="line">            dfs(graph, states, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rets;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; states.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (states[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                rets.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, graph, state, curr_idx)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> state[curr_idx]:</span><br><span class="line">            <span class="keyword">return</span> state[curr_idx]</span><br><span class="line">        state[curr_idx] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> next_node_idx <span class="keyword">in</span> graph[curr_idx]:</span><br><span class="line">            next_state = self.dfs(graph, state, next_node_idx)</span><br><span class="line">            <span class="keyword">if</span> next_state == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> state[curr_idx]</span><br><span class="line">        state[curr_idx] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> state[curr_idx]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eventualSafeNodes</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = []</span><br><span class="line">        state = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph))]</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(graph)):</span><br><span class="line">            <span class="keyword">if</span> self.dfs(graph, state, idx) == <span class="number">2</span>:</span><br><span class="line">                ret.append(idx)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code> 因为每个node经过一次<br>空间复杂度: <code>O(n)</code> 记录<code>states</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这是一道经典的<a href="/tags/Depth-first-Search/">DFS</a>题目, 需要注意的是, 每个node有三个状态, 并且我们经过node时将其设为<code>unsafe</code>状态, 这样遍历过程中再次遇到该点, 我们就可以直接确定为<code>unsafe</code>了.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Depth-first Search</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 803] Bricks Falling When Hit</title>
    <url>/Leetcode-803-Bricks-Falling-When-Hit/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>We have a grid of 1s and 0s; the 1s in a cell represent bricks.  A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.</p>
<p>We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure.</p>
<p>Return an array representing the number of bricks that will drop after each erasure in sequence.</p>
<blockquote><p><strong>Example 1</strong>:<br><strong>Input</strong>:<br>grid = <code>[[1,0,0,0],[1,1,1,0]]</code><br>hits = <code>[[1,0]]</code><br><strong>Output</strong>: <code>[2]</code><br><strong>Explanation</strong>:<br>If we erase the brick at (1, 0), the brick at (1, 1) and (1, 2) will drop. So we should return 2.</p>
</blockquote>
<blockquote><p><strong>Example 2</strong>:<br><strong>Input</strong>:<br>grid = <code>[[1,0,0,0],[1,1,0,0]]</code><br>hits = <code>[[1,1],[1,0]]</code><br><strong>Output</strong>: <code>[0,0]</code><br><strong>Explanation</strong>:<br>When we erase the brick at (1, 0), the brick at (1, 1) has already disappeared due to the last move. So each erasure will cause no bricks dropping.  Note that the erased brick (1, 0) will not be counted as a dropped brick.</p>
</blockquote>
<p><strong>Note</strong>:</p>
<ul>
<li>The number of rows and columns in the grid will be in the range <code>[1, 200]</code>.</li>
<li>The number of erasures will not exceed the area of the grid.</li>
<li>It is guaranteed that each erasure will be different from any other erasure, and located inside the grid.</li>
<li>An erasure may refer to a location with no brick - if it does, no bricks drop.</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题tag里有<code>union find</code>的方法, 解题思路可以参考官方解答.</p>
<p>实际上, 用<code>DFS</code>一样可以给出清晰的解答. 在面试过程中, 除非利用<code>union find</code>可以明显简化问题, 否则不是很推荐使用. 曾经有人使用<code>union find</code>解答<code>number of islands I</code>, 就被面试官追问, <code>union find</code>如何删除一个节点, 如果不熟悉的话就会很被动.</p>
<p>这里我们提供两种<code>DFS</code>的思路。</p>
<p>方法1(c++): 每次落下一个砖块, 要从砖块的上下左右四个方向分别做<code>DFS</code>, 第一遍判断<code>DFS</code>经过的砖块是否与顶部砖块连通, 如果不连通, 则该砖块会落下, 并且所有与之相连的砖块都不与顶部砖块连通, 因此做第二遍<code>DFS</code>, 标记访问过的砖块为落下. 注意每一次<code>DFS</code>都是一次新的遍历, 因此我们使用<code>_id</code>的来标记第<code>_id</code>次<code>DFS</code>, 并且在新的一次遍历前更新<code>id</code>.</p>
<p>方法2(python): 将所有击落的砖块，先行去除(在<code>Grid</code>矩阵中-1)，接着用<code>DFS</code>找出所有与顶部砖块连通的砖块，并用一个矩阵<code>connected</code>记录(既表示已经访问过，又表示与顶部连通)。然后，从最后一块被击落的砖块向前逐一恢复。每次恢复被击落砖块时，在<code>Grid</code>中+1，并且判断该位置是否原来有砖块存在，是否处于顶部或者四周有没有与顶部连通的砖块存在。若满足这些条件，说明该被击落的砖块可以恢复，并且以它为起点做<code>DFS</code>，所有与他连通的砖块都可以被恢复，恢复的数量即为该次击落后，落下砖块的数量。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; _g; <span class="comment">// 用一个私有变量 _g 可以减少 fall 函数的参数数量</span></span><br><span class="line">    <span class="keyword">int</span> _m, _n;</span><br><span class="line">    <span class="keyword">int</span> _id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dx = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dy = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">fall</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">bool</span> isClear, <span class="keyword">int</span>&amp; cnt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= _m || y &lt; <span class="number">0</span> || y &gt;= _n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_g[x][y] == _id || _g[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _g[x][y] = isClear ? <span class="number">0</span> : _id;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> xx = x + dx[i], yy = y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (!fall(xx, yy, isClear, cnt)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">hitBricks</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; hits)</span> </span>&#123;</span><br><span class="line">        _m = grid.size();</span><br><span class="line">        _n = grid[<span class="number">0</span>].size();</span><br><span class="line">        _g.swap(grid);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rets;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; hit : hits) &#123;</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> x = hit[<span class="number">0</span>], y = hit[<span class="number">1</span>];</span><br><span class="line">            _g[x][y] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">                ++_id;</span><br><span class="line">                <span class="keyword">int</span> xx = x + dx[i];</span><br><span class="line">                <span class="keyword">int</span> yy = y + dy[i];</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (!fall(xx, yy, <span class="literal">false</span>, cnt)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ++_id;</span><br><span class="line">                ret += cnt;</span><br><span class="line">                fall(xx, yy, <span class="literal">true</span>, cnt);</span><br><span class="line">            &#125;</span><br><span class="line">            rets.push_back(ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rets;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_valid</span><span class="params">(self, r, c, grid)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> r &gt;= len(grid) <span class="keyword">or</span> c &lt; <span class="number">0</span>  <span class="keyword">or</span> c &gt;= len(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[r][c] &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs_connect</span><span class="params">(self, grid, connected, r, c)</span>:</span></span><br><span class="line">        num_connected = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> rr, cc <span class="keyword">in</span> [(r - <span class="number">1</span>, c), (r + <span class="number">1</span>, c), (r, c - <span class="number">1</span>), (r, c + <span class="number">1</span>)]:</span><br><span class="line">            <span class="keyword">if</span> self.check_valid(rr, cc, grid) <span class="keyword">and</span> <span class="keyword">not</span> connected[rr][cc]:</span><br><span class="line">                connected[rr][cc] = <span class="number">1</span></span><br><span class="line">                num_connected += self.dfs_connect(grid, connected, rr, cc)</span><br><span class="line">        <span class="keyword">return</span> num_connected</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_connection</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        connected = [[<span class="number">0</span> <span class="keyword">for</span> c <span class="keyword">in</span> range(len(grid[<span class="number">0</span>]))] <span class="keyword">for</span> r <span class="keyword">in</span> range(len(grid))]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> self.check_valid(<span class="number">0</span>, c, grid):</span><br><span class="line">                connected[<span class="number">0</span>][c] = <span class="number">1</span></span><br><span class="line">                self.dfs_connect(grid, connected, <span class="number">0</span>, c)</span><br><span class="line">        <span class="keyword">return</span> connected</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_new_block_connection</span><span class="params">(self, r, c, grid, connected)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> grid[r][c] &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> r == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> rr, cc <span class="keyword">in</span> [(r - <span class="number">1</span>, c), (r + <span class="number">1</span>, c), (r, c - <span class="number">1</span>), (r, c + <span class="number">1</span>)]:</span><br><span class="line">            <span class="keyword">if</span> self.check_valid(rr, cc, grid) <span class="keyword">and</span> connected[rr][cc] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hitBricks</span><span class="params">(self, grid, hits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :type hits: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(hits))]</span><br><span class="line">        <span class="keyword">for</span> hit <span class="keyword">in</span> hits:</span><br><span class="line">            grid[hit[<span class="number">0</span>]][hit[<span class="number">1</span>]] -= <span class="number">1</span></span><br><span class="line">        connected = self.build_connection(grid)</span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(hits)):</span><br><span class="line">            r, c = hits[<span class="number">-1</span> - idx]</span><br><span class="line">            grid[r][c] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.check_new_block_connection(r, c, grid, connected):</span><br><span class="line">                connected[r][c] = <span class="number">1</span></span><br><span class="line">                add_num = self.dfs_connect(grid, connected, r, c) - <span class="number">1</span></span><br><span class="line">                ret[<span class="number">-1</span> - idx] = add_num</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>方法1：<br>时间复杂度: <code>O(N * Q)</code> 其中<code>N</code>是砖块数量, <code>Q</code>是<code>hits</code>的长度<br>空间复杂度: <code>O(1)</code></p>
<p>方法2：<br>时间复杂度: <code>O(N + Q)</code> 其中<code>N</code>是砖块数量, <code>Q</code>是<code>hits</code>的长度<br>空间复杂度: <code>O(N)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这是一道比较复杂的深度遍历问题, 如果同学一下子不会做也没有关系, 面试的时候不要紧张, 要和面试官讨论并且慢慢理清思路.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 805] Split Array With Same Average</title>
    <url>/Leetcode-805-Split-Array-With-Same-Average/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>In a given integer array A, we must move every element of A to either list B or list C. (B and C initially start empty.)</p>
<p>Return true if and only if after such a move, it is possible that the average value of B is equal to the average value of C, and B and C are both non-empty.</p>
<pre><code>Example :
Input: 
[1,2,3,4,5,6,7,8]
Output: true    
Explanation: We can split the array into [1,4,5,8] and [2,3,6,7], and both of them have the average of 4.5.
</code></pre><p><strong>Note</strong>:</p>
<ul>
<li>The length of A will be in the range [1, 30].</li>
<li>A[i] will be in the range of [0, 10000].<a id="more"></a>
</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>给定一个数组，题目要求判断能否把数组分成两个数组，是它们的平均值相同。</p>
<p>我们说明以下三点事实：</p>
<ul>
<li>如果存在这样的分组，它们各自的平均值一定等于原数组的平均值，反之则不存在</li>
<li>我们只要找到任意一个分组，使得它的平均值等于原数组的平均值，就可以判定剩余数组成的数组的平均值也与其相等，从在给出存在的判断</li>
<li>如果存在这样的分组，平均值（原数组以及分类后的两个数组的平均值都相等）乘以任意数组的长度，都一定是一个整数。这点会简化我们的计算。</li>
</ul>
<p>因此，我们可以用上述三点事实，来给出我们的算法。因为是分成两个数组，所以必定有一个数组的长度不超过原数组长度的一般。枚举从1到原数组长度的一半<code>k</code>，对其中乘以平均值为整数的那些值<code>sum</code>，我们用递归的方法找出是否能从原数组中挑选出给<code>k</code>个元素，使得它们的和等于<code>sum</code>。如果能找出其中任意一个，存在这种分类，反之则不存在。</p>
<p>为了防止<code>TLE</code>,我们用一个字典<code>visit</code>来记录遍历的情况。<code>visit</code>的<code>key</code>是一个元组（target，k），表示需要寻找的目标和元素个数，<code>visit</code>的<code>value</code>是<code>i</code>,表示从第<code>i</code>个元组之后找。这样如果新的<code>i</code>比<code>visit</code>中对应<code>key</code>的<code>value</code>来的大，说明这种情况已经遍历过，则无需重复遍历。否则需要更新<code>visit</code>，并继续搜索。</p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitArraySameAverage</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        visit = &#123;&#125; <span class="comment"># 记录搜索过得信息</span></span><br><span class="line">        n, s = len(A), sum(A)</span><br><span class="line">        <span class="keyword">return</span> any(self.find(A, s * k / n, k, <span class="number">0</span>, visit) <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>, int(n / <span class="number">2</span>) + <span class="number">1</span>) <span class="keyword">if</span> s * k % n == <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, A, target, k, i, visit)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (target, k) <span class="keyword">in</span> visit <span class="keyword">and</span> visit[(target, k)] &lt;= i:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> target == <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> k + i &gt; len(A):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        ans = self.find(A, target - A[i], k - <span class="number">1</span>, i + <span class="number">1</span>, visit) <span class="keyword">or</span> self.find(A, target, k, i + <span class="number">1</span>, visit)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ans:</span><br><span class="line">            visit[(target, k)] = min(visit.get((target,k), len(A)), i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>我们用了一个<code>visit</code>来记录一些中间过程，它的空间复杂度是<code>O(ele_max*n^3)</code>,其中<code>ele_max</code>是A[i]的最大值，这里是10000。<br>对于时间复杂度，也是同样的情况，<br>时间复杂度: <code>O(ele_max*n^3)</code><br>空间复杂度: <code>O(ele_max*n^3)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这题如果使用暴力搜索，一定会超时。利用两个数组平均值相等的性质，可以做的剪枝<code>dfs</code>。同时我们用一个<code>map</code>来记录已经搜索的信息，进一步避免了不必要的计算。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 808] Soup Servings</title>
    <url>/Leetcode-808-Soup-Servings/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>There are two types of soup: type A and type B. Initially we have N ml of each type of soup. There are four kinds of operations:</p>
<ol>
<li>Serve 100 ml of soup A and 0 ml of soup B</li>
<li>Serve 75 ml of soup A and 25 ml of soup B</li>
<li>Serve 50 ml of soup A and 50 ml of soup B</li>
<li>Serve 25 ml of soup A and 75 ml of soup B</li>
</ol>
<p>When we serve some soup, we give it to someone and we no longer have it.  Each turn, we will choose from the four operations with equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as we can.  We stop once we no longer have some quantity of both types of soup.</p>
<p>Note that we do not have the operation where all 100 ml’s of soup B are used first.  </p>
<p>Return the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time.</p>
<blockquote><p><strong>Example:</strong><br><strong>Input:</strong> N = 50<br><strong>Output:</strong> 0.625<br><strong>Explanation:</strong><br>If we choose the first two operations, A will become empty first. For the third operation, A and B will become empty at the same time. For the fourth operation, B will become empty first. So the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.</p>
</blockquote>
<p><strong>Notes:</strong></p>
<ul>
<li>0 &lt;= N &lt;= 10^9. </li>
<li>Answers within 10^-6 of the true value will be accepted as correct.<a id="more"></a>
</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>虽然题目乍一看比较复杂，好像让你去算概率，难道是概率题，不是编程题？<br>但稍加分析，可以总结如下信息：<br>初始状态下，<code>A</code>和<code>B</code>同时拥有<code>N</code>的汤。<br>终结状态下，</p>
<ul>
<li>若<code>A</code>先被倒完，则<code>A</code>剩余的汤为<code>0</code>或<code>负数</code>。（因为在剩余汤不足时，可以倒比所需少的量）此时<code>B</code>剩余的汤应当大于<code>0</code>。</li>
<li>若<code>A</code>和<code>B</code>同时倒完，则<code>A</code>和<code>B</code>的汤均为<code>0</code>或<code>负数</code>。</li>
<li>若<code>B</code>先被倒完，则<code>B</code>剩余的汤为<code>0</code>或<code>负数</code>。此时<code>A</code>剩余的汤应当大于<code>0</code>。</li>
</ul>
<p>有了初始状态和终结状态，可以想到用递归的方法来求解。在结算时，因为同时倒完的概率只需计算一半。因此，判断其为A先倒完时，返回<code>1</code>，而同时倒完时返回<code>0.5</code>。<br>又考虑到所有操作中汤的份量都是<code>25</code>的倍数，实际中间状态的可能最多为<code>Ceil(N/25)^2</code>。因此可以用动态规划来避免冗余计算。</p>
<p>以上基本实现了本题的主体解法。然而这是一个两次方复杂度的解法，随着<code>N</code>的上升，需要指数的时间去计算。此时我们可以利用题目中提到的精度要求来做文章。让我们从概率的角度重新审题。四个操作对汤消耗的期望值为<code>A = 62.5, B = 37.5</code>。<code>A</code>的消耗速度远高于<code>B</code>。因此，当<code>N</code>变大时，<code>A</code>先倒完的概率趋向于1。我们尝试不断递增的<code>N</code>来运行程序后，可以发现当N&gt;4800时，所得概率已经落在<code>1 - 10^-6</code>内。也就是说所有大于4800的输入，都可以直接输出1作为结果。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">recurse</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= <span class="number">0</span> &amp;&amp; b &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memo.count(a) &amp;&amp; memo[a].count(b)) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[a][b];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> prob = (recurse(a - <span class="number">100</span>, b, memo) + recurse(a - <span class="number">75</span>, b - <span class="number">25</span>, memo) + recurse(a - <span class="number">50</span>, b - <span class="number">50</span>, memo) + recurse(a - <span class="number">25</span>, b - <span class="number">75</span>, memo)) / <span class="number">4.0</span>;</span><br><span class="line">        memo[a][b] = prob;</span><br><span class="line">        <span class="keyword">return</span> prob;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">soupServings</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &gt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;&gt; memo;</span><br><span class="line">        <span class="keyword">return</span> recurse(N, N, memo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">soupHelper</span><span class="params">(self, A, B, state)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (A, B) <span class="keyword">in</span> state:</span><br><span class="line">            <span class="keyword">return</span> state[A, B]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> A &lt;=<span class="number">0</span> <span class="keyword">or</span> B &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> A &lt;= <span class="number">0</span> <span class="keyword">and</span> B &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0.5</span></span><br><span class="line">            <span class="keyword">if</span> B &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        prob = <span class="number">0</span></span><br><span class="line">        prob += self.soupHelper(A - <span class="number">100</span>, B, state)</span><br><span class="line">        prob += self.soupHelper(A - <span class="number">75</span>, B - <span class="number">25</span>, state)</span><br><span class="line">        prob += self.soupHelper(A - <span class="number">50</span>, B - <span class="number">50</span>, state)</span><br><span class="line">        prob += self.soupHelper(A - <span class="number">25</span>, B - <span class="number">75</span>, state)</span><br><span class="line">        state[A, B] = <span class="number">0.25</span> * prob</span><br><span class="line">        <span class="keyword">return</span> state[A, B]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">soupServings</span><span class="params">(self, N)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type N: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> N &gt; <span class="number">4800</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.</span></span><br><span class="line">        state = dict()</span><br><span class="line">        prob = self.soupHelper(N, N, state)</span><br><span class="line">        <span class="keyword">return</span> prob</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>当N&lt;=4800时：</p>
<ul>
<li>时间复杂度: <code>O(n^2)</code></li>
<li>空间复杂度: <code>O(n^2)</code></li>
</ul>
<p>当N&gt;4800时：</p>
<ul>
<li>时间复杂度: <code>O(1)</code></li>
<li>空间复杂度: <code>O(1)</code></li>
</ul>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>本题主要有两个难点:</p>
<ul>
<li>想到用递归结合动态规划的办法来求解概率。</li>
<li>利用精度和定性的概率判断，避免计算时间会指数量级的膨胀</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 809] Expressive Words</title>
    <url>/Leetcode-809-Expressive-Words/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Sometimes people repeat letters to represent extra feeling, such as <code>&quot;hello&quot; -&gt; &quot;heeellooo&quot;</code>, <code>&quot;hi&quot; -&gt; &quot;hiiii&quot;</code>.  Here, we have groups, of adjacent letters that are all the same character, and adjacent characters to the group are different.  A group is extended if that group is length 3 or more, so “e” and “o” would be extended in the first example, and “i” would be extended in the second example.  As another example, the groups of “abbcccaaaa” would be “a”, “bb”, “ccc”, and “aaaa”; and “ccc” and “aaaa” are the extended groups of that string.</p>
<p>For some given string S, a query word is stretchy if it can be made to be equal to S by extending some groups.  Formally, we are allowed to repeatedly choose a group (as defined above) of characters c, and add some number of the same character c to it so that the length of the group is 3 or more.  Note that we cannot extend a group of size one like “h” to a group of size two like “hh” - all extensions must leave the group extended - ie., at least 3 characters long.</p>
<p>Given a list of query words, return the number of words that are stretchy. </p>
<blockquote><p><strong>Example</strong>:<br><strong>Input</strong>:<br>S = “heeellooo”<br>words = [“hello”, “hi”, “helo”]<br><strong>Output</strong>: 1<br><strong>Explanation</strong>:<br>We can extend “e” and “o” in the word “hello” to get “heeellooo”.<br>We can’t extend “helo” to get “heeellooo” because the group “ll” is not extended.</p>
</blockquote>
<p>Notes:</p>
<ul>
<li><code>0 &lt;= len(S) &lt;= 100</code>.</li>
<li><code>0 &lt;= len(words) &lt;= 100</code>.</li>
<li><code>0 &lt;= len(words[i]) &lt;= 100</code>.</li>
<li><code>S</code> and all <code>words</code> in words consist only of lowercase letters<a id="more"></a>
</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题主要需要建立<code>isMatch()</code>方法判断<code>original word</code> (<code>o</code>)是否能够表述成<code>stretchy word</code> (<code>s</code>)<br>指针<code>i</code>和<code>j</code>分别指向<code>s</code>和<code>o</code>,需要判断如下条件:</p>
<ul>
<li>如果当前的<code>s[i] != o[j]</code>, 直接返回<code>false</code></li>
<li>统计当前连续相同的字符分别用<code>cntO</code>和<code>cntS</code>表示</li>
<li>如果<code>cntO == cntS</code>,说明是严格匹配,当然可以继续</li>
<li>如果<code>cntO &lt; cntS &amp;&amp; cntS &gt;= 3</code>, 说明<code>S</code>extend了当前的字符,也可以继续匹配</li>
</ul>
<p>需要注意的是,<code>&quot;baac&quot;</code>(original word)和<code>&quot;baaac&quot;</code>(strechy word)是可以匹配的, 但是<code>&quot;baaaac&quot;</code>(original word)和<code>&quot;baaac&quot;</code>(stretchy word)就不可以了, 也就是说原字符串中相同连续字符(例子中的字符<code>&#39;a&#39;</code>)长度一定要小于Stretchy word中对应的相同连续字符(<code>&#39;a&#39;</code>)长度才可能匹配, 这一点原题没有说的特别清楚, 面试的时候需要和面试官clarify清楚.</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// s means strechy word, o means original word</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">const</span> <span class="built_in">string</span>&amp; o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.size() &amp;&amp; j &lt; o.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i++] != o[j++]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// cntO means number of consecutive chars in O starting from i - 1</span></span><br><span class="line">            <span class="comment">// cntS means number of consecutive chars in S stargin from j - 1</span></span><br><span class="line">            <span class="keyword">int</span> cntO = <span class="number">1</span>, cntS = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.size() &amp;&amp; s[i] == s[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">                ++cntS;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; o.size() &amp;&amp; o[j] == o[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                ++j;</span><br><span class="line">                ++cntO;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cntS == cntO || (cntS &gt;= <span class="number">3</span> &amp;&amp; cntS &gt; cntO)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (i == s.size() &amp;&amp; j == o.size());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">expressiveWords</span><span class="params">(<span class="built_in">string</span> S, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isMatch(S, word)) &#123;</span><br><span class="line">                ++ret;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_char_len_next_nondup_idx</span><span class="params">(self, word, curr_idx)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get current character, continous length of this charactor</span></span><br><span class="line"><span class="string">        and next character index</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> idx <span class="keyword">in</span> range(curr_idx + <span class="number">1</span>, len(word)):</span><br><span class="line">            <span class="keyword">if</span> word[idx] != word[curr_idx]:</span><br><span class="line">                <span class="keyword">return</span> word[curr_idx], length, idx</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> word[curr_idx], length, len(word)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(self, S, word)</span>:</span></span><br><span class="line">        sid = <span class="number">0</span></span><br><span class="line">        wid = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(sid &lt; len(S) <span class="keyword">and</span> wid &lt; len(word)):</span><br><span class="line">            curr_s_char, curr_s_len, sid = self.get_char_len_next_nondup_idx(S, sid)</span><br><span class="line">            curr_w_char, curr_w_len, wid = self.get_char_len_next_nondup_idx(word, wid)</span><br><span class="line">            <span class="keyword">if</span> curr_s_char != curr_w_char:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> curr_s_len &lt; curr_w_len:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> curr_s_len == <span class="number">2</span> <span class="keyword">and</span> curr_w_len == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> sid == len(S) <span class="keyword">and</span> wid == len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">expressiveWords</span><span class="params">(self, S, words)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type S: str</span></span><br><span class="line"><span class="string">        :type words: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            ret += self.check(S, word)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(len * (m + n))</code> 其中<code>len</code>为<code>words.size()</code>, <code>m</code>为<code>S.size()</code>, <code>n</code>为<code>word</code>中字符串的平均长度<br>空间复杂度: <code>O(1)</code> </p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这是一道经典的字符串题目,题目本身并不算很难,重要的是要理解清楚题意.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 812] Largest Triangle Area</title>
    <url>/Leetcode-812-Largest-Triangle-Area/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.</p>
<img src="/Leetcode-812-Largest-Triangle-Area/sample.png" width="350">
<blockquote><p><strong>Example</strong>:<br><strong>Input</strong>: points = <code>[[0,0],[0,1],[1,0],[0,2],[2,0]]</code><br><strong>Output</strong>: 2<br><strong>Explanation</strong>:<br>The five points are show in the figure below. The red triangle is the largest.</p>
</blockquote>
<p><strong>Notes</strong>:</p>
<ul>
<li><code>3 &lt;= points.length &lt;= 50</code>.</li>
<li>No points will be duplicated.</li>
<li><code>-50 &lt;= points[i][j] &lt;= 50</code>.</li>
<li>Answers within 10^-6 of the true value will be accepted as correct.<a id="more"></a>
</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题主要考察解析几何中三角形面积的计算(如<a href="http://www.maths.usyd.edu.au/u/MOW/vectors/vectors-11/v-11-7.html" target="_blank" rel="noopener">叉乘计算面积</a>, <a href="https://people.richland.edu/james/lecture/m116/matrices/applications.html" target="_blank" rel="noopener">行列式计算面积
</a>), 也比较适合Google电话面试或者Intern面试的难度, 可能会用来考察简历有相关背景的面试者.<br>做法上比较暴力, 直接三重循环找到所有可能组成三角形的点计算最大面积即可, 还是要求快速形成思路, 代码清晰, 建议把叉乘部分单独写成一个Function, 这样做即使面试时叉乘公式不记得了, 但是整体思路清晰, 也可能会过面试. </p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">multiply</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.5</span> * <span class="built_in">abs</span>(v1[<span class="number">0</span>] * v2[<span class="number">1</span>] - v2[<span class="number">0</span>] * v1[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">largestTriangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = points.size();</span><br><span class="line">        <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; n; ++k) &#123;</span><br><span class="line">                    ret = max(ret, multiply(&#123;points[k][<span class="number">0</span>] - points[i][<span class="number">0</span>], points[k][<span class="number">1</span>] - points[i][<span class="number">1</span>]&#125;, &#123;points[k][<span class="number">0</span>] - points[j][<span class="number">0</span>], points[k][<span class="number">1</span>] - points[j][<span class="number">1</span>]&#125;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calArea</span><span class="params">(self, p1, p2, p3)</span>:</span></span><br><span class="line">        <span class="comment">#Use Determinant to get triangle area</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">.5</span> * abs(p1[<span class="number">0</span>] * p2[<span class="number">1</span>] + p2[<span class="number">0</span>] * p3[<span class="number">1</span>] + p3[<span class="number">0</span>] * p1[<span class="number">1</span>] - p1[<span class="number">0</span>] * p3[<span class="number">1</span>] - p2[<span class="number">0</span>] * p1[<span class="number">1</span>] - p3[<span class="number">0</span>] * p2[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">largestTriangleArea</span><span class="params">(self, points)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type points: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        maxS = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(points) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(points) - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(j + <span class="number">1</span>, len(points)):</span><br><span class="line">                    S = self.calArea(points[i], points[j], points[k])</span><br><span class="line">                    <span class="keyword">if</span> S &gt; maxS:</span><br><span class="line">                        maxS = S</span><br><span class="line">        <span class="keyword">return</span> maxS</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N^3)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>谷歌有时候会考察矩阵叉乘, 点乘相关的知识点, 面试的时候即使不记得也可以问面试官要提示, 当然如果自己能够记得肯定是加分的. 之后会整理相关的考题.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Google</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 819] Most Common Word</title>
    <url>/Leetcode-819-Most-Common-Word/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words.  It is guaranteed there is at least one word that isn’t banned, and that the answer is unique.</p>
<p>Words in the list of banned words are given in lowercase, and free of punctuation.  Words in the paragraph are not case sensitive.  The answer is in lowercase.</p>
<blockquote><p><strong>Example</strong>:<br><strong>Input</strong>:<br>paragraph = “Bob hit a ball, the hit BALL flew far after it was hit.”<br>banned = [“hit”]<br><strong>Output</strong>: “ball”<br><strong>Explanation</strong>:<br>“hit” occurs 3 times, but it is a banned word.<br>“ball” occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph.<br>Note that words in the paragraph are not case sensitive,<br>that punctuation is ignored (even if adjacent to words, such as “ball,”),<br>and that “hit” isn’t the answer even though it occurs more because it is banned.</p>
</blockquote>
<p>Note:</p>
<ul>
<li><code>1 &lt;= paragraph.length &lt;= 1000</code>.</li>
<li><code>1 &lt;= banned.length &lt;= 100</code>.</li>
<li><code>1 &lt;= banned[i].length &lt;= 10</code>.</li>
<li>The answer is unique, and written in lowercase (even if its occurrences in paragraph may have uppercase symbols, and even if it is a proper noun.)</li>
<li><code>paragraph</code> only consists of letters, spaces, or the punctuation symbols !?’,;.</li>
<li>Different words in <code>paragraph</code> are always separated by a space.</li>
<li>There are no hyphens or hyphenated words.</li>
<li>Words only consist of letters, never apostrophes or other punctuation symbols.<a id="more"></a>
</li>
</ul>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题可以通过<code>hash table</code>来建立每个单词与其出现频率的对应关系, 在遍历<code>paragraph</code>的时候统计单词出现的频率, 并更新当前的最高频单词.<br>由于题目相对简单, 面试的时候需要在较短的时间内想到建立怎样的对应关系, 存储结构应该如何设计 (比如用<code>map</code>还是<code>unordered_map</code>, <code>key</code>和<code>value</code>分别是什么, 两者能不能倒过来等等)<br>另外对于使用<code>cpp</code>的同学来说, 熟练掌握<code>istringstream</code>和<code>getline</code>这些基础的I/O interface还是比较加分的.</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">mostCommonWord</span><span class="params">(<span class="built_in">string</span> paragraph, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; banned)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(paragraph)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; <span class="title">banSet</span><span class="params">(banned.begin(), banned.end())</span></span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; mapping;</span><br><span class="line">        <span class="built_in">string</span> cur, ret;</span><br><span class="line">        <span class="keyword">int</span> curMax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (getline(iss, cur, <span class="string">' '</span>)) &#123;</span><br><span class="line">            <span class="built_in">string</span> formatStr;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">char</span> ch = <span class="built_in">tolower</span>(cur[i]);</span><br><span class="line">                <span class="keyword">if</span> (ch &gt;= <span class="string">'a'</span> &amp;&amp; ch &lt;= <span class="string">'z'</span>) &#123;</span><br><span class="line">                    formatStr += ch;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mapping[formatStr]++;</span><br><span class="line">            <span class="keyword">if</span> (mapping[formatStr] &gt; curMax &amp;&amp; !banSet.count(formatStr)) &#123;</span><br><span class="line">                curMax = mapping[formatStr];</span><br><span class="line">                ret = formatStr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mostCommonWord</span><span class="params">(self, paragraph, banned)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type paragraph: str</span></span><br><span class="line"><span class="string">        :type banned: List[str]</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        words_dict = collections.Counter()</span><br><span class="line">        top_word = <span class="literal">None</span></span><br><span class="line">        top_freq = <span class="number">0</span></span><br><span class="line">        words = re.split(<span class="string">"[ !?',;.]+"</span>, paragraph)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> word.lower() <span class="keyword">not</span> <span class="keyword">in</span> banned:</span><br><span class="line">                words_dict[word.lower()] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> words_dict[word.lower()] &gt; top_freq:</span><br><span class="line">                    top_word = word.lower()</span><br><span class="line">                    top_freq = words_dict[word.lower()]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> top_word</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code> (n为<code>paragraph</code>包含的单词数)<br>空间复杂度: <code>O(m + n)</code> (m为<code>banned</code>长度)</p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>像这样一道比较基础的算法设计题, 如果真正面试的时候遇到, 尽量不要一上来就写答案, 可以在白板上列举一下可能的数据结构及做法, 说明为什么最后选择这样做(比如只有这样才行得通或者效率更高). 通过这样的分析可以让面试官看到真实清晰的思路.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 832] Flipping an Image</title>
    <url>/Leetcode-832-Flipping-an-Image/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.</p>
<p>To flip an image horizontally means that each row of the image is reversed.  For example, flipping <code>[1, 1, 0]</code> horizontally results in <code>[0, 1, 1]</code>.</p>
<p>To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting <code>[0, 1, 1]</code> results in <code>[1, 0, 0]</code>.</p>
<p>Example 1:<br><blockquote><p>Input: <code>[[1,1,0],[1,0,1],[0,0,0]]</code><br>Output: <code>[[1,0,0],[0,1,0],[1,1,1]]</code><br>Explanation: First reverse each row: <code>[[0,1,1],[1,0,1],[0,0,0]]</code>.<br>Then, invert the image: <code>[[1,0,0],[0,1,0],[1,1,1]]</code></p>
</blockquote><br>Example 2:<br><blockquote><p>Input: <code>[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</code><br>Output: <code>[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</code><br>Explanation: First reverse each row: <code>[[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]</code>.<br>Then invert the image: <code>[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</code></p>
</blockquote><br>Notes:</p>
<ul>
<li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li>
<li><code>0 &lt;= A[i][j] &lt;= 1</code></li>
</ul>
<a id="more"></a>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题并不难, 属于谷歌面试中的热身题或者是Intern电话面试的难度. 关键是要在短时间内形成清晰的思路, 并且形成代码, 为之后的题或者followup争取到足够的时间.<br>这里介绍的思路是逐行进行<code>swap</code>, 然后每个元素异或, 虽然这样每个元素会扫面两遍, 但是思路足够清晰.</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">flipAndInvertImage</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : A) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row.size() / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                swap(row[i], row[row.size() - <span class="number">1</span> - i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ele : row) &#123;</span><br><span class="line">                ele ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flipAndInvertImage</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(A)):</span><br><span class="line">            A[i] = A[i][::<span class="number">-1</span>]</span><br><span class="line">            A[i] = [ele^<span class="number">1</span> <span class="keyword">for</span> ele <span class="keyword">in</span> A[i]]</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n^2)</code> (n为A的边长)<br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>需要训练在白板上10分钟之内搞定.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 9] Palindrome Number</title>
    <url>/Leetcode-9-Palindrome-Number/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> 121<br><strong>Output:</strong> true</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> -121<br><strong>Output:</strong> false<br><strong>Explanation:</strong> From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</p>
</blockquote></p>
<p><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> 10<br><strong>Output:</strong> false<br><strong>Explanation:</strong> Reads 01 from right to left. Therefore it is not a palindrome.</p>
</blockquote></p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>最简单的思路是先转换成字符串, 然后用两个指针来判断. 但是这样需要<code>O(n)</code>的空间复杂度. 为了用<code>O(1)</code>的空间复杂度, 我们可以直接把输入转换成反转后的数字. 如果一个数字反转后, 大小不变, 则是回文数. 解法也比较直观, 按位取余后逐渐生成反转后的数字. 要注意判断是否溢出. </p>
<h4 id="示例代码-python"><a href="#示例代码-python" class="headerlink" title="示例代码 (python)"></a>示例代码 (python)</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        rev = <span class="number">0</span></span><br><span class="line">        x_ = x</span><br><span class="line">        <span class="keyword">while</span> x_ &gt; <span class="number">0</span>:</span><br><span class="line">            tmp = rev * <span class="number">10</span> + x_ % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> (tmp - x_ % <span class="number">10</span> ) / <span class="number">10</span> != rev:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            rev = tmp</span><br><span class="line">            x_ /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> x == rev</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>在解题时需要判断是否会溢出.</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 94] Binary Tree Inorder Traversal</title>
    <url>/Leetcode-94-Binary-Tree-Inorder-Traversal/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary tree, return the <em>inorder</em> traversal of its nodes’ values.</p>
<p>For example:</p>
<p>Given binary tree [1,null,2,3],</p>
<pre><code>1   
 \
  2
 /
3
</code></pre><p>return [1,3,2].</p>
<p><strong>Note</strong>: Recursive solution is trivial, could you do it iteratively?</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>深度遍历二叉树（<code>DFS</code>），可以分为</p>
<ul>
<li>前序遍历（<code>preorder</code>）</li>
<li>中序遍历（<code>inorder</code>）</li>
<li>后序遍历（<code>postorder</code>）</li>
</ul>
<p>这题要求使用中序遍历。中序遍历按照左子节点（<code>left</code>），根节点（<code>root</code>），右子节点（<code>right</code>）的顺序深度遍历二叉树。</p>
<p>同样，我们可以使用递归与非递归两种方法来实现前序遍历。递归的方法比较简单，参看相关代码就能明白。非递归的方法可以通过栈（<code>stack</code>）实现：</p>
<p>使用栈（<code>stack</code>），每次visit当前节点<code>node</code>，同时如果当前节点的右子节点非空，将此右子节点存入栈中，再将当前节点<code>node</code>更新为当前节点的左子节点。直到遍历完整棵二叉树。具体步骤为：</p>
<ol>
<li><p>建立一个空栈<code>stack</code></p>
</li>
<li><p>如果当前节点<code>node</code>非空或者栈<code>stack</code>非空：</p>
<ul>
<li>2.1 如果当前节点<code>node</code>非空：    <ul>
<li>将当前节点<code>node</code>压入栈</li>
<li>更新当前节点<code>node</code>为它的左子节点，回到步骤2.1    </li>
</ul>
</li>
<li>2.2 如果栈非空，:    <ul>
<li>将当前节点更新为栈顶元素，并且退栈</li>
<li>访问当前节点</li>
<li>更新当前节点<code>node</code>为它的右子节点，回到步骤2</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="示例代码-（递归-python版）"><a href="#示例代码-（递归-python版）" class="headerlink" title="示例代码 （递归 python版）"></a>示例代码 （递归 python版）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderhelper</span><span class="params">(self, root, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">	        <span class="keyword">return</span></span><br><span class="line">        self.inorderhelper(root.left, ans)  </span><br><span class="line">        ans.append(root.val)</span><br><span class="line">        self.inorderhelper(root.right, ans)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span> </span><br><span class="line">        res = []</span><br><span class="line">        self.inorderhelper(root, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-（递归-cpp版）"><a href="#示例代码-（递归-cpp版）" class="headerlink" title="示例代码 （递归 cpp版）"></a>示例代码 （递归 cpp版）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorderHelper</span><span class="params">(TreeNode* curr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!curr) &#123;</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">        inorderHelper(curr-&gt;left, ret);</span><br><span class="line">        ret.push_back(curr-&gt;val);</span><br><span class="line">        inorderHelper(curr-&gt;right, ret);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        inorderHelper(root, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-（非递归-python版）"><a href="#示例代码-（非递归-python版）" class="headerlink" title="示例代码 （非递归 python版）"></a>示例代码 （非递归 python版）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        cur, ans = root, []</span><br><span class="line">        <span class="keyword">while</span>(cur <span class="keyword">or</span> stack):</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                ans.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-（非递归-cpp版）"><a href="#示例代码-（非递归-cpp版）" class="headerlink" title="示例代码 （非递归 cpp版）"></a>示例代码 （非递归 cpp版）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">        <span class="keyword">while</span>(curr || !nodeStack.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(curr) &#123;</span><br><span class="line">                nodeStack.push(curr);</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = nodeStack.top();</span><br><span class="line">            nodeStack.pop();</span><br><span class="line">            ret.push_back(curr-&gt;val);</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>对递归方法，每个节点都被访问一次，考虑到本题并非平衡二叉树，最差将退化成链表，递归栈最大深度为<code>O(n)</code>。所以复杂度分析为：</p>
<ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>空间复杂度：<code>O(1)</code>, &#160; 递归栈深度<code>O(n)</code></li>
</ul>
<p>对非递归方法，同样每个节点都被访问一次，考虑到本题并非平衡二叉树，最差将退化成链表，栈最大深度为<code>O(n)</code>。所以复杂度分析为：</p>
<ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>空间复杂度：<code>O(n)</code></li>
</ul>
<h4 id="总结归纳："><a href="#总结归纳：" class="headerlink" title="总结归纳："></a>总结归纳：</h4><p>今天我们讲了二叉树的中序遍历，结合之前我们介绍的前序遍历，希望能对感兴趣的朋友有所帮助。</p>
<p>这里再介绍一个小知识点，当二叉树(<code>Binary Tree</code>)为二叉搜索树（<code>Binary Search Tree</code>）时，中序遍历会按照节点值从小到大排列。因此这也提供给我们一个判断二叉树(<code>Binary Tree</code>)是否是二叉搜索树（<code>Binary Search Tree</code>）的方法。</p>
<p>相关的练习还有：</p>
<p><a href="/Leetcode-144-Binary-Tree-Preorder-Traversal">[LeetCode 144] Binary Tree Preorder Traversal 二叉树前序遍历</a></p>
<p><a href="/leetcode-145-Binary-Tree-Postorder-Traversal">[LeetCode 145] Binary Tree Postorder Traversal 二叉树后序遍历</a></p>
<p><a href="/Leetcode-102-Binary-Tree-Level-Order-Traversal">[LeetCode 102] Binary Tree Level Order Traversal 二叉树层序遍历</a></p>
<p>之后我们会继续讨论更多Tree相关的内容,并更新在 <a href="/tags/Tree">Tree Tag</a>，尽请期待，种香蕉树去了：）</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Microsoft</tag>
        <tag>Hash Table</tag>
        <tag>Stack</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 993] Cousins in Binary Tree</title>
    <url>/Leetcode-993-Cousins-in-Binary-Tree/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>In a binary tree, the root node is at depth 0, and children of each depth k node are at depth <code>k+1</code>.</p>
<p>Two nodes of a binary tree are cousins if they have the same depth, but have different parents.</p>
<p>We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree.</p>
<p>Return true if and only if the nodes corresponding to the values x and y are cousins.</p>
<p><strong>Example 1:</strong><br><img src="/Leetcode-993-Cousins-in-Binary-Tree/example1.png" width="250"><blockquote><p><strong>Input:</strong> <code>root = [1,2,3,4], x = 4, y = 3</code><br><strong>Output:</strong> <code>false</code></p>
</blockquote></p>
<p><strong>Example 2:</strong><br><img src="/Leetcode-993-Cousins-in-Binary-Tree/example2.png" width="250"><blockquote><p><strong>Input:</strong> <code>root = [1,2,3,null,4,null,5], x = 5, y = 4</code><br><strong>Output:</strong> <code>true</code></p>
</blockquote></p>
<p><strong>Example 3:</strong><br><img src="/Leetcode-993-Cousins-in-Binary-Tree/example3.png" width="250"><blockquote><p><strong>Input:</strong> <code>root = [1,2,3,null,4], x = 2, y = 3</code><br><strong>Output:</strong> <code>false</code></p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li>The number of nodes in the tree will be between 2 and 100.</li>
<li>Each node has a unique integer value from 1 to 100.<a id="more"></a>
</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>因为要判断两个节点是否同层，想到用BFS逐层扫描.<br>对于每一层的节点：<br>    1) 用<code>has_x</code>和<code>has_y</code>代表<code>x</code>和<code>y</code>是否出现在本层<br>    2) 判断该节点的子节点是否同时是<code>x</code>和<code>y</code>，如果是，说明x和y是兄弟节点，而非cousin节点，直接<code>return false</code><br>    3) 该层扫描结束后，如果has_x和has_y同时为true，说明x和y同时出现在该层，<code>return true</code><br>    4) 该层扫描结束后，如果has_x和has_y仅有一个为true，则x和y必然在不同层，<code>return false</code><br>整棵树扫描结束后，如果还是没有返回，说明之前并未遇到过x或y中任何一个，<code>return false</code></p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; qu;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        qu.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!qu.empty()) &#123;</span><br><span class="line">            <span class="comment">// has_x and has_y represents whether x and y exist in this level</span></span><br><span class="line">            <span class="keyword">bool</span> has_x = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">bool</span> has_y = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// level_size means number of nodes at this level, so we don't need two queue to swap </span></span><br><span class="line">            <span class="keyword">int</span> level_size = qu.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level_size; ++i) &#123;</span><br><span class="line">                TreeNode* cur = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;val == x) &#123;</span><br><span class="line">                    has_x = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;val == y) &#123;</span><br><span class="line">                    has_y = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Check if x and y are sibling</span></span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left &amp;&amp; cur-&gt;right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;left-&gt;val == x &amp;&amp; cur-&gt;right-&gt;val == y) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;right-&gt;val == x &amp;&amp; cur-&gt;left-&gt;val == y) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">                    qu.push(cur-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">                    qu.push(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (has_x &amp;&amp; has_y) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Good to add this condition since x and y are unique in the tree</span></span><br><span class="line">            <span class="keyword">if</span> (has_x || has_y) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(n)</code><br>空间复杂度: <code>O(log(n))</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这道题重点要理解题意，cousin节点之间必须在同一层，且父节点不同。官网的解答空间复杂度不高，且整个想法不够直观，不是很推荐。</p>
<p>我们在<strong>Youtube</strong>上更新了<a href="https://www.youtube.com/watch?v=LoBbUrWPH7k" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Bloomberg</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 995] Minimum Number of K Consecutive Bit Flips</title>
    <url>/Leetcode-995-Minimum-Number-of-K-Consecutive-Bit-Flips/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>In an array <code>A</code> containing only <code>0</code>s and <code>1</code>s, a K-bit flip consists of choosing a (contiguous) subarray of length <code>K</code> and simultaneously changing every <code>0</code> in the subarray to <code>1</code>, and every <code>1</code> in the subarray to <code>0</code>.</p>
<p>Return the minimum number of K-bit flips required so that there is no <code>0</code> in the array.  If it is not possible, return <code>-1</code>.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>A = [0,1,0], K = 1</code><br><strong>Output:</strong> <code>2</code><br><strong>Explanation:</strong> Flip <code>A[0]</code>, then flip <code>A[2]</code>.</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>A = [1,1,0], K = 2</code><br><strong>Output:</strong> <code>-1</code><br><strong>Explanation:</strong> No matter how we flip subarrays of size <code>2</code>, we can’t make the array become <code>[1,1,1]</code>.</p>
</blockquote></p>
<p><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> <code>A = [0,0,0,1,0,1,1,0], K = 3</code><br><strong>Output:</strong> <code>3</code><br><strong>Explanation:</strong><br>Flip <code>A[0]</code>,<code>A[1]</code>,<code>A[2]</code>: <code>A</code> becomes <code>[1,1,1,1,0,1,1,0]</code><br>Flip <code>A[4]</code>,<code>A[5]</code>,<code>A[6]</code>: <code>A</code> becomes <code>[1,1,1,1,1,0,0,0]</code><br>Flip <code>A[5]</code>,<code>A[6]</code>,<code>A[7]</code>: <code>A</code> becomes <code>[1,1,1,1,1,1,1,1]</code></p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>1 &lt;= K &lt;= A.length</code><a id="more"></a>
</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>先从数组的最左元素开始，因为要改变最左元素的状态，只能以这个元素为起始点。</p>
<p>如果这个元素是<code>1</code>，那么不需要<code>kBitFlip</code>操作；如果这个元素是<code>0</code>， 那么需要进行一次<code>kBitFlip</code>操作， <code>kBitFlip</code>的操作次数 <code>++ans</code>。当元素值变为<code>1</code>之后，进入下一个元素判断。</p>
<p>这样的操作最多进行<code>A.size() - K + 1</code>次。这样能保证<code>index</code>从<code>0</code>到<code>A.size() - K</code>的值都是<code>1</code>，只需要对剩下的元素进行检查。如果有<code>0</code>，<code>return -1</code>；否则<code>return</code> <code>kBitFlip</code>的操作次数<code>ans</code>。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (K &gt; A.size()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; A.size(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; A.size() - K + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                kBitFlip(A, K, i);</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j = A.size() - K; j &lt; A.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">kBitFlip</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="keyword">int</span> K, <span class="keyword">const</span> <span class="keyword">int</span> loc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = loc; i &lt; loc + K; ++i) &#123;</span><br><span class="line">            A[i] = (A[i]==<span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N * K)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/IUSI727XIwg" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Sliding Window</tag>
        <tag>Greedy</tag>
        <tag>Akuna Capital</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 996] Number of Squareful Arrays</title>
    <url>/Leetcode-996-Number-of-Squareful-Arrays/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.</p>
<p>Return the number of permutations of A that are squareful.  Two permutations A1 and A2 differ if and only if there is some index i such that <code>A1[i] != A2[i]</code>.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>[1,17,8]</code><br><strong>Output:</strong> <code>2</code><br><strong>Explanation:</strong><br><code>[1,8,17]</code> and <code>[17,8,1]</code> are the valid permutations.</p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>[2,2,2]</code><br><strong>Output:</strong> <code>1</code></p>
</blockquote></p>
<p><strong>Note:</strong> </p>
<ol>
<li><code>1 &lt;= A.length &lt;= 12</code></li>
<li><code>0 &lt;= A[i] &lt;= 1e9</code><a id="more"></a>
</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>经典的backtracking回溯算法:<br>用一个<code>vector&lt;int&gt; cur</code>记录当前的permutation, 用<code>vector&lt;bool&gt; used</code>记录第i个元素是否被选如当前的permutation中。<br>遍历过程中要判断重复元素的情况，因此需要先排序将重复的元素排在一起，每一轮遍历都只选择重复元素中第一个出现的。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSquarefulPerms</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (A.size() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(A.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="comment">// vector A must be sorted, the test case is not complete</span></span><br><span class="line">        sort(A.begin(), A.end());</span><br><span class="line">        <span class="comment">// do dfs</span></span><br><span class="line">        dfs(A, res, cur, used);</span><br><span class="line">        <span class="keyword">return</span> res.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.size() ==  nums.size()) &#123;</span><br><span class="line">            res.push_back(cur);            </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// prune的过程</span></span><br><span class="line">            <span class="keyword">if</span> (used[i] || (i &gt; <span class="number">0</span> &amp;&amp; !used[i<span class="number">-1</span>] &amp;&amp; nums[i]==nums[i<span class="number">-1</span>])) &#123; </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// check if it is a valid insert</span></span><br><span class="line">            <span class="keyword">if</span> (cur.size() &gt; <span class="number">0</span> &amp;&amp; !isSquare(cur.back() + nums[i])) &#123; </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            cur.push_back(nums[i]);</span><br><span class="line">            dfs(nums, res, cur, used);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// for backtracking in the next step</span></span><br><span class="line">            cur.pop_back();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSquare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span> &amp;&amp; num == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">sqrt</span>(num);</span><br><span class="line">        <span class="keyword">return</span> i * i == num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(N!)</code> 因为一共有<code>N！</code>种可能的排列组合，每一种都会遍历一遍<br>空间复杂度: <code>O(N * N!) = O(N!)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/V5eeRgQsr6o" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Apple</tag>
        <tag>Backtracking</tag>
        <tag>Math</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 997] Find the Town Judge</title>
    <url>/Leetcode-997-Find-the-Town-Judge/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>In a town, there are <code>N</code> people labelled from <code>1</code> to <code>N</code>.  There is a rumor that one of these people is secretly the town judge.</p>
<p>If the town judge exists, then:</p>
<ol>
<li>The town judge trusts nobody.</li>
<li>Everybody (except for the town judge) trusts the town judge.</li>
<li>There is exactly one person that satisfies properties 1 and 2.<br>You are given trust, an array of pairs <code>trust[i] = [a, b]</code> representing that the person labelled a trusts the person labelled <code>b</code>.</li>
</ol>
<p>If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return <code>-1</code>.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>N = 2, trust = [[1,2]]</code><br><strong>Output:</strong> <code>2</code></p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input:</strong> <code>N = 3, trust = [[1,3],[2,3]]</code><br><strong>Output:</strong> <code>3</code></p>
</blockquote></p>
<p><strong>Example 3:</strong><br><blockquote><p><strong>Input:</strong> <code>N = 3, trust = [[1,3],[2,3],[3,1]]</code><br><strong>Output:</strong> <code>-1</code></p>
</blockquote></p>
<p><strong>Example 4:</strong><br><blockquote><p><strong>Input:</strong> <code>N = 3, trust = [[1,2],[2,3]]</code><br><strong>Output:</strong> <code>-1</code></p>
</blockquote></p>
<p><strong>Example 5:</strong><br><blockquote><p><strong>Input:</strong> <code>N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]</code><br><strong>Output:</strong> <code>3</code></p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 1000</code></li>
<li><code>trust.length &lt;= 10000</code></li>
<li><code>trust[i]</code> are all different</li>
<li><code>trust[i][0] != trust[i][1]</code></li>
<li><code>1 &lt;= trust[i][0], trust[i][1] &lt;= N</code><a id="more"></a>
</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这是一道单向图的题，实际上我们要寻找图中入度为<code>N-1</code>,出度为<code>0</code>的点。<br>因为每个点的入度最大即为<code>N-1</code>（即村上所有其他人都<code>trust</code>他）,所以<code>入度 - 出度 = N - 1</code>是入度为<code>N-1</code>,出度为<code>0</code>的充分必要条件，所以本题用一个<code>counts</code>数组统计每个点入度和出度之差，遍历<code>trust</code>来更新<code>counts</code>数组，之后再遍历<code>counts</code>数组寻找值为<code>N-1</code>的点，返回坐标即可，如果在<code>counts</code>中不存在值为<code>N-1</code>的点，说明不存在judge，返回<code>-1</code>。</p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findJudge</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; trust)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">counts</span><span class="params">(N + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; relation : trust) &#123;</span><br><span class="line">            counts[relation[<span class="number">0</span>]]--;</span><br><span class="line">            counts[relation[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counts[i] == N - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(T + N)</code>, <code>T</code>为<code>trust</code>数组的长度<br>空间复杂度: <code>O(N)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/clkmS3_AP2w" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Graph</tag>
        <tag>Arista</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 999] Available Captures for Rook</title>
    <url>/Leetcode-999-Available-Captures-for-Rook/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>On an 8 x 8 chessboard, there is one white rook.  There also may be empty squares, white bishops, and black pawns.  These are given as characters ‘R’, ‘.’, ‘B’, and ‘p’ respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.</p>
<p>The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.  Also, rooks cannot move into the same square as other friendly bishops.</p>
<p>Return the number of pawns the rook can capture in one move.</p>
<p><strong>Example 1:</strong><br><img src="/Leetcode-999-Available-Captures-for-Rook/999_example_1_improved.PNG" width="250"><br><blockquote><p><strong>Input:</strong><br><code>[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</code><br><strong>Output:</strong> <code>3</code><br><strong>Explanation:</strong><br>In this example the rook is able to capture all the pawns.</p>
</blockquote><br><strong>Example 2:</strong><br><img src="/Leetcode-999-Available-Captures-for-Rook/999_example_2_improved.PNG" width="250"><br><blockquote><p><strong>Input:</strong><br><code>[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;R&quot;,&quot;B&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;B&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</code><br><strong>Output:</strong> <code>0</code><br><strong>Explanation:</strong><br>Bishops are blocking the rook to capture any pawn.</p>
</blockquote><br><strong>Example 3:</strong><br><img src="/Leetcode-999-Available-Captures-for-Rook/999_example_3_improved.PNG" width="250"><br><blockquote><p><strong>Input:</strong><br><code>[[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;p&quot;,&quot;p&quot;,&quot;.&quot;,&quot;R&quot;,&quot;.&quot;,&quot;p&quot;,&quot;B&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;B&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;p&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],</code><br><code>[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]]</code><br><strong>Output:</strong> <code>3</code><br><strong>Explanation:</strong><br>The rook can capture the pawns at positions <code>b5</code>, <code>d6</code> and <code>f5</code>.</p>
</blockquote><br><strong>Note:</strong></p>
<ol>
<li><code>board.length == board[i].length == 8</code></li>
<li><code>board[i][j]</code> is either <code>&#39;R&#39;</code>, <code>&#39;.&#39;</code>, <code>&#39;B&#39;</code>, or <code>&#39;p&#39;</code></li>
<li>There is exactly one cell with <code>board[i][j] == &#39;R&#39;</code><a id="more"></a>
</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>题目问从<code>&#39;R&#39;</code>点开始上下左右直走，碰到<code>&#39;B&#39;</code>，<code>&#39;p&#39;</code>，或者边界则停止，可能遇到多少个<code>&#39;p&#39;</code>.<br>我们用<code>count_p</code>记录可能遇到的<code>p</code>的数量，遍历整个<code>board</code>。<br>当遇到<code>&#39;R&#39;</code>时，我们尝试从<code>&#39;R&#39;</code>的位置开始，向四个方向移动：<br>1) 当遇到边界，则停止当前方向探索<br>2) 当遇到<code>&#39;B&#39;</code>时，则停止当前方向探索<br>3) 当遇到<code>&#39;p&#39;</code>时，<code>count_p++</code>并停止当前方向探索<br>4) 当四个方向均探索完毕，则可以直接返回<code>count_p</code><br>如果遍历<code>board</code>结束仍没有返回，则说明不存在<code>&#39;R&#39;</code>，可返回<code>0</code></p>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="comment">// move one step towards four directions</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> kBoardSize = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numRookCaptures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count_p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kBoardSize; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; kBoardSize; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'R'</span>) &#123;</span><br><span class="line">                    <span class="comment">// Once we find 'R', move towards each of the four directions.</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dirs.size(); ++k) &#123;</span><br><span class="line">                        <span class="keyword">int</span> cur_x = i, cur_y = j;</span><br><span class="line">                        <span class="comment">// When not reaching boundary</span></span><br><span class="line">                        <span class="keyword">while</span> (cur_x &gt;= <span class="number">0</span> &amp;&amp; cur_x &lt; kBoardSize &amp;&amp; cur_y &gt;= <span class="number">0</span> &amp;&amp; cur_y &lt; kBoardSize) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (board[cur_x][cur_y] == <span class="string">'B'</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (board[cur_x][cur_y] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                                ++count_p;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            cur_x += dirs[k][<span class="number">0</span>];</span><br><span class="line">                            cur_y += dirs[k][<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Since we assume at most one 'R' existed on the board</span></span><br><span class="line">                    <span class="keyword">return</span> count_p;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We could not find 'R' on the board</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>时间复杂度: <code>O(mn + (m + n)) =&gt; O(mn)</code><br>空间复杂度: <code>O(1)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这道题并不是很难，但是理解题目需要些时间，面试的时候可能会用来作为warm up，关键是和面试官多交流，理解题目的意思，不要着急盲目开始做。<br>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/UspBaHqxjfE" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Square</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>机械系PhD如何转行成为程序员</title>
    <url>/Mechanical-Engineering-Phd-To-Software-Engineer/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>“大猩猩”给大家带来的非CS专业PHD毕业转行做码农的总结。算不上⼀次非常成功的经历，但其中的经验教训希望能给有相似背景的同学带来⼀点帮助。主要针对在北美非CS专业的PhD学⽣，想在美国转行做软件工程相关行业的的同学。</p>
<img src="/Mechanical-Engineering-Phd-To-Software-Engineer/mathworks_logo.png" width="300">
<a id="more"></a>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>背景介绍</p>
<blockquote><p>大猩猩本人</p>
<p>北京大学 力学专业本科</p>
<p>Rutgers University 机械工程 PhD</p>
<p>MathWorks simulink组 软件工程师</p>
</blockquote>
<p>简单介绍一下自己的背景。目前Rutgers PhD机械工程(ME)毕业，同时攻读了统计专业master。即将入职MathWorks做SDE（软件工程师），说Mathworks大家可能不熟悉，其实他们的核心产品就是Matlab，相信很多同学都用到过。</p>
<p>12年秋季我从北大力学专业本科毕业进入Rutgers ME攻读博士学位。博士研究的主要方向是连续介质力学、材料理论建模和相关的数值模拟。简单来说非常偏向理论，与industry的联系很少。16年年初对未来从事本专业工作有了很大犹豫，决定转专业求职。其中过程会在下文继续详谈。</p>
<p>读博的决定对很多同学来说并没有在最开始就考虑清楚利弊。读博的时间很长，一般至少5年。毕业后从事什么行业，这个行业的就业前景、发展如何往往会是我们需要关心的问题。但是相信很多有过博士经历的同学会发现，除去北美的热门专业（例如CS，ECE之类），有时候真的很难在市场中找准自己的位置。原因或者有些专业确实市场的需求不大，又或者对国际学生就业的难度会很大（因为身份因素，很多工作虽然很合适，但无法申请）。对名校的PhD，更好的network和reputation会让他们在自己专业的求职中更有优势。但是对大部分同学来说，可能求职的另外一个选择就是转行了。这是个⾮常现实的现象。</p>
<p>就我个人情况而言，由于我的PhD research方向非常偏向理论，又没有实验室技能，当我念了几年PhD，发现自己专业方向的求职前景并不理想。由于个人的情况，还是希望能把PhD学位拿到，因此考虑到之后求职，自然想到了往别的专业转行。当时考虑的有以下几个⽅方向：data、金融、CS或者咨询。都算是比较热门和大家熟知的。结合自己的情况后，决定在学校修一个统计master的二专业，将来往data scientist方向靠。当然之后为什么会找SDE，我会继续说明。</p>
<p>PhD转行的原因有很多种，但总体来说要么自己不喜欢自己专业，要么⾃己专业求职困难，迫于实际情况不得已。我知道很多同学一开始并没有想明白为什么自己要读PhD，也有很多同学在念PhD的过程中因为文章等原因非常痛苦。各种现实的压力会随着年岁的增长在PhD攻读的过程中越来越大，尤其对冷门专业的同学，更是如此。所以，一旦自己有了想改变的念头，希望大家能仔细的咨询周围的朋友老师，对行业情况尽可能的了解再做出决定。而一旦下定决心要去做改变，就越快越好。当然，任何时候你都应该勇敢的去做出你认为对的决定，哪怕你PhD已经念了5、6年还远远未达到毕业标准。改变并不会因为你选择的晚变得无效，可怕的是明知道不变不行而不去做改变。</p>
<h4 id="第二专业"><a href="#第二专业" class="headerlink" title="第二专业"></a>第二专业</h4><p>很多转行的PhD并没有选择念二专业。这当然是可以的。通过自己的⾃学，很多同学也成功转行进入了自己理想的行业。当然，我之所以选择修二专业是基于以下几点：</p>
<ol>
<li>我认为二专业能让自己的简历变得能更match一些职位。这点对freshman还是挺重要的。同时通过课堂上的学习和project练习，确实能学到很多东西，也能丰富自己的简历。</li>
<li>自己还学有余力，自己PhD research的压力并没有太大。我的老板的指导方式也比较“散养”，不是非常push的那种。</li>
<li>我和自⼰老板沟通过，也得到了我老板的支持。有些PhD的老板并不会支持自己学生做这些，遇到这样的情况，就得自⼰衡量了。是瞒着自己的老板去学，还是继续和老板做好沟通。不同的选择各有利弊，每个人的情况都不同，这里我就不好给出更多建议。</li>
</ol>
<p>我们学校master需要修10门课，我花了大概2年多总共5个学期修完。不算是很快，主要是同时还有PhD的工作需要完成。期间除了一些基础课之外，重点修了算法，AI 和机器学习之类的课。因为想往data scientist方向靠拢，所以还学习了与数据分析相关的一些课。</p>
<h4 id="关于实习"><a href="#关于实习" class="headerlink" title="关于实习"></a>关于实习</h4><img src="/Mechanical-Engineering-Phd-To-Software-Engineer/xingxings.png" width="300">
<p>对于转行的同学，找full time position一大困难应该就是没有相关背景，这点会让简历关都很难通过。所以如果能有一两个实习会有很大帮助。我的第一个实习是在HPE公司下面的一个数据库子公司的machine learning组，project是在数据库里实现一个算法服务。这和我原先预想的data scientist方向区别很大，完全是software engineer的工作。我当时对职业并没有太清晰的理解，因为是朋友⼀个很强力的内推，当时也没有别的更好的机会，刷了几个星期的题，通过了面试就去了。这个实习对我的帮助还是很大的，同时也起到了敲门砖的作用。自⼰不是cs专业，所以从中也学到了很多实用的东西。</p>
<p>其实第一个实习结束已经是我PhD第五年了。秋季开学是第六年。按理我开学就应该开始找工作了。但是当时一方⾯thesis还有部分内容没有完成，一方面自己有些拖拉，直接导致了当时自己错过了很多求职的机会。等觉得应该抓紧找工作的时候已经快11月了。现在想来，这是非常不应该的。同学们⼀定要从我这里吸取教训。</p>
<p>之后还是通过同学和朋友的内推，分别获得了一家大公司和一家小公司的onsite机会。但是都没有通过。大公司的职位是一个类似带consult性质的data analyst，自己去面试时发现并不是很喜欢这个工作，当然面试也被拒了。小公司是国内在美国这里开的一个AI实验室，面试不是很理想，但对方提出了可以提供给我一个暑期实习的机会。当时时间已经到了2⽉，针对new grad的职位基本没了，而对社招的职位，自⼰的竞争力明显不够。考虑再三，决定去接了这个实习，延期自⼰毕业的时间，等第二个实习结束全力再找full time job，也明确把自己定位在找sde的工作。</p>
<p>这两个实习，对我最后找到工作有很大的帮助。个人体会，主要是让自⼰的简历变得能”看“了，可以通过简历关获得面试。而获得面试，是很重要的第一步。</p>
<h4 id="关于full-time求职"><a href="#关于full-time求职" class="headerlink" title="关于full-time求职"></a>关于full-time求职</h4><p>我想很多人很多文章（当然包括我们自己的公众号）有提到找工作的各种细节。因此，介于我最终也没有找到最top的公司，算不上什么大牛，我就不多做讨论，只谈一些我在这过程中个人的理解。</p>
<p>首先想说，对SDE，对转专业的同学，最重要的准备工作就是刷题，好好刷题，<a href="/categories/leetcode">认真刷题</a>。因为美国SDE的tech面试，一般最直接的就是做题。确实实际的工作，和刷题并没有太多关系。但这就是在面试过程中最硬的指标，尤其对entry level的position。其实这一步对于转专业的同学有好处，因为只要通过练习，刷题，完全可以做到与cs专业的同学一样的水平。相较而言，对于cs的基础知识，project、实习甚至面试官对非科班出身的人的刻板印象，往往很多不是我们自己能一时之间可以改变。</p>
<p>其次是内推。内推是最好能拿到面试机会的方法。大家应该尽可能发动自己的network，联系自己的好友、同学、朋友和老师，和对方说明清楚自己的情况或者让对方拥有一份自己的简历。哪怕当时并没有机会，未来也可能会有opening。同时，linkedin、一亩三分地等求职社交论坛上也会有很多人愿意提供内推的机会，应该积极去联系。这些人可能是你的校友，可能是你朋友的朋友，也可能根本不不认识你，但你都应该去尝试建立network。就算别⼈没给你feedback，你也不会有所损失。比起海投，内推往往能保证通过简历筛选的第一关，甚至可能直接让你的hire manager看到，会大大增加你拿到面试的机会。</p>
<p>接着是对于公司的选择。个人感觉对于简历单薄的同学，大公司（比如FLAG之类）往往对于我们会有更友好的态度，更愿意提供机会和培养新人。而小公司更侧重于你的实际技能能不能马上投入工作中，反而会更难拿到面试。所以不用觉得⾃自己这里或者那里不够，就对大公司有些失去信心，相反你反而更可能在那里获得机会。</p>
<p>最后是onsite这点。自我总结一下，我一共只去过5家onsite，分别是IBM，Google，Bloomberg，MathWorks 和实习去的那家小公司。最终只有MathWorks拿到offer，成绩不算是很好。IBM不是SDE的工作，不做评价；BB自我感觉被老印黑了；GG可能是和面试官的沟通不够好，虽然面完感觉不错，但结局还是挂了。那家小公司面试完对我评价不高，但事后了解也有部分人事关系，实习之后，公司对我的表现还是比较满意的，我个人也很感谢他们能提供给我这个实习的机会，公司也有return offer的意向，但我基于综合的考量并没有move on。但总体来说，面试次数多了后，还是有不少提升，自信也有提高。所以如果一开始onsite发挥的不好，一定不要灰⼼。通过不断的练习，一定可以发挥的越来越好。</p>
<img src="/Mechanical-Engineering-Phd-To-Software-Engineer/daxingxing.png" width="250">
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这次求职，拿到了offer，也不算太坏。对这个结果，我给自⼰打个及格分吧。自身的实力还是不够，所以像Google、Bloomberg这样的公司，最终还是失败了了。有些遗憾，但也只能move on。未来的路还很长，不论是技术上还是别的方面，自己还有很多可以继续努力的空间。希望我分享的这些经验教训能给朋友们带来些许帮助，有想沟通交流的朋友欢迎留言。大家共勉~</p>
<p>想要发现更多求职信息请<a href="https://article.xingxingpark.com/category/career/" target="_blank" rel="noopener">点击这里</a>:)</p>
]]></content>
      <categories>
        <category>career</category>
      </categories>
      <tags>
        <tag>Mathworks</tag>
      </tags>
  </entry>
  <entry>
    <title>东北大学(NEU)博士如何获得谷歌和亚麻的大包</title>
    <url>/NEU-phd-to-Google/</url>
    <content><![CDATA[<h4 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h4><p>这篇文章是一位PKU，NEU CS Phd师兄的求职经历，文中会提及职业发展建议，技术面试准备，以及行为面试应该如何作答（想要发现更多求职信息请<a href="https://article.xingxingpark.com/category/career/" target="_blank" rel="noopener">点击这里</a>）。</p>
<a id="more"></a>
<h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><blockquote><p>北京大学 计算机系本科 + 硕士研究生</p>
<p>Northeastern University 计算机系 PhD</p>
<p>Offer：Amazon L5， Google T4</p>
<p>去向：Google Ads组 SDE</p>
</blockquote>
<p>我从本科开始就一直是计算机系的，当年想在国内找工作所以读了研究生，但是后来发现还是想出来做做科研，于是在毕业前申请了PhD。 </p>
<p>这里我的建议是：如果想做科研，那就读Phd，如果想去工业界做码工，应该越早越好——本科毕业最好。因为本科和硕士毕业在公司级别往往是一样，PhD有时也是一样的，即使高一级，五六年的时间成本如果本科直接进公司可以升好几级了。另外公司的训练完全可以抵得上硕士的专业训练，而且很多学校提供兼职读硕士的机会，公司还会报销部分（甚至全部）学费。本科毕业读硕士应当是在想出国，或者没有很好的offer的情况下才考虑的选项。</p>
<p>科研 vs 码工：以前是抱着一颗科研之心来读博的，但是现在学术界竞争激烈而自己水平有限，就不加入了。有追求有梦想的同学一定要坚持。</p>
<p>实习： 强烈推荐，实习中学到的东西比刷题有用多了。而且实习后的return offer一般最靠谱，拿到了心里也有底，如果想的话也能再去投其他家，不慌。</p>
<h4 id="2-找工准备"><a href="#2-找工准备" class="headerlink" title="2. 找工准备"></a>2. 找工准备</h4><img src="/NEU-phd-to-Google/dongge_biking.jpeg" width="300" title="NEU Phd to Google Biking">
<p>自从2018年初开始就想着准备找工作了，但是并没有实际付诸行动。一直忙于做实验和写论文，想着把毕业前最后一篇写出来就可以安心刷题了。只是没想到一拖就是半年，终于在六月底开始行动了。根据个人经验，劝想要找工作的各位，一定要早点开始，不要等到“闲下来”再去做，也许突然老板让你做一个项目，也许你高估了自己完成事情的能力（对我来说这个经常发生），真正闲下来时已经过去好久了。每天哪怕只做一道题，也能积累一个很大的数量。</p>
<p>说正题，对一个 new grad，找工作主要就是刷题。我是先把要刷的题目类型先总结了一下，这个在网上有很多的 blog 都总结的不错，也有各种主流公司的高频、爱考什么题型等等。各大刷题网站上也有 tag。建议大家先去看一下，做到心里有数，开始练习的时候就知道自己哪类题目已经可以了，哪一类还不够明白。刷题的方法这个见仁见智。我的建议是，如果开始准备的时候觉得简单的题也想不明白，那多半是基础没打好，需要去复习一下 algorithm and data structure，把基本概念和常用知识搞清楚先。</p>
<p>尽管上过算法课，之前找实习的时候也刷过几道题，我在去年开始刷题的时候也没有觉得很顺利。很多题目都有corner case，不容易一次就 bug free。我开始也有点挫折，觉得自己这么多年 CS 白读了。不过渐渐的有了些经验，思路也理顺了。常考的题目类别并不是很多，只要坚持下去，自信心就会逐渐上升。</p>
<p>等刷题有了信心之后，就可以开始申请职位了。这个过程中内推很重要，没有内推的话，对于一个 new grad 来讲是很难拿到面试机会的。建议在刷提前就联系一下认识的朋友、同学等等，发展一下关系网。大家一般都乐意给你推荐。当然要有诚意一些，对于不太熟的内推者（朋友的朋友这样的），听说要尽量把自己的简历和刷题情况通报给对方，让对方心里有底可以帮你吹一吹。如果面试表现太差的话对内推的人也不太好。有人没准备就去面试，结果面试官很生气的在公司里问“到底是谁把人推荐来的！？”。</p>
<p>（小编补充：内推一般都会有个评分系统，会问这个人你觉得在你见过的人当中排百分之多少，如果没有比较好的背景或者和内推人很熟，一般内推人不会给很高分，那对面试者并不会有好处）</p>
<p>我前后一共投了十家公司，其中有HR联系我的有六家，拿到电面的有五家。石沉大海的四家里，两家是没有内推，两家是投的太晚（2月才申请）估计已经招满了。看来最好是赶在秋招前期就安排面试，早点占据head count。我是写 paper花了太多时间，到今年一月底才开始系统的申请。大家引以为戒。</p>
<h4 id="3-面试"><a href="#3-面试" class="headerlink" title="3. 面试"></a>3. 面试</h4><img src="/NEU-phd-to-Google/dongge_meeting.jpeg" width="300" title="NEU Phd To Google In a Facebook Meeting">
<p>先说电面，我觉得比onsite还随机，一道题就决定是不是能过。除了多刷题多看面经，还要注意跟interviewer的交流，有不确定的地方就立即问一问，对方一般也乐意多解释，这样也利于你思考。我不建议听完题目后就自己立即开始做，哪怕跟interviewer重复一下你对题目的理解，也是有点用的，说不定开始你理解错了呢。这个过程中也要注意时间，有个思路并且理清之后就立刻写。电面一般不会很难，但要注意follow up的问题。</p>
<p>我投的都是developer，但其中一个电面事先我没问清楚，结果问了很多Machine Learning的问题，必然是挂了，尴尬。事先要问清楚HR这个岗位需要的是什么skill set。</p>
<p>再说onsite，这个没话说，就是看刷题是不是够好，以及跟interviewer的交流。Amazon的每轮面试会花一半时间问behavior question，就是考他们的leadership principle，这个网上有很多总结，一定要事先准备好。一般会被问到这样的问题：说一下你面对工作上困难的经历，你有没有收到过非常差的工作评价然后你是怎么做的，如果你不喜欢某个同事但又要跟他/她在一个项目上合作你会怎么办，谈一谈你面对压力时工作的经历。不要说你没有这样的经历！我在准备这类问题的时候就把自己之前遇到过的一些事情整理一下，跟 leadership principle 做做关联，也就是说在讲自己的故事的时候让面试官知道我的处理方法体现了某条 principle。我的感受是，在讲自己经历的时候要有细节，不能简单的说“我多投入了时间然后完成了项目”，一定要多讲自己采取了具体什么方式，比如可以说“听说某个项目A遇到了困难，我于是立即跟老板谈了一下，把另一个项目的deadline退后，每天花半天时间在A项目上，在网上搜索相关的解决办法，并且跟同事多讨论，请教有相关知识背景的人，最后尝试了多个方法后终于发现其中某一两个方法是有效的，然后在deadline前解决了问题”；甚至可以多说两句 – “我还在项目上添加了XYZ feature，这个是客户之前并没有提到的，但是我觉得将来会很有用，于是跟客户提出来，客户很认可” – 这样的话就可以关联到 dive deep, obsessed with customer, ownership 这几条principle。这些是看网上很多前辈总结出来的经验，尝试了一下，似乎效果不错。</p>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><img src="/NEU-phd-to-Google/dongge_mountain.jpeg" width="300" title="NEU Phd To Google Thinking on a mountain">
<p>最后四个onsite拿到三个offer，还有一个公司四个interviewer全给了hire但没strong hire所以他们招了别人。</p>
<p>最后去了谷歌，需要relocate到湾区，也是比较纠结因为本来想留在波士顿的，但还是更喜欢G家，也想趁着还“年轻”去硅谷看看。波士顿机会也不错，将来希望越来越好。</p>
<p>想要发现更多求职信息请<a href="https://article.xingxingpark.com/category/career/" target="_blank" rel="noopener">点击这里</a>:)</p>
]]></content>
      <categories>
        <category>career</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 145] Binary Tree Postorder Traversal</title>
    <url>/leetcode-145-Binary-Tree-Postorder-Traversal/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>Given a binary tree, return the <em>postorder</em> traversal of its nodes’ values.</p>
<p>For example:</p>
<p>Given binary tree [1,null,2,3],</p>
<pre><code>1   
 \
  2
 /
3
</code></pre><p>return [3,2,1]. </p>
<p><strong>Note</strong>: Recursive solution is trivial, could you do it iteratively?</p>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>深度遍历二叉树（<code>DFS</code>），可以分为</p>
<ul>
<li>前序遍历（<code>preorder</code>）</li>
<li>中序遍历（<code>inorder</code>）</li>
<li>后序遍历（<code>postorder</code>）</li>
</ul>
<p>这题要求使用后序遍历。后序遍历按照左子节点（<code>left</code>），右子节点（<code>right</code>），根节点（<code>root</code>）的顺序深度遍历二叉树。</p>
<p>同样，我们可以使用递归与非递归两种方法来实现前序遍历。递归的方法还是比较简单，参看相关代码就能明白。后序遍历的非递归的方法相比前序遍历与中序遍历而言，相对比较复杂，每个根节点我们都要visit两次，逻辑上需要大家仔细思考。</p>
<p>我们依然可以通过栈（<code>stack</code>）实现，总体思想为方位左子节点，直到其为空，同时将访问过得节点和其右子节点存入栈中。当退回是需要判断节点的右子节点是否为空， 从而可以确定是否访问该节点还是访问该节点的右子节点：</p>
<p>使用栈（<code>stack</code>），每次visit当前节点<code>node</code>，同时如果当前节点的右子节点非空，将此右子节点存入栈中。然后将当前节点<code>node</code>压入栈中，并将当前节点更新为其左子节点，知道当前节点<code>node</code>为空。</p>
<p>之后当栈非空，如果栈顶元素的右子节点不等于该元素退栈后的栈顶元素，则将栈顶元素存入答案数组，退栈，并将当前节点<code>node</code>设为空。反之，交换栈顶的两个节点，并将当前节点设为栈顶元素，并退栈。</p>
<p>重复上述两个步骤，直到遍历完整棵二叉树。具体流程为：</p>
<ol>
<li><p>建立一个空栈<code>stack</code></p>
</li>
<li><p>如果当前节点<code>node</code>非空或者栈<code>stack</code>非空：</p>
<ul>
<li><p>2.1 如果当前节点<code>node</code>非空：</p>
<ul>
<li>如果当前节点的右子节点非空：将右子节点存入栈中</li>
<li>将当前节点<code>node</code>压入栈</li>
<li>更新当前节点<code>node</code>为它的左子节点，回到步骤2.1</li>
</ul>
</li>
<li><p>2.2 如果栈非空:</p>
<ul>
<li>将当前节点<code>node</code>设为栈顶元素并退栈</li>
<li>如果栈非空并且栈顶元素等于当前节点的右子节点：<br>交换当前节点和栈顶元素。 反之访问并将当前节点<code>node</code>存入答案数组<code>ans</code>, 并将当前节点设为空</li>
<li>回到步骤2</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="示例代码-（递归-python版）"><a href="#示例代码-（递归-python版）" class="headerlink" title="示例代码 （递归 python版）"></a>示例代码 （递归 python版）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">postorderhelper</span><span class="params">(root, ans)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                postorderhelper(root.left, ans)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            postorderhelper(root.right, ans)</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">        ans = []</span><br><span class="line">        postorderhelper(root, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-（递归-c-版）"><a href="#示例代码-（递归-c-版）" class="headerlink" title="示例代码 （递归 c++版）"></a>示例代码 （递归 c++版）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postorderHelper</span><span class="params">(TreeNode* curr, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!curr) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        postorderHelper(curr-&gt;left, ret);</span><br><span class="line">        postorderHelper(curr-&gt;right, ret);</span><br><span class="line">        ret.push_back(curr-&gt;val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        postorderHelper(root, ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-（非递归-python版）"><a href="#示例代码-（非递归-python版）" class="headerlink" title="示例代码 （非递归 python版）"></a>示例代码 （非递归 python版）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cur = root</span><br><span class="line">        stack = collections.deque()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span>(cur <span class="keyword">or</span> stack):</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="keyword">if</span> cur.right:</span><br><span class="line">                    stack.append(cur.right)</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">if</span> stack:</span><br><span class="line">                cur = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> stack <span class="keyword">and</span> cur.right == stack[<span class="number">-1</span>]:</span><br><span class="line">                    tmp = stack.pop()</span><br><span class="line">                    stack.append(cur)</span><br><span class="line">                    cur = tmp</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append(cur.val)</span><br><span class="line">                    cur = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h4 id="示例代码-（非递归-c-版）"><a href="#示例代码-（非递归-c-版）" class="headerlink" title="示例代码 （非递归 c++版）"></a>示例代码 （非递归 c++版）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; nodeStack;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">bool</span>&gt; stackLR; <span class="comment">// False for Only Visited Left, True for Visited Left and Right</span></span><br><span class="line">        <span class="keyword">bool</span> lr = <span class="literal">false</span>;</span><br><span class="line">        TreeNode* curr = root;</span><br><span class="line">        <span class="keyword">while</span>(curr || !stackLR.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr) &#123;</span><br><span class="line">                <span class="keyword">while</span>(curr-&gt;left) &#123;</span><br><span class="line">                    nodeStack.push(curr);</span><br><span class="line">                    stackLR.push(<span class="literal">false</span>);</span><br><span class="line">                    curr = curr-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                nodeStack.push(curr);</span><br><span class="line">                stackLR.push(<span class="literal">true</span>);</span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = nodeStack.top();</span><br><span class="line">            nodeStack.pop();</span><br><span class="line">            lr = stackLR.top();</span><br><span class="line">            stackLR.pop();</span><br><span class="line">            <span class="keyword">if</span> (lr) &#123;</span><br><span class="line">                ret.push_back(curr-&gt;val);</span><br><span class="line">                curr = <span class="literal">NULL</span>;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nodeStack.push(curr);</span><br><span class="line">                stackLR.push(<span class="literal">true</span>);</span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>对递归方法，每个节点都被访问一次，考虑到本题并非平衡二叉树，最差将退化成链表，递归栈最大深度为<code>O(n)</code>。所以复杂度分析为：</p>
<ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>空间复杂度：<code>O(1)</code>, &#160; 递归栈深度<code>O(n)</code></li>
</ul>
<p>对非递归方法，同样每个节点都被访问一次，考虑到本题并非平衡二叉树，最差将退化成链表，栈最大深度为<code>O(n)</code>。所以复杂度分析为：</p>
<ul>
<li>时间复杂度： <code>O(n)</code></li>
<li>空间复杂度：<code>O(n)</code></li>
</ul>
<h4 id="总结归纳："><a href="#总结归纳：" class="headerlink" title="总结归纳："></a>总结归纳：</h4><p>今天我们讲了二叉树的后序遍历，结合之前我们介绍的前序遍历、中序遍历，希望能对感兴趣的朋友有所帮助。</p>
<p>后序遍历的非递归实现相对前序遍历、中序遍历而言复杂一点，但只要逻辑上清晰，严格按照后序遍历的定义去做，也不难实现。</p>
<p>相关的练习还有：</p>
<p><a href="/Leetcode-144-Binary-Tree-Preorder-Traversal">[LeetCode 144] Binary Tree Preorder Traversal 二叉树前序遍历</a></p>
<p><a href="/Leetcode-94-Binary-Tree-Inorder-Traversal">[LeetCode 94] Binary Tree Inorder Traversal 二叉树中序遍历</a></p>
<p><a href="/Leetcode-102-Binary-Tree-Level-Order-Traversal">[LeetCode 102] Binary Tree Level Order Traversal 二叉树层序遍历</a></p>
<p>之后我们会继续讨论更多Tree相关的内容,并更新在 <a href="/tags/Tree">Tree Tag</a>，尽请期待，种香蕉树去了：）</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>[Leetcode 994] Rotting Oranges</title>
    <url>/leetcode-994-rotting-oranges/</url>
    <content><![CDATA[<h4 id="原题说明"><a href="#原题说明" class="headerlink" title="原题说明"></a>原题说明</h4><p>In a given grid, each cell can have one of three values:</p>
<ul>
<li>the value 0 representing an empty cell;</li>
<li>the value 1 representing a fresh orange;</li>
<li>the value 2 representing a rotten orange.</li>
</ul>
<p>Every minute, any fresh orange that is adjacent (4-directionally) to a rotten orange becomes rotten.</p>
<p>Return the minimum number of minutes that must elapse until no cell has a fresh orange.  If this is impossible, return -1 instead.</p>
<p><strong>Example 1:</strong><br><blockquote><p><strong>Input:</strong> <code>[[2,1,1],[1,1,0],[0,1,1]]</code><br><strong>Output:</strong> <code>4</code></p>
</blockquote></p>
<p><strong>Example 2:</strong><br><blockquote><p><strong>Input</strong>: <code>[[2,1,1],[0,1,1],[1,0,1]]</code><br><strong>Output</strong>: <code>-1</code><br><strong>Explanation</strong>:  The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.</p>
</blockquote></p>
<p><strong>Example 3:</strong><br><blockquote><p><strong>Input</strong>: <code>[[0,2]]</code><br><strong>Output</strong>: <code>0</code><br><strong>Explanation</strong>:  Since there are already no fresh oranges at minute 0, the answer is just 0.</p>
</blockquote></p>
<p><strong>Note:</strong></p>
<ol>
<li><code>1 &lt;= grid.length &lt;= 10</code></li>
<li><code>1 &lt;= grid[0].length &lt;= 10</code></li>
<li><code>grid[i][j] is only 0, 1, or 2</code>.<a id="more"></a>
</li>
</ol>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>这类问题问需要多少时间遍历整个二维数组，并且每次遍历一次，自然想到要用广度优先搜索（BFS）来做：</p>
<ol>
<li>遍历二维数组，统计新鲜橘子(value=1)的数量<code>fresh_count</code>，并且将烂橘子(value=2)的坐标加入队列qu</li>
<li>minutes为经过的时间，如果队列qu非空且<code>fresh_count</code>不为0，则用BFS方法遍历当前队列qu中所有元素<br> i）如果其周围有新鲜橘子，则<code>fresh_count--</code>，将其坐标加入qu，并更新为烂橘子(value=2)<br> ii) 否则直接跳过<br>每一轮遍历完使<code>minutes++</code></li>
<li>如果<code>fresh_count</code>不为0，则返回-1，否则返回<code>minutes</code></li>
</ol>
<h4 id="示例代码-cpp"><a href="#示例代码-cpp" class="headerlink" title="示例代码 (cpp)"></a>示例代码 (cpp)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; qu;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">if</span> (!m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> minutes = <span class="number">0</span>, fresh_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ++fresh_count;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    qu.push(i * n + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!qu.empty() &amp;&amp; fresh_count != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = qu.size(); i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">int</span> cur = qu.front();</span><br><span class="line">                qu.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">int</span> x = cur / n + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y = cur % n + dir[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] != <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                    qu.push(x * n + y);</span><br><span class="line">                    --fresh_count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++minutes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fresh_count) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minutes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>因为只遍历了一遍二维数组，所以时间空间复杂度都是二维数组中元素个数<br>时间复杂度: <code>O(m * n)</code><br>空间复杂度: <code>O(m * n)</code></p>
<h4 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h4><p>这道题稍微与一般BFS不同的是截止条件判断需要为:<code>!qu.empty() &amp;&amp; fresh_count != 0</code>，即除了队列为空外，还要判断新鲜橘子还有没有。<br>另外，遍历二维数组时常用的找到周边上下左右坐标的方法:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>以及如果将二维坐标<code>(i, j)</code>转换为一维的index: <code>i * n + j</code> 也是需要熟练掌握的。<br>我们在<strong>Youtube</strong>上更新了<a href="https://youtu.be/GSc-F_jlYWk" target="_blank" rel="noopener">视频讲解</a>，欢迎关注！</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>Amazon</tag>
        <tag>Breadth-first Search</tag>
      </tags>
  </entry>
</search>
